- [x] List
- [x] Map
- [ ] Set
- [ ] Queue
- [ ] 其他

> <font style="color:rgb(51, 51, 51);">Java集合分为 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">Collection</font>`<font style="color:rgb(51, 51, 51);">接口，主要用于存放单一元素；另一个是 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">Map</font>`<font style="color:rgb(51, 51, 51);"> 接口，主要用于存放键值对。</font>
>
> `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">Collection</font>`<font style="color:rgb(51, 51, 51);"> 接口又有三个主要的子接口：</font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">List</font>`<font style="color:rgb(51, 51, 51);">、</font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">Set</font>`<font style="color:rgb(51, 51, 51);"> 、 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">Queue</font>`<font style="color:rgb(51, 51, 51);">。</font>
>

## <font style="color:rgb(51, 51, 51);">List</font>
### 列表
<details class="lake-collapse"><summary id="u480e4890"><span class="ne-text" style="color: rgb(51, 51, 51)">List vs 数组</span></summary><p id="u3a1d8b32" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。</span></p><p id="ub4ec1b9b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">数组可以包含基本数据类型和对象，而集合只能包含对象。</span></p><p id="u1bb92e0f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</span></p></details>
<details class="lake-collapse"><summary id="u803fa36e"><span class="ne-text" style="color: rgb(51, 51, 51)">List可以一边遍历一边修改元素吗？</span></summary><p id="u27c9be89" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">决于遍历方式和具体的</span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)">实现类</span></strong></p><p id="uc3c0baf8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">使用普通for循环遍历</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可以</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">在遍历过程中修改元素，只要修改的索引不超出</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">的范围即可。</span></p><p id="u27cca175" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">使用foreach循环遍历</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不可以</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，因为这可能会导致意外的结果或</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentModificationException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">异常。因为</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">foreach</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">循环底层是基于迭代器实现的，在</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">foreach</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">循环中修改元素可能会破坏迭代器的内部状态。</span></p><p id="u1ff04380" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">使用迭代器遍历</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可以</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">使用迭代器的</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">方法来删除元素，通过迭代器的</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">set</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">方法修改元素。不能通过</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">的</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">set</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">方法，否则也可能发生</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentModificationException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">异常。</span></p><p id="u3015a3aa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">4，对于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程安全的</span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">，如</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CopyOnWriteArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">由于其采用了写时复制的机制，在遍历的同时可以进行修改操作，不会抛出</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentModificationException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">异常,但是可能会读取到旧的数据，因为修改操作是在新的副本上进行的。</span></p></details>
### <font style="color:rgb(51, 51, 51);">ArrayList </font>
<details class="lake-collapse"><summary id="u0b0875a3"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">ArrayList </span></strong><strong><span class="ne-text">是什么？懒加载，扩容和</span></strong><strong><span class="ne-text" style="color: rgb(51, 51, 51)">复杂度</span></strong></summary><p id="u8c8bdb6c" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">是基于数组实现的可变长度的列表。它实现了</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">RadomAccess</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">标记接口，支持索引快速访问。底层就是一个Object[]数组。线程不安全。</span></p><p id="u67646e62" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">懒加载</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：如果你没有指定大小那它是懒加载的，创建了一个</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">的时候并不会立刻分配数组，而是把内部的</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">elementDate</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">指向一个共享的空数组</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">EMPTY_ELEMENTDATA</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，真正的初始化发生在第一次添加元素的时候，这样的目的是为了节省内存。只有在第一次添加元素时，才会初始化为默认容量 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">10</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 的数组。</span></p><p id="ub932810e" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">扩容</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当你调用add()会进行元素个数和容量的判断，判断是否达到数组容量，如果是就会触发扩容，这里的扩容是一个懒触发的过程，只有在满了的那一刻才扩容，会触发grow()方法，把原数组的容量扩大到1.5倍，实际上是创建了一个新数组然后</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Arrays.copyOf()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">方法复制的。</span></p><p id="u1e6b97a7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">至于为什么是1.5倍，从源码上看是因为</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">oldCapacity + (oldCapacity &gt;&gt; 1);</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，&gt;&gt;右移一位就是除以2^1，从设计上讲，这是一个性能和空间的权衡折中方案，因为频繁的扩容会导致性能浪费，而扩太多就会导致空间浪费。并且1.5可以通过位运算减少浮点数或者运算时间和运算次数。</span></p><p id="ubaec7f2c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">但是删除元素不会自动缩容，逻辑大小会减少，但是底层容量仍然保留原扩容后的大小。这种设计的初衷是为了提高性能，减少频繁的内存复制操作，适用于大多数场景。然而，这也带来了内存浪费的问题。为了避免浪费，如果元素减少得较多，可以手动调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">trimToSize()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来缩容。</span></p><p id="u71e42fbc" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">复杂度</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：至于插入删除的复杂度，如果是头部和指定位置都是O(n)，如果是尾部插入，又分为需要扩容和不需要扩容的情况，如果需要扩容，那么会新建数组然后</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">copyOf()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，复杂度是O(n)，如果不需要扩容就是O(1)。 </span></p></details>
<details class="lake-collapse"><summary id="ub9c5f827"><span class="ne-text" style="color: rgb(51, 51, 51)">ArrayList </span><span class="ne-text">为什么线程不安全，怎么变成线程安全的</span></summary><p id="u4e55d408" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是基于 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">动态数组</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现的集合类，在设计上是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为单线程场景优化的</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，内部操作都没有做任何同步控制，因此在多线程环境下是不安全的。</span></p><p id="u14353ef4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">具体来说，它的线程不安全体现在以下几个方面：</span></p><ol class="ne-ol"><li id="u975be5e7" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">添加元素时可能发生数据覆盖或数组越界</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><span class="ne-text" style="color: rgb(51, 51, 51)">如果多个线程同时调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">add()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，而此时底层数组正好需要扩容，那么可能会多个线程同时进入扩容逻辑，导致扩容结果不一致、数据被覆盖，甚至抛出 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayIndexOutOfBoundsException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li><li id="u615d5a62" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">删除或修改元素时可能引发结构错乱</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><span class="ne-text" style="color: rgb(51, 51, 51)">多个线程同时调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">set()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，可能会导致元素错位或数据异常，破坏 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的内部结构。</span></li><li id="ue7760a6d" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">迭代过程中可能抛出 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentModificationException</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的迭代器是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">快速失败（fail-fast）机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，在遍历过程中如果有其他线程修改了集合结构，会抛出 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentModificationException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 异常。</span></li></ol><p id="u4ad87b62" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这些问题的根本原因在于：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的核心操作（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">add</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ensureCapacity</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">modCount</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 相关）</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">没有使用锁或其他并发控制机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，在多线程环境下会发生</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">竞态条件</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，最终导致不可预测的问题。</span></p><hr id="syIVf" class="ne-hr"><h3 id="f53db60d"><span class="ne-text" style="color: rgb(51, 51, 51)">把ArrayList变成线程安全</span></h3><p id="u809e0efa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">ArrayList不是线程安全的</span></p><p id="u1317d2b4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List</span></p><p id="u2c8ab4f7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现</span></p><p id="u04d21fa8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，使用Vector类代替ArrayList，Vector是线程安全的List实现</span></p></details>
<details class="lake-collapse"><summary id="u29070c6d"><span class="ne-text" style="color: rgb(51, 51, 51)">ArrayList 和数组的区别</span></summary><p id="u00e77bee" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">数组是 Java 最基本的数据结构，特点是长度固定、访问效率高。它适合用在对性能要求比较高、元素数量明确的场景，比如底层算法、缓存之类的。</span></p><p id="u67cf13e6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">ArrayList 是 Java 集合框架中的一个类，它的底层其实就是数组，但它在上层做了封装，支持动态扩容。还提供了很多方便的 API，比如 add、remove、contains 等。</span></p><p id="udca1ec5b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">数组可以存基本类型，比如 int[]，但是 ArrayList 只能存引用类型，这是因为泛型不支持基本类型，要通过自动装箱来处理。</span></p></details>
### <font style="color:rgb(51, 51, 51);">LinkedList</font>
<details class="lake-collapse"><summary id="u11d04d66"><span class="ne-text" style="color: rgb(51, 51, 51)">LinkedList 是什么</span></summary><p id="u9dab1064" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">是基于双向链表实现的（JDK1.6 之前为循环链表，JDK1.7 改为普通双向链表），底层是由多个节点（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Node</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）连接成的链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问。包括前后节点的引用和存储的元素。线程不安全。</span></p><p id="u41f33932" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">复杂度</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：元素的添加都是O(1)，删除头尾也都是O(1)，但是删除中间节点的时候需要定位到节点，所以是O(n)。</span></p><p id="u3084226f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">并且它实现了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Deque</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Queue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口，所以既能当列表用，也能当队列、双端队列、栈来用，功能还是很丰富的。</span></p></details>
<details class="lake-collapse"><summary id="u03ed3b8d"><span class="ne-text">1.6 循环链表---&gt;1.7 </span><span class="ne-text" style="color: rgb(51, 51, 51)">双向链表</span></summary><p id="ucf3aedc8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 JDK 1.6 之前，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的实现是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">循环链表</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。而从 JDK 1.7 开始，Java 的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 底层实现就不再使用循环链表，改用了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">普通的双向链表</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="uf26dc3f3" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">双向链表：</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</span></p><p id="ua9d10769" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">双向循环链表：</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</span></p><p id="uaae41675" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么这么改？</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">这个变化的主要原因是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">循环链表并不带来明显的性能优势</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，而反而可能带来一些复杂性和潜在的错误。例如，处理尾节点指向头节点的引用可能引发无限循环的问题，尤其是在垃圾回收时。改成普通双向链表后，结构更简单，代码也更加直观。</span></p></details>
<details class="lake-collapse"><summary id="u1e068875"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">LinkedList 和 ArrayList 有什么异同</span></strong></summary><p id="ub9798552" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">相同点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></p><ul class="ne-ul"><li id="ub6344149" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">都实现了 Java 的 List 接口：它们都支持相同的基本操作，例如添加元素、删除元素、查找元素、获取元素等</span></li><li id="u62ff55d0" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">都是有序的集合：都保证按顺序存储元素</span></li><li id="u217e461f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">都允许存储重复元素：可以有多个相同的元素，并且都允许存储 null 元素。</span></li><li id="u8dd740a8" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">都不线程安全</span></li></ul><p id="ue275c954" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不同点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></p><ul class="ne-ul"><li id="u3d719c58" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">底层数据结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：ArrayList的底层是动态数组，有扩容机制；LinkedList的底层是双向链表。</span></li><li id="u51738da5" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">操作复杂度</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：ArrayList的插入删除的复杂度，如果是头部和指定位置都是O(n)，如果是尾部插入，又分为需要扩容和不需要扩容的情况，如果需要扩容，那么会新建数组然后</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">copyOf()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，复杂度是O(n)，如果不需要扩容就是O(1)； LinkedList元素的添加都是O(1)，删除头尾也都是O(1)，但是删除中间节点的时候需要定位到节点，所以是O(n)。</span></li><li id="u36ac3567" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">快速随机访问</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不支持高效的随机元素访问，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">（实现了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">RandomAccess</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口） 支持。</span></li><li id="u14c372d3" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内存空间占用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</span></li><li id="u7b671345" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">应用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：ArrayList 适合查询多，修改少的场景；LinkedList 适合插入和删除操作多的场景。</span></li></ul></details>
### <font style="color:rgb(51, 51, 51);">CopyOnWriteArrayList</font>
<details class="lake-collapse"><summary id="u3efbbc60"><span class="ne-text" style="color: rgb(51, 51, 51)">CopyOnWriteArrayList 是什么？底层结构？实现原理？特性？应用场景？</span></summary><p id="uea23e842" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CopyOnWriteArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 并发包 (</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.util.concurrent</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">) 提供的线程安全 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现。它采用 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">&quot;写时复制&quot;</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 机制，适用于 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">读多写少</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 的高并发场景。</span></p><p id="u39956e7c" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">底层结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是内部维护了一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 数组（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Object[] array</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">），保证多线程可见性。</span></p><p id="uc4b85539" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">核心实现原理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是读写分离。所有读操作直接访问当前数组的快照，完全不需要加锁，因此读性能极高。而写操作会通过互斥锁ReentrantLock 加锁保护，在修改数据时先复制一份新的底层数组，在新数组上完成修改后，再原子性地替换旧数组。这种设计保证了读操作永远不会阻塞，也避免了读写冲突。</span></p><p id="uf2798636" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这种实现方式带来了几个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">关键特性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：首先，由于读操作不加锁且访问的是不可变数组快照，因此可以支持高并发的读取。其次，写操作虽然需要复制数组，但由于加锁保证了同一时刻只有一个写操作在进行，避免了数据竞争。最后，迭代器基于创建时的数组快照工作，不会反映后续修改，这种弱一致性特性避免了 ConcurrentModificationException。</span></p><p id="ucf7175c4" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">应用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CopyOnWriteArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 最适合监听器列表、配置信息等读多写少的场景。它的主要优势在于极高的读并发性能和无锁读取，但代价是写操作的成本较高，因为每次修改都需要复制整个数组。同时，由于迭代器的弱一致性，它不适合需要实时看到最新数据的场景。</span></p></details>
## <font style="color:rgb(51, 51, 51);">Map</font>
### <font style="color:rgb(51, 51, 51);">HashMap</font>
<details class="lake-collapse"><summary id="u30e417be"><span class="ne-text">底层结构？核心原理？put 和查找元素的流程？扩容过程？</span></summary><p id="ue5e94b8c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">HashMap的底层是数组+链表/红黑树，是非线程安全的，核心原理是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">通过 key 的 hash 值快速定位元素在数组中的位置</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，然后通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">equals()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 判断是否为同一个 key，实现快速查找和插入；</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">当put插入数据的时候</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，首先调用hashcode方法计算哈希值，然后hash方法又会对这个哈希值进行扰动处理（本质是添加高位信息的计算，降低低位重复的风险），目的是为了让哈希值更均匀，减少碰撞。然后会对数组长度取模得到数组下标，也就是桶的索引，如果这个位置是空的，就直接在这个位置放一个Node节点（键值对的封装对象），如果已经有数据了，说明发生了哈希冲突，这个时候会遍历桶的链表/红黑树，先用hash筛选可能的key，然后使用equals方法判断是不是同一个key，如果key已经存在，就更新value，反之，就添加这个节点，走链表（8之前头插，之后尾插，性能稍慢但是并发扩容不会造成</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">循环链表</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">）或红黑树的添加逻辑。如果某个桶的链表长度超过8并且总容量大于64，就会</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">转化成红黑树</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，效率是O（logn）；当</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">查找元素</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的时候，首先计算key的哈希值，再去桶遍历链表/红黑树，找hash值相等的节点，然后用equals判断是不是目标key，如果找到了就返回value；</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">扩容</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：HashMap的默认初始容量是16，负载因子是0.75，当元素数量超过16*0.75=12的时候，发生扩容，扩容会把原数组容量扩大为原来的2倍，然后把原来的元素再次hash放到新位置，这一步的开销较大，因为涉及所有元素的重新计算和移动。</span></p></details>
<details class="lake-collapse"><summary id="u0e1c10a4"><span class="ne-text"></span></summary><p id="uf5429882" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优先扩容而不是优先转化为红黑树</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，因为数组扩容能减少哈希冲突的概率，并且红黑树需要维持自平衡，维护成本较高，并且红黑树会增加复杂度（节点占用内存更大）。</span></p><hr id="re8DJ" class="ne-hr"><p id="u067a3cad" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">转化成红黑树为什么是8和64</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：因为泊松分布表明，链表长度到达8的情况非常非常少。设为8可以保证性能和空间的平衡。64也是实践验证的经验值，优先扩容而不是优先转化红黑树，当数组大小达到64的时候，冲突概率较高，转化成红黑树的性能优势就明显了。</span></p><hr id="fbcPm" class="ne-hr"><p id="u78e96002" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么扩容*2</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：目的是为了让hash计算更加高效；首先，HashMap的容量是2的幂，hash取模可以使用位运算代替，（n-1）&amp; hash；扩容后的再次hash更容易判断元素是否发生位置移动，重新hash后我们只需要看新增的哪一位是0还是1就能判断出来是否需要后移oldCapacity（是1就移）；</span></p><hr id="Aoh7t" class="ne-hr"><p id="u13dee093" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么负载因子是0.75？</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">默认负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。</span></p><hr id="y1zIP" class="ne-hr"><p id="u9ddf2839" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">死循环问题</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：JDK1.7 及之前版本的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</span></p><hr id="fXF10" class="ne-hr"><p id="u51d613cf" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么红黑树而不是平衡二叉树(AVL树)</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：平衡二叉树追求的是一种 ”完全平衡“ 状态，导致每次进行插入/删除节点的时候都需要左旋右旋来维持平衡；红黑树追求 ”弱平衡“，虽然牺牲了一些查找的效率，但是维护成本低。</span></p><hr id="NeuYJ" class="ne-hr"><p id="ue4121be4" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Key可以为null</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：null作为Key只能有一个，但是null作为value可以有多个。当key为空时，直接令 key的哈希值为0，不走key.hashCode()方法。</span></p></details>
<details class="lake-collapse"><summary id="uaba1b1c4"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">HashMap 线程安全吗？怎么变成线程安全的</span></strong></summary><p id="u05416488" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么HashMap线程不安全？</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">1.7之前头插法导致在多线程环境下扩容操作可能存在死循环问题；另外无论是7还是8都存在一个数据丢失的问题，实际上是数据覆盖，一种情况是线程1发现hash冲突并且equals满足，即将覆盖数据的时候，CPU执行权被线程2抢走，数据2覆盖了数据，等到线程1再次操作的时候就会把线程2的数据覆盖。还有一种情况是两个线程同时 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">put</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 操作导致 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">size</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的值不正确，进而导致数据覆盖的问题。</span></p><hr id="vbrFJ" class="ne-hr"><p id="u52b192e4" class="ne-p"><span class="ne-text">1， 早期使用 Hashtable，每个方法都加了 synchronized 关键字</span></p><p id="u4428ed64" class="ne-p"><span class="ne-text">2， 也可以</span><span class="ne-text" style="color: rgb(44, 62, 80)">通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(44, 62, 80); background-color: rgba(127, 127, 127, 0.12)">Collections.synchronizedMap</span></code><span class="ne-text" style="color: rgb(44, 62, 80)"> 方法返回一个线程安全的 Map，内部是通过 synchronized 对象锁来保证线程安全的，比在方法上直接加 synchronized 关键字更轻量级。</span></p><p id="ue5c85de4" class="ne-p"><span class="ne-text" style="color: rgb(44, 62, 80)">3，使用</span><span class="ne-text" style="color: rgb(51, 51, 51)">ConcurreHashMap</span></p></details>
### TreeMap
<details class="lake-collapse"><summary id="uf8e027cd"><strong><span class="ne-text">TreeMap </span></strong></summary><p id="u591c0f4a" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 中 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Map</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口的一个实现类，最大的特点就是它可以对键进行自动排序。这个排序要么是按照键的自然顺序，也就是键实现了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口，要么是通过我们在构造时传入的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparator</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 进行自定义排序。</span></p><p id="u9effe38f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它的底层是基于红黑树实现的，也就是一种自平衡的二叉搜索树，所以它在插入、删除、查找时都能保证 logN 的时间复杂度。相比于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来说，虽然性能略低一些，但它能保持顺序，这在需要范围查找、按序遍历时非常有用。</span></p><p id="u63724465" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">值得注意的是，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不允许键为 null，因为排序时会涉及键的比较，而 null 不能参与比较操作。值是可以为 null 的。</span></p><p id="u0cf18a58" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">另外，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不是线程安全的，在并发场景下我们需要自己加锁或者使用工具方法进行同步包装。</span></p><p id="ua68186a9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">总的来说，如果我们在业务中需要一个按照键排序的 Map，比如做排行榜、区间查找、时间线数据等，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是一个很合适的选择。</span></p></details>
<details class="lake-collapse"><summary id="uc155418d"><span class="ne-text" style="color: rgb(51, 51, 51)">TreeMap vs HashMap </span></summary><p id="u676d8997" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">排序方式</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是最显著的区别。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不保证任何顺序，它是无序的，元素的顺序是由哈希函数决定的。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是基于红黑树实现的，它会根据键的自然顺序（即 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）或者自定义的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparator</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对键进行排序。因此，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 保证键的顺序是有序的。</span></p><p id="u80479684" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第二，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">底层数据结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">不同。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 底层是基于哈希表实现的，键通过哈希值定位到桶（bucket）中，这使得它的查找、插入和删除操作平均时间复杂度是 O(1)，但是它的顺序是不可预测的。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 底层是基于红黑树的，操作时间复杂度是 O(log N)，但是它能够提供有序的键值对。</span></p><p id="u027f211c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程安全性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 都是非线程安全的。如果在多线程环境下需要使用线程安全的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Map</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，需要使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或者通过显式加锁来实现。</span></p><p id="u1c457df2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最后，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">性能上的差异</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。由于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 需要维护键的顺序，插入、删除、查找等操作的时间复杂度是 O(log N)，相较于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的 O(1) 要慢。如果不需要排序，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会更快</span></p></details>
### <font style="color:rgb(51, 51, 51);">ConcurreHashMap</font>
<details class="lake-collapse"><summary id="u5c81464d"><span class="ne-text" style="color: rgb(51, 51, 51)">ConcurreHashMap 是什么，以及1.8 前后的变化</span></summary><p id="u1e0499aa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">ConcurreHashMap是线程安全版的hashmap。</span></p><p id="u6f240a6b" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">1.8之前</span></strong></p><p id="ud9954f2b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 JDK1.7 及之前，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的线程安全是通过</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">分段锁（Segment Lock）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">实现的。它将整个哈希表分为若干个段（Segment），每个 Segment 其实是一个小的哈希表，同时每个 Segment 都维护一个独立的锁。</span></p><p id="u0cb6a6b7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当我们对 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 进行 put、get 或 remove 操作时，只会锁住对应的某个 Segment，而不是整个 map。这样多个线程只要访问的 Segment 不同，就可以并发执行操作，避免了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 那种全表锁带来的性能瓶颈。</span></p><p id="u14d54093" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Segment 的数量一般是 2 的幂次方，比如默认是 16 个，也就是说最多可以有 16 个线程并发写入而不阻塞，从而提升了并发性能。</span></p><p id="u6ef19a63" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">不过它的缺点也很明显：Segment 的数量是固定的，粒度不能再细，某个 Segment 上仍然可能成为热点，限制了更高的并发性。</span></p><p id="u911f3969" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。</span></p><p id="u23a1aca4" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">1.8之后</span></strong></p><p id="uebb1b2fa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">到了 JDK1.8，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的结构完全重写，不再使用 Segment，而是用</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">数组 + 链表 + 红黑树</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的结构，同时结合了 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">CAS（无锁操作）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">synchronized（细粒度同步）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="ube7ef515" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">插入数据时，先通过 CAS 操作尝试将节点插入到桶中，如果该位置是空的，直接写入，无需加锁；如果该位置已经有元素（比如链表或红黑树），才会用 synchronized 加锁，但只锁当前桶的头节点，锁的粒度更细。</span></p><p id="u248bd7d8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">扩容时，多个线程可以</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">协同迁移数据</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，称为协助扩容，避免了单线程扩容造成的阻塞。</span></p><p id="u7a1c2f21" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">get 操作是无锁的，通过 volatile 保证可见性，读取效率非常高。</span></p><p id="ub7b59270" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">相比 JDK1.7，1.8 的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 在并发性能、内存占用、锁竞争等方面都做了很大优化，彻底解决了分段锁机制下的扩展瓶颈。</span></p></details>
<details class="lake-collapse"><summary id="u567db51c"><span class="ne-text" style="color: rgb(51, 51, 51)">已经用了synchronized，为什么还要用CAS</span></summary><p id="u747f0261" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 之所以同时使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CAS</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，是为了在保证线程安全的同时最大程度提高并发性能，两者各有侧重，互相配合使用。</span></p><p id="u69467c3e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CAS</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">（Compare-And-Swap）是一种无锁原子操作，适用于一些简单、局部的并发修改场景，比如在插入元素之前先尝试占位节点（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">initTable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 初始化时就使用了 CAS）。它可以在不加锁的前提下完成并发修改，从而提高并发效率，减少上下文切换。</span></p><p id="u0493bd07" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">但 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CAS</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 也有局限，它只能保证单点原子性，不适用于需要多个步骤或者修改多个共享变量的复合操作。而对于某些复杂逻辑（如链表转红黑树、链表删除元素、扩容等），就必须使用传统的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来保证原子性和一致性。</span></p><p id="u541e4b01" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">所以：</span></p><ul class="ne-ul"><li id="ud609aa9e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">CAS 适用于轻量级、简单、可乐观执行的操作，优先使用，提高性能。</span></li><li id="u595f88c4" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 适用于需要完整互斥控制的复杂操作，确保线程安全。</span></li></ul><p id="u21320f11" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这种组合方式体现了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的设计思想：在保证线程安全的前提下，尽可能细化锁粒度、提升并发度和执行效率。</span></p></details>
<details class="lake-collapse"><summary id="uf2ee52c9"><span class="ne-text">value 和 key 允许为 null 吗</span></summary><p id="u38f037fd" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不允许为 null</span></strong></p><p id="u1fc825b8" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的 key 和 value 都能为 null，但 key 最多只能有一个为 null；而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 两者都不允许为 null，因为二义性，你没办法是不存在才返回null还是因为值本身就是null。多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</span></p><p id="ufabd8e6d" class="ne-p"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是否支持复合操作的原子性时</span></strong></p><p id="u584aa37d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第一，它本身只保证单个方法的线程安全，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">get</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">put</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 等，内部都有并发控制机制，比如 CAS 或 synchronized。但如果我组合多个方法，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">if (!map.containsKey(k)) map.put(k, v)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，这就不是原子的，中间可能被其他线程修改，导致逻辑错误。</span></p><p id="u72ae0f54" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第二，JDK 1.8 开始提供了一些专门应对复合操作的原子方法，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">putIfAbsent</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">compute</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">computeIfAbsent</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">computeIfPresent</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">merge</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，这些方法内部已经做了同步控制，可以安全地执行复合操作，所以我们要优先使用这些方法来避免并发问题。</span></p><p id="ud674f250" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三，如果遇到更加复杂的逻辑，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 没有提供直接支持的原子操作，那就需要 开发者自己加锁 来保证原子性，通常可以使用外部 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p></details>
### <font style="color:rgb(51, 51, 51);">ConcurrentSkipListMap</font>
<details class="lake-collapse"><summary id="u5f9fcc83"><span class="ne-text" style="color: rgb(51, 51, 51)">ConcurrentSkipListMap 是什么</span></summary><p id="ubef5d107" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentSkipListMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 并发包中提供的一种线程安全的、可排序的 Map 实现，底层基于跳表（Skip List）结构。它可以保证键值对按照 key 的自然顺序或自定义 Comparator 排序，并支持高并发读写操作。</span></p><p id="ubef27333" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">与 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 相比，它最大的特点是有序；与 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 相比，它则具备线程安全性，并发性能更好。内部是通过 CAS 和分段锁来实现并发控制的，支持无锁读、局部加锁写，整体性能优于传统的全锁方案。</span></p><p id="u46a305f9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">由于其有序性和线程安全特性，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentSkipListMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 特别适用于并发场景下需要排序功能的需求，比如实现排行榜、区间查找、按时间排序的数据存储等。</span></p></details>
### <font style="color:rgb(51, 51, 51);">Hashtable</font>
<details class="lake-collapse"><summary id="u3e896c79"><span class="ne-text" style="color: rgb(51, 51, 51)">Hashtable 是什么</span></summary><p id="u7308cb8c" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 中最早期提供的哈希表实现，已经过时，更推荐使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来替代它。</span></p><p id="u5142b57e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最大的特点是线程安全。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的所有方法几乎都通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现了同步控制，保证了多线程并发访问时的数据一致性。但也正因为如此，它的性能在高并发环境下会受到一定影响，因为每次访问都需要加锁，容易成为性能瓶颈。</span></p><p id="ue45fea54" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从底层结构上看，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和早期的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类似，都是基于数组加链表的结构实现的哈希表。通过键的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">hashCode()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法计算哈希值，再定位到数组的某个槽位，发生哈希冲突时通过拉链法解决。</span></p><p id="ud8d914ae" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">值得注意的是，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不允许键或值为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。这和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不同，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 允许一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 键和多个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 值。</span></p></details>
<details class="lake-collapse"><summary id="u649dba77"><span class="ne-text" style="color: rgb(51, 51, 51)">Hashtable 和 ConcurreHashMap 的区别</span></summary><p id="uaf579d04" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，在实现线程安全的方式上，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是通过对整个方法加上 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来实现同步的，也就是说每次读写操作都需要加锁，锁的粒度非常大，线程只能串行访问，性能比较低。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 则是通过分段锁或者更细粒度的同步机制来实现并发控制的。在 JDK1.7 中，它使用的是分段锁结构，把整个桶数组分成多个 Segment，每个 Segment 有自己的锁，可以支持更高并发；到了 JDK1.8，它优化为使用 CAS 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 结合的方式，锁粒度更小，性能进一步提升。</span></p><p id="ua0b10719" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 在多线程下容易成为性能瓶颈，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 在保证线程安全的同时兼顾了并发性能，是并发场景下更推荐的选择。</span></p><p id="u0f3c9c5c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">还有一点比较重要的是，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不允许键或值为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 也不允许。这个设计是为了避免在并发场景下使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 带来的歧义，比如不能判断是没有映射还是映射为 null。</span></p><p id="u70f2019a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从实际开发角度来说，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Hashtable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 已经属于过时的类，几乎不会在新项目中使用了；而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是目前在并发环境下使用最广泛的线程安全 Map 实现。</span></p></details>
## Set
### <font style="color:rgb(44, 62, 80);">HashSet</font>
<details class="lake-collapse"><summary id="ud42d1062"><span class="ne-text">是什么？实现原理？能不能是 null？</span></summary><p id="ucb69bb82" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">HashSet，LinedHashSet，TreeSet，都是Set接口的实现类，都能保证元素唯一，并且都不是线程安全的。</span></p><p id="ue4454dfe" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">HashSet是基于HasmMap的Key唯一的特性实现的，用来实现HashSet的HasmMap的value是一个固定常量，一般是PRESENT。</span></p><p id="ue41099d6" class="ne-p"><span class="ne-text">这个 </span><code class="ne-code"><span class="ne-text">PRESENT</span></code><span class="ne-text"> 是 </span><code class="ne-code"><span class="ne-text">HashSet</span></code><span class="ne-text"> 内部的一个 </span><code class="ne-code"><span class="ne-text">private static final Object</span></code><span class="ne-text">，只用来占位，没有实际意义。每当我们往 </span><code class="ne-code"><span class="ne-text">HashSet</span></code><span class="ne-text"> 添加一个元素，底层就是执行 </span><code class="ne-code"><span class="ne-text">map.put(element, PRESENT)</span></code><span class="ne-text">。</span></p><p id="ud6777fdf" class="ne-p"><strong><span class="ne-text">不能是Null</span></strong></p><p id="ufd52ad6e" class="ne-p"><span class="ne-text">如果用 </span><code class="ne-code"><span class="ne-text">null</span></code><span class="ne-text"> 作为 value，那在调用 </span><code class="ne-code"><span class="ne-text">map.get(key)</span></code><span class="ne-text"> 的时候，永远返回的是 </span><code class="ne-code"><span class="ne-text">null</span></code><span class="ne-text">，我们就无法区分到底这个 key 是真的存在，只是值是 null，还是这个 key 根本不存在。</span></p></details>
### <font style="color:rgb(51, 51, 51);">LinkedHashSet</font>
<details class="lake-collapse"><summary id="u8a7dd534"><span class="ne-text" style="color: rgb(51, 51, 51)">LinkedHashSet 是什么，实现？应用场景？</span></summary><p id="u8da1aa0e" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedHashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Set</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口的一个实现类，它继承自 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><ol class="ne-ol"><li id="u68284285" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">保持插入顺序</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedHashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 通过双向链表来维护元素的插入顺序，这意味着在遍历时，它会按照元素添加的顺序进行输出。与 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不同，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是无序的，无法保证元素的顺序。</span></li><li id="u838c3873" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">底层实现</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedHashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是基于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现的，每个元素作为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的 key，value 使用一个固定的对象（通常是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PRESENT</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）。同时，它通过双向链表来保持插入顺序。</span></li><li id="ueee9c6b2" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">性能</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u12c3de7e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 一样，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedHashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">add</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">contains</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 等操作的时间复杂度都是 O(1)。</span></li><li id="u9a8fe978" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">由于需要维护插入顺序，它相较于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会稍微多一些内存开销，因为它要额外存储双向链表的信息。</span></li></ul></ul><ol start="4" class="ne-ol"><li id="u3f1fbece" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">适用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedHashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 适用于那些需要保证元素顺序的场景，且不需要重复元素的集合。如果你需要元素的唯一性且保持插入顺序，就可以使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedHashSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li></ol></details>
### <font style="color:rgb(51, 51, 51);">TreeSet</font>
<details class="lake-collapse"><summary id="ud0653cb9"><span class="ne-text" style="color: rgb(51, 51, 51)">TreeSet是什么，实现？应用场景？</span></summary><p id="u54d93c53" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Set</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口的一个实现类，底层基于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现。</span></p><ol class="ne-ol"><li id="uce047c39" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">元素有序</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会根据元素的自然顺序（即元素实现了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口）或者自定义的排序规则（通过构造函数传入 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparator</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）对元素进行排序，遍历时是有序的。</span></li><li id="ucef6f833" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不允许重复元素</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和其他 Set 一样，不能存储重复元素。它是通过比较元素的大小来判断是否重复的，而不是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">equals()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，所以自定义比较器或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">compareTo</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的逻辑要和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">equals</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 保持一致，否则会出现逻辑冲突。</span></li><li id="u4d333075" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">底层实现</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 底层是基于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现的，具体是将元素作为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的 key，value 是一个固定的常量。它本质上是一个红黑树结构，因此所有操作的时间复杂度是 O(log N)。</span></li><li id="u083e2773" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不允许存储 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 元素</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><span class="ne-text" style="color: rgb(51, 51, 51)">因为比较时会抛出空指针异常，所以插入 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会直接抛出 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">NullPointerException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li><li id="u0c420cb4" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">适用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当我们需要一个自动排序且不重复的集合时，就可以使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TreeSet</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，比如处理排行榜、自动去重并排序的一些数据集合等。</span></li></ol></details>
## <font style="color:rgb(51, 51, 51);">Queue</font>
### <font style="color:rgb(51, 51, 51);">PriorityQueue</font>
<details class="lake-collapse"><summary id="ude92440d"><span class="ne-text" style="color: rgb(51, 51, 51)">PriorityQueue </span></summary><p id="u14325e22" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PriorityQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 提供的一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">基于优先级的队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">实现，它实现了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Queue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口，用来存储一组按照优先级自动排序的元素。</span></p><p id="u27c5b8e2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">和普通队列不同，普通队列是先进先出，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PriorityQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 中的元素并不是按照插入顺序来出队的，而是按照优先级</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">最小的元素优先出队</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也就是默认是一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">小顶堆结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="u93a72186" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它的底层是基于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">最小堆（binary heap）实现的数组结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，插入和删除操作的时间复杂度都是 O(logN)。元素入队后会自动按照优先级进行调整。</span></p><p id="u754f3104" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">默认情况下，队列中的元素必须实现 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口，使用元素的自然顺序进行排序；如果我们需要自定义排序方式，也可以在构造方法中传入一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparator</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，从而按照指定的优先级进行排序。</span></p><p id="ubbb1f8ea" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">值得注意的是，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PriorityQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 允许重复元素，但</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不允许插入 null</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，因为 null 会与内部比较操作冲突。此外，它</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不是线程安全的</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，在多线程环境下需要通过外部同步或使用并发版本的队列，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PriorityBlockingQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="ucaec35dc" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">典型应用场景包括：任务调度器、带权重的消息处理系统、Dijkstra 最短路径算法、Top-K 问题等。</span></p></details>
### <font style="color:rgb(51, 51, 51);">BlockingQueue</font>
<details class="lake-collapse"><summary id="u2b3c156c"><span class="ne-text" style="color: rgb(51, 51, 51)">BlockingQueue 是什么？特性？常用实现类？</span></summary><p id="u3e5a000f" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BlockingQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 中用于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程间通信</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">和</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">任务调度</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的一个接口，广泛用于生产者-消费者模型的实现。它的特点是：当队列为空时，消费者线程会被阻塞，直到有新元素加入；而当队列满时，生产者线程会被阻塞，直到队列有空间可以插入新元素。在实际应用中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BlockingQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 被广泛应用于多线程的任务调度、线程池的实现、生产者-消费者模型等场景。</span></p><p id="u8b9523ef" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BlockingQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 主要有两个特性：</span></p><ol class="ne-ol"><li id="u47b4053d" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">阻塞</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：如果队列为空，调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">take()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法的线程会被阻塞，直到队列中有元素可用。如果队列已满，调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">put()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法的线程会被阻塞，直到队列有空位。</span></li><li id="u04e98aa2" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程安全</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过内部的锁机制（如使用 ReentrantLock 或其他同步机制）来确保多个线程同时访问时，不会产生数据不一致的问题，保证在高并发情况下的正确性和一致性。</span></li></ol><p id="u34e77ac3" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BlockingQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口有几个常用实现类：</span></p><ul class="ne-ul"><li id="uf600c6db" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayBlockingQueue</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：基于数组实现的有界阻塞队列，队列的容量是固定的。</span></li><li id="uf479a1ee" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：基于链表实现的有界阻塞队列，可以设置最大容量，也可以不设置，默认是无界队列。</span></li><li id="u35878b4f" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PriorityBlockingQueue</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：基于优先级队列实现的阻塞队列，元素会按照优先级顺序排序。</span></li></ul></details>
<details class="lake-collapse"><summary id="u6346edaa"><span class="ne-text">ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue</span></summary><ul class="ne-ul"><li id="u4a3812ad" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayBlockingQueue</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：基于数组实现的有界阻塞队列，队列的容量是固定的。</span></li><li id="uc2a352b6" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：基于链表实现的有界阻塞队列，可以设置最大容量，也可以不设置，默认是无界队列。</span></li><li id="u6dbce95c" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PriorityBlockingQueue</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：基于优先级队列实现的阻塞队列，元素会按照优先级顺序排序。</span></li></ul></details>
<details class="lake-collapse"><summary id="u68d700dd"><span class="ne-text">ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别</span></summary><p id="u578ef74e" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">ArrayBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 都是常用的阻塞队列，具备线程安全和阻塞特性，但它们在底层结构、容量控制和性能表现上有明显区别。</span></p><p id="u6f5e672f" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">首先，底层实现不同。</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">ArrayBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 是基于数组实现的，内部使用一个固定长度的数组作为存储结构，因此它的容量必须在创建时指定，无法动态扩容。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 是基于链表实现的，每个元素是一个独立的节点，通过链表串联起来，它支持有界和无界两种模式。如果构造时没有指定容量，默认容量是 Integer.MAX_VALUE，相当于一个理论上的无界队列。</span></p><p id="u96e556de" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">其次，在性能和资源使用上也有区别。由于数组是连续内存，</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">ArrayBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 的内存利用更紧凑，内存开销相对较小，适合对内存敏感的场景。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 每个元素都需要额外的节点对象，内存开销相对更大，但在高并发场景下，它的插入和移除操作更加平稳，适合大规模数据流动。</span></p><p id="u0a74e8d1" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">此外，</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 的 put 和 take 操作内部使用的是两把锁（分别用于读和写），而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">ArrayBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 只使用一把锁来控制整个队列，因此在某些高并发情况下，</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 的吞吐量可能会更好一些。</span></p><p id="u88902628" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">应用场景上，如果我清楚队列的容量范围，比如用于线程池中的任务提交队列，我更倾向于使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">ArrayBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)">，因为它更简单、内存开销更小。但如果任务量无法预估，或者系统允许更大的弹性空间，那么 </span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">LinkedBlockingQueue</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 会更适合一些。</span></p></details>
### <font style="color:rgb(51, 51, 51);">ConcurrentLinkedQueue</font>
<details class="lake-collapse"><summary id="u82bf4f09"><span class="ne-text" style="color: rgb(51, 51, 51)">ConcurrentLinkedQueue 是什么？底层实现？使用场景？</span></summary><p id="u4e57d306" class="ne-p"><strong><span class="ne-text" style="color: rgb(0, 0, 0)">线程安全的、无界的、非阻塞的先进先出（FIFO）队列</span></strong><span class="ne-text" style="color: rgb(0, 0, 0)">。</span></p><p id="u1c038386" class="ne-p"><span class="ne-text">Java 提供的线程安全的 </span><code class="ne-code"><span class="ne-text">Queue</span></code><span class="ne-text"> 可以分为阻塞队列(BlockingQueue)和非阻塞队列(ConcurrentLinkedQueue)，阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</span></p><p id="ue270febd" class="ne-p"><span class="ne-text">内部是一个单向链表，</span><span class="ne-text" style="color: rgb(60, 60, 67)">使用 CAS 非阻塞算法来实现线程安全。</span></p><p id="u8d252f55" class="ne-p"><span class="ne-text">使用场景：线程池 </span><code class="ne-code"><span class="ne-text">ThreadPoolExecutor</span></code><span class="ne-text">的任务队列、高性能消息传递、无阻塞任务处理。</span></p></details>
### <font style="color:rgb(51, 51, 51);">Deque</font>
<details class="lake-collapse"><summary id="ub683dc20"><span class="ne-text" style="color: rgb(51, 51, 51)">Queue 和 Deque 的区别</span></summary><p id="u93d8ff07" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Queue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">单端队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，遵循的是典型的“先进先出”（FIFO）原则。我们通常使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">offer()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 添加元素，用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">poll()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 移除元素，从队首出，从队尾入。常见的实现类有 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">PriorityQueue</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，像任务调度、消息队列等场景都是使用 Queue。</span></p><p id="u0b9e979a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Deque</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是“双端队列”，全称是 Double Ended Queue，它既可以从队头添加或移除元素，也可以从队尾进行相同的操作。也就是说，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Deque</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 同时支持 FIFO 和 LIFO（后进先出），因此它</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">既可以当队列用，也可以当栈用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。常用方法比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">addFirst()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">addLast()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">removeFirst()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">removeLast()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，而实现类像 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayDeque</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 都支持 Deque 接口。</span></p><p id="u8e4d5ced" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">所以总结来说，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Queue 只能一端进、一端出，Deque 两端都能进出，更灵活</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，适合处理双向数据结构或实现栈这种结构。</span></p></details>
<details class="lake-collapse"><summary id="u0ecff232"><span class="ne-text">ArrayDeque 和 LinkedList 的区别</span></summary><p id="u540bd150" class="ne-p"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayDeque</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是基于动态数组实现的</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，它内部用一个循环数组来存储元素。因为是数组结构，它在两端插入和删除元素时效率很高，几乎都是 O(1) 时间，并且由于没有指针开销，它的内存利用率也更好。</span></p><p id="u464bc601" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">相比之下，</span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是基于双向链表实现的</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，每个节点都有前后指针。它的优势是插入和删除不会涉及数组扩容或元素移动，也支持插入 null 元素，但缺点是内存开销更大，随机访问效率低，性能波动也可能更明显。</span></p><p id="ud692f717" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">此外，</span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayDeque</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 不允许插入 null 元素</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是允许的；另外在栈结构（比如替代 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Stack</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类）或队列结构中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayDeque</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 通常比 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LinkedList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 表现更优，也更推荐使用。</span></p></details>
<details class="lake-collapse"><summary id="ud2d44c03"><span class="ne-text">ArrayDeque 和 ArrayList 的区别</span></summary><p id="uff0bd4ab" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，</span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现了 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，主要用于按顺序存储元素，强调的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">随机访问和按索引管理数据</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。它的底层是一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线性动态数组</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，支持快速的索引访问，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">get(index)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">set(index)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的时间复杂度是 O(1)。但是如果在中间插入或删除元素，就会涉及到大量元素的移动，性能相对较差。</span></p><p id="u2951b7e7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而 </span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayDeque</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现了 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Deque</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也就是双端队列，它的重点是支持从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">队头和队尾进行高效的插入和删除操作</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。它底层虽然也是数组，但用的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">循环数组结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。当数组尾部空间不足时，它会自动绕回到数组头部去使用未占用的位置，这种</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">环形结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">可以避免频繁的数据移动，使得两端操作的性能非常稳定，都是 O(1) 的时间复杂度。</span></p><p id="u7eb24076" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">还有一些细节上的差异，比如：</span></p><ul class="ne-ul"><li id="u1deae671" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 允许插入 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 元素，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayDeque</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 明确禁止 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，因为它用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 表示队列为空，这样更容易区分是否出队成功。</span></li><li id="u5b9c99bf" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">在扩容机制上，两者都支持动态扩容，但 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是线性扩容（一般是原来容量的 1.5 倍），</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayDeque</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的容量总是 2 的幂次方，这有助于在循环数组中通过位运算快速定位元素位置。</span></li></ul></details>
## 其他
<details class="lake-collapse"><summary id="u4b99e738"><span class="ne-text" style="color: rgb(51, 51, 51)">Fail-fast 和 Fail-safe</span></summary><p id="uc5507156" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Fail-fast 是一种设计策略，它会在集合被修改的情况下</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">立即抛出异常</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。通常，当你在迭代集合时，如果集合被修改了，迭代器就会抛出 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentModificationException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 异常。</span></p><p id="ufc2ff5a8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Fail-safe 是另一种设计策略，它允许在遍历集合的同时</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">修改集合的结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，并且不会抛出异常。即使在迭代过程中发生修改，迭代器也能继续正常工作。</span></p><p id="ud8c37564" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">fail-fast</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 更侧重于提前发现错误，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">fail-safe</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 更侧重于保证并发环境下的安全操作。</span></p><p id="u75216b10" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的迭代器就是 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">fail-fast</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 类型的。</span></p><p id="u7d2c55cd" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CopyOnWriteArrayList</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ConcurrentHashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，它们采用了 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">fail-safe</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 策略</span></p></details>






