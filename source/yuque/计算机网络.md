- [x] **网络模型**
- [x] **应用层-网络协议**
- [x] HTTP
- [x] HTTPS
- [x] DNS
- [x] <font style="color:rgb(51, 51, 51);">WebSocket</font>
- [x] RPC
- [x] **传输层-网络协议**
- [x] TCP
- [x] UDP
- [x] **网络层-网络协议**
- [x] IP
- [x] **网络接口层-网络协议**
- [x] ARP
- [x] **网络攻击**
- [ ] **其他**

## 网络模型
> <font style="color:rgb(119, 119, 119);">OSI 是理论上的网络通信模型，TCP/IP 是实际应用层面上的网络通信模型</font>
>

### `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">OSI</font>`<font style="color:rgb(51, 51, 51);">模型</font>
OSI七层模型是理论上的网络分层模型，把通信过程分为七层，<font style="color:rgb(51, 51, 51);">主要用于教学和标准化</font>

1. **<font style="color:rgb(51, 51, 51);">应用层</font>**<font style="color:rgb(51, 51, 51);">：为用户提供网络服务，如HTTP、DNS、文件传输（FTP）等。</font>
2. **<font style="color:rgb(51, 51, 51);">表示层</font>**<font style="color:rgb(51, 51, 51);">：负责数据的格式化、加密和解密</font>
3. **<font style="color:rgb(51, 51, 51);">会话层</font>**<font style="color:rgb(51, 51, 51);">：管理设备之间的会话，负责会话的建立、维护和终止（如RPC）。</font>
4. **<font style="color:rgb(51, 51, 51);">传输层</font>**<font style="color:rgb(51, 51, 51);">：提供端到端的数据传输（如TCP、UDP协议）。</font>
5. **<font style="color:rgb(51, 51, 51);">网络层</font>**<font style="color:rgb(51, 51, 51);">：路由和寻址（如IP协议）。</font>
6. **<font style="color:rgb(51, 51, 51);">数据链路层</font>**<font style="color:rgb(51, 51, 51);">：保证数据在物理层上可靠地传输，错误检测与纠正（如以太网、MAC地址）。</font>
7. **<font style="color:rgb(51, 51, 51);">物理层</font>**<font style="color:rgb(51, 51, 51);">：数据的实际物理传输，比如电缆、光纤等。</font>

### `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">TCP/IP</font>`<font style="color:rgb(51, 51, 51);">四层模型</font>
<font style="color:rgb(51, 51, 51);">是广泛应用的网络模型，是互联网的基础</font>

1. **<font style="color:rgb(51, 51, 51);">应用层</font>**<font style="color:rgb(51, 51, 51);">：专注于提供应用功能，如HTTP、FTP、Telnet、DNS、SMTP 		-应用数据</font>
2. **<font style="color:rgb(51, 51, 51);">传输层</font>**<font style="color:rgb(51, 51, 51);">：为应用层提供网络支持，包括TCP和UDP 		-TCP/UDP头+应用数据</font>
3. **<font style="color:rgb(51, 51, 51);">网络层</font>**<font style="color:rgb(51, 51, 51);">：负责实际的传输功能，最常用的是IP协议		 -IP头+TCP/UDP头+应用数据</font>
4. **<font style="color:rgb(51, 51, 51);">网络接口层</font>**<font style="color:rgb(51, 51, 51);">：负责在</font>物理网络上<font style="color:rgb(51, 51, 51);">发送原始数据包 		-帧头+IP头+TCP/UDP头+应用数据+帧尾</font>
+ <font style="color:rgb(51, 51, 51);">分别对应OSI的1-3，4，5，6-7层</font>
+ 网络接口层的传输单位是帧，网络层 (IP等)的传输单位是包/数据报，传输层 (TCP等)的传输单位是段，应用层 (HTTP等)的传输单位是消息或报文。

<details class="lake-collapse"><summary id="u6cb35f3d"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为什么要分层</span></strong></summary><p id="u5e69d70a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">通过分层标准化交互的过程。</span></p><p id="u2fde0539" class="ne-p"><span class="ne-text" style="font-size: 16px">具体讲，分层一方面使各层相互独立，不需要考虑其他层的实现，只需要调用下层功能；另一方面提高了灵活性和可替换性，类似高内聚、低耦合的原则；并且使得复杂的计算机网络系统变得易于设计，实现和标准化。</span></p></details>
## 应用层-网络协议
### <font style="color:rgb(51, 51, 51);">HTTP</font>
HTTP，即超文本传输协议。

> 超文本：文字、图片、视频等的混合体，有超链接功能，最常见的：HTML
>

用于Web浏览器和服务器之间传输的协议。定义了浏览器如何请求网页，以及服务器如何响应这些请求。

默认端口：80

<details class="lake-collapse"><summary id="u3deb8d67"><strong><span class="ne-text">状态码</span></strong><span class="ne-text">---</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于描述请求的结果</span></summary><p id="u05d9ce7a" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1xx表示正在处理</span></strong></p><p id="u36ddfefa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">基本上没见过，100 Continue客户端应该继续发送请求</span></p><p id="u68c9eb75" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">102 Processing正在处理，</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">用于长时间操作</span></p><p id="u05c3145f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2xx表示正常处理完毕</span></strong></p><p id="u174527f3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">200 OK表示请求成功</span></p><p id="ud4da34a6" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">201 Created</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px"> 资源创建成功，如 POST 请求后返回新资源的 URL</span></p><p id="u75828305" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">204 No Content表示成功但是没有body数据</span></p><p id="ue264ea14" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">206 Partial Content表示资源只是一部分</span></p><p id="u4405bcba" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">3xx表示需要附加操作</span></strong></p><p id="u5c405b5b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">301Moved Permanently表示永久重定向，资源不存在了，需改用新的 URL</span></p><p id="u62efb4eb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">302 Found表示临时重定向，请求资源还在但是暂时需要另一个URL访问</span></p><p id="u22738dfb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">304 Not Modified 表示资源未修改，</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">仅用于缓存控制（客户端可复用本地缓存）</span></p><p id="u366f855f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">4xx表示服务器无法处理请求</span></strong></p><p id="uc36977ad" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">400 Bad Request </span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">客户端请求错误，如参数格式错误</span><span class="ne-text" style="font-size: 16px"> </span></p><p id="u01da6c77" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">401Unauthorized 未授权（未认证），用户未提供有效身份凭证（如未登录）</span></p><p id="u348706c7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">403 Forbidden 表示服务器拒绝执行，如权限不足、IP地址被封禁或网站配置错误</span></p><p id="u7c669d05" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">404 Not Found表示请求的资源不存在</span></p><p id="u1281f000" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">5xx表示服务器处理请求出错</span></strong></p><p id="u62ae5b09" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">500 Internal Server Error表示服务器内部错误</span></p><p id="u9c1ab064" class="ne-p"><span class="ne-text" style="font-size: 16px">501 </span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">Not Implemented</span><span class="ne-text" style="font-size: 16px"> 表示服务器不支持请求方法</span></p><p id="ud6d4fd56" class="ne-p"><span class="ne-text" style="font-size: 16px">502 Bad Gateway 网关服务器无法从上游服务器获得有效的响应，如上游服务器未启动、崩溃或超时</span></p><p id="u9d2a8c68" class="ne-p"><span class="ne-text" style="font-size: 16px">504 Gateway Time-out 表示网关服务器等待上游服务器响应超时，如上游服务器处理时间过长或网络延迟</span></p></details>
<details class="lake-collapse"><summary id="u22ffcc06"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">请求类型</span></strong></summary><p id="ufb8dbe56" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">GET：用于请求获取指定资源，通常用于获取数据。</span></p><p id="u8be94280" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</span></p><p id="uae7abbf5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。</span></p><p id="u129b8728" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">DELETE：用于请求服务器删除指定资源。</span></p><p id="uc8199233" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</span></p></details>
<details class="lake-collapse"><summary id="u651b9288"><span class="ne-text" style="font-size: 16px">GET 和 POST 有什么区别</span></summary><ol class="ne-ol"><li id="uff4fb0f1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">GET是从服务器获取指定的资源，请求的参数位置一般写在URL中，参数只允许ASCII，并且浏览器(不是HTTP)对URL长度有限制。GET是安全且幂等的，是“只读”操作，可被浏览器缓存。</span></li><li id="uc11aa29e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">POST是根据请求符合(报文body)对指定数据的资源做出处理，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。POST是不安全不幂等的，是“新增/提交数据”操作，会修改服务器资源，浏览器一般不会缓存POST请求。</span></li></ol><p id="u1c9b312b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">注：理论上，任何请求都可以带 body 的，只是规范上GET不带body；并且URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</span></p></details>
<details class="lake-collapse"><summary id="u5197f0f5"><strong><span class="ne-text" style="font-size: 16px">请求报文 / 响应报文</span></strong></summary><p id="u0517f072" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求报文</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：</span></p><p id="ue2a1f426" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。</span></p><p id="uc04a938a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。</span></p><p id="u2d4aed9d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">空行：请求头部和请求体之间用空行分隔。</span></p><p id="ub18dfd04" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。</span></p><p id="ue08eade7" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">响应报文</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：</span></p><p id="u93cfb4eb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">状态行：包含HTTP协议版本、状态码和状态信息。</span></p><p id="u2468d6c7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。</span></p><p id="u9e9ed68a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">空行：响应头部和响应体之间用空行分隔。</span></p><p id="u0d83804a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容。</span></p></details>
<details class="lake-collapse"><summary id="u78017288"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">HTTP常见字段</span></strong></summary><p id="u64e4ef9d" class="ne-p"><span class="ne-text">HTTP字段（HTTP field）是出现在HTTP请求或响应头部的一组键: 值结构，用于携带额外的指令或说明，帮助服务器和客户端正确处理HTTP消息。</span></p><ul class="ne-ul"><li id="uc79425c5" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HOST：可以将请求发往「同一台」服务器上的不同网站</span></li><li id="ud7499345" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Content-Length：表明本次回应的数据长度</span></li><li id="uba6c2e44" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Connection：最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用</span></li><li id="u27918e96" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Content-Type：用于服务器回应时，告诉客户端，本次数据是什么格式</span></li><li id="u2d6c8e85" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Content-Encoding：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</span></li></ul></details>
<details class="lake-collapse"><summary id="u2cf66d7e"><strong><span class="ne-text" style="font-size: 16px">HTTP版本</span></strong></summary><ol class="ne-ol"><li id="u94245ca3" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/0.9：</span></strong><span class="ne-text" style="font-size: 16px">只有 GET 方法，无头部，响应仅为 HTML。</span></li><li id="u9cd08d33" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/1.0：</span></strong><span class="ne-text" style="font-size: 16px">引入</span><strong><span class="ne-text" style="font-size: 16px">头部</span></strong><span class="ne-text" style="font-size: 16px">（Header）、状态码、多种请求方法（POST/HEAD），支持非 HTML 内容。</span></li><li id="ue3347fca" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/1.1：持久连接</span></strong><span class="ne-text" style="font-size: 16px">（默认保持连接复用）、管道化、缓存控制（如 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">Cache-Control</span></code><span class="ne-text" style="font-size: 16px">）、 Host 头（支持虚拟主机）。</span></li><li id="u1cb42dea" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/2：多路复用</span></strong><span class="ne-text" style="font-size: 16px">（一个连接并行传输多个请求）、头部压缩、服务器推送。</span></li><li id="uae0a5753" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/3：</span></strong><span class="ne-text" style="font-size: 16px">基于 </span><strong><span class="ne-text" style="font-size: 16px">QUIC 协议</span></strong><span class="ne-text" style="font-size: 16px">（UDP），减少连接建立延迟，解决队头阻塞问题。</span></li></ol></details>
<details class="lake-collapse"><summary id="uee2778d2"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/1.0</span></summary><ol class="ne-ol"><li id="ua99b9873" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">响应状态码：有16 种状态码。</span></li><li id="u8abb9361" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">缓存机制：服务器在返回响应时，告诉客户端这个资源的“过期时间”或“最后修改时间”，客户端在下次需要这个资源时，可以据此判断是直接使用本地副本，还是需要向服务器重新请求。存在的问题：依赖绝对时间，控制手段单一，不可靠不灵活。</span></li><li id="u0bb48044" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">连接方式：默认短连接， 每次请求都会重新建立并关闭一次 TCP 连接，频繁的三次握手与四次挥手造成明显的带宽和性能浪费。</span></li></ol></details>
<details class="lake-collapse"><summary id="ua1f61836"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/1.1</span></summary><ol class="ne-ol"><li id="u9cee579c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">响应状态码：新增大量的状态码，如206等。</span></li><li id="uc724cda6" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">缓存机制：引入了Cache-Control头部和ETag机制，  提供了丰富的缓存指令，支持更精确控制，使用内容哈希标识资源版本而不是时间，缓存校验更加精准高效。</span></li><li id="uf35f6ebe" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">连接方式：默认长连接，</span><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px"> 通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">Connection: keep-alive</span></code><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px"> 保持 TCP 连接在多个请求间复用，显著减少连接开销，提高传输效率。  </span></li><li id="u1834bdd9" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">新增并强制使用Host头部：1.0中服务器无法区分同一 IP 下的多个网站，强制Host头的引入实现了虚拟主机支持，使一台服务器能同时服务多个域名  </span></li><li id="uf5d70e2d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">范围请求机制： 允许客户端只获取资源的部分字节（或多段），支持断点续传与按需加载。通过Range等头部配合多种状态码协调实现</span></li></ol><hr id="vzZ7u" class="ne-hr"><ol class="ne-ol"><li id="u11887a1f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">连接方式：串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接的限制</span></li><li id="u4111f81d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">传输格式：文本格式的报文</span></li><li id="uebd3418b" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">队头阻塞：请求-响应串行模型， 同一连接中一个慢请求阻塞后续  </span></li><li id="u3bd1b3bb" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">头部压缩：支持Body压缩，不支持Header压缩， 头部大量重复  </span></li></ol></details>
<details class="lake-collapse"><summary id="u5701ee68"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/2</span></summary><ol class="ne-ol"><li id="u0a5dbe10" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">连接方式：多路复用，在同一连接上可以同时传输多个请求和响应，互不干扰</span></li><li id="u90bc033f" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">传输格式：二进制分帧，更高效、更易解析  </span></li><li id="ua7f99edb" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">队头阻塞：多路复用技术允许多个请求和响应在单个 TCP 连接上并行交错传输，解决了 HTTP/1.1 应用层的队头阻塞问题，但 HTTP/2 依然受到 TCP 层队头阻塞 的影响。</span></li><li id="ub5a38e94" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">头部压缩： 使用 HPACK 压缩头部，大幅减少冗余  </span></li><li id="u6f984c0c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">服务器推送：可以在客户端请求一个资源时，将其他相关资源一并推送，减少客户端的请求次数和延迟</span></li><li id="u12393550" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">安全性：实际使用中，HTTP/2 实际等同于 HTTPS，总是基于TLS加密</span></li></ol><hr id="RCHF5" class="ne-hr"><ol class="ne-ol"><li id="ua00436de" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">传输协议：基于TCP协议</span></li><li id="uc43f8c22" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">握手性能：TCP三次握手+TLS握手，至少2RTT</span></li><li id="u206363f0" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">队头阻塞：存在传输层堵头阻塞</span></li><li id="u328dce7b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">加密机制： TLS 与传输分层独立，不加密TCP头部等信息</span></li><li id="ubd70d965" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">丢包处理：依赖于TCP的全局重传，容易阻塞</span></li></ol></details>
<details class="lake-collapse"><summary id="u86a44a6c"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/3</span></summary><ol class="ne-ol"><li id="u1425c23f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">传输协议：使用QUIC协议，在UDP基础上实现了可靠传输、多路复用、加密和连接迁移</span></li><li id="u9ef5449b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">握手性能：首次连接1次RTT，复用则0次</span></li><li id="u958bdf2a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">队头阻塞：完全消除队头阻塞</span></li><li id="ud0339293" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">加密机制：TLS内嵌于QUIC，对整个数据包加密，更加安全</span></li><li id="uc2b92747" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">丢包处理：QUIC 局部重传，仅影响丢失的数据流  </span></li><li id="ub0f219d0" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">连接迁移：QUIC使用64位标识连接，网络环境改变也能保持连接</span></li></ol></details>
<details class="lake-collapse"><summary id="uc6d000ce"><strong><span class="ne-text"> URI 和 URL 的区别是什么</span></strong></summary><p id="u07739e64" class="ne-p"><span class="ne-text">URL是URI的一种</span></p><p id="u1e0b0f59" class="ne-p"><span class="ne-text">URI是统一资源标识符，</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">唯一标识一个资源</span></p><p id="u1b7f1cd8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">URL是统一资源定位符，指出资源访问位置和方式</span></p><hr id="koQ72" class="ne-hr"><p id="uce3385b2" class="ne-p"><span class="ne-text">URL组成：协议://主机:端口/路径?查询参数#片段标识</span></p></details>
<details class="lake-collapse"><summary id="ubcff9f6e"><span class="ne-text"> </span><strong><span class="ne-text" style="font-size: 16px">HTTP 是不保存状态的协议, 如何保存用户状态?  </span></strong></summary><p id="u093709cd" class="ne-p"><span class="ne-text" style="font-size: 16px">HTTP是无状态协议，每次请求都是独立的，必须依靠额外机制显式传递状态信息</span></p><ol class="ne-ol"><li id="u02d610a4" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Cookie，最基础的状态存储机制， 由服务器通过响应头 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">Set-Cookie</span></code><span class="ne-text" style="font-size: 16px"> 发送给客户端，浏览器自动在后续请求中携带  </span></li><li id="uaef0d597" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Session，基于Cookie的服务器状态保存方案， 服务器在内存/数据库中保存用户状态，客户端仅保存一个 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">SessionID</span></code><span class="ne-text" style="font-size: 16px">（通常放在 Cookie 中），用来关联状态</span></li><li id="u4dd0b1ad" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Token/JWT：无状态认证方案，适合分布式系统， 服务器签发加密 Token（如 JWT），客户端每次请求携带（通常放在 Header 的 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">Authorization</span></code><span class="ne-text" style="font-size: 16px"> 中），服务器验证后识别用户</span></li></ol></details>
<details class="lake-collapse"><summary id="ueb027d4c"><strong><span class="ne-text" style="font-size: 16px">缓存技术</span></strong></summary><p id="ud0af145b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器/中间服务器在本地保存资源副本，减少重复请求、提示加载速度、节省宽带</span></p><p id="u599ad48c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">有两种实现方式：强制缓存和协商缓存</span></p><ol class="ne-ol"><li id="ud77c25ba" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">强制缓存即HTTP/1.0的Expires绝对过期时间判断和HTTP/1.1的Cache-Control 相对过期时间和策略判断</span></li><li id="uc525c169" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">协商缓存即HTTP/1.0的 通过资源修改时间判断是否更新  和HTTP/1.1的 内容哈希标识判断是否更新  </span></li></ol><p id="u572e01cd" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">协商缓存是强制缓存的“备胎”，只有强制缓存失效时才会触发协商缓存流程。</span></p></details>
### <font style="color:rgb(51, 51, 51);">HTTPS</font>
HTTPS，即超文本传输安全协议。 是在 HTTP 协议基础上<font style="color:rgb(51, 51, 51);">通过SSL/TLS协议加密，加密层在HTTP和TCP之间。</font>

默认端口：443

<details class="lake-collapse"><summary id="u3b626525"><strong><span class="ne-text" style="font-size: 16px">HTTPS如何解决了HTTP的安全问题</span></strong></summary><p id="u3c05579c" class="ne-p"><span class="ne-text" style="font-size: 16px">首先明白HTTP的安全问题：</span></p><ol class="ne-ol"><li id="ufc4c9ef6" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">明文存储，存在窃听风险</span></li><li id="ub1bb5559" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">可以截获数据包并修改内容，存在篡改风险</span></li><li id="u1de6fd0f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">无法确认与你通信的服务器的身份，存在冒充风险</span></li></ol><p id="ue969c056" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">对应的，HTTPS：</span></p><ol class="ne-ol"><li id="ue6d76fd1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">混合加密，即对称加密和非对称加密，握手阶段通过</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">非对称加密交换会话密钥，通信过程全部使用对称加密加密明文数据</span></li><li id="u74746ed7" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">HMAC，是摘要算法的变种，</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">摘要算法即哈希函数</span><span class="ne-text" style="font-size: 16px">，直接发送“数据摘要+数据”可能二者都被伪造，所以HMAC发送的摘桃来源于数据和对称密钥。</span></li><li id="u49597818" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">数字证书的数字签名，通过校验收到的服务器公钥是否具有权威机构CA的证明来判断是不是伪造的</span></li></ol></details>
<details class="lake-collapse"><summary id="u8d9e0c34"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">SSL/TLS 协议</span></strong></summary><p id="u1335395a" class="ne-p"><span class="ne-text" style="font-size: 16px">TLS 是 SSL 的升级版，同一个东西的不同版本，只是SSL叫习惯了所以保留了</span></p></details>
<details class="lake-collapse"><summary id="ufeaba4ed"><span class="ne-text">握手过程</span></summary><ol class="ne-ol"><li id="u0b8ef44d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">ClientHello：客户端向服务器发起ClientHello加密通信请求，发送了客户端支持的TLS协议版本 + 客户端生产的随机数(用来生成对话密钥) + 支持的密码套件系列(加密算法)</span></li><li id="ud9ae9158" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">SeverHello：服务器做出响应，发送 确认TLS协议版本(不支持该版本就关闭加密通信) + 服务器生产的随机数(用来生成对话密钥) + 确认密码套件系列 + 服务器的数字证书</span></li><li id="u088c1f41" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">客户端回应：客户端收到回应后，先通过浏览器/操作系统的CA公钥确认数字证书真实性，随后从数字证书取出服务器公钥，生成一个随机数(pre-master  Secret )用服务器公钥加密后发送给服务器。然后客户端使用三个随机数用协商的加密算法各自生成本次通信的会话密钥，客户端发送 加密的 Finished 消息校验握手完整性  </span></li><li id="u9131ead4" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">服务端计算会话密钥，发送 加密 Finished 消息  </span></li></ol><hr id="Zv5co" class="ne-hr"><p id="uacbcc1ce" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">至此握手阶段结束，进入加密通信，完全使用HTTP协议，只不过使用会话密钥加密内容(对称加密+HMAC)。</span></p></details>
<details class="lake-collapse"><summary id="udcf92195"><span class="ne-text" style="font-size: 16px">握手为什么要使用随机数，以及为什么要三个随机数</span></summary><p id="uc10b2de5" class="ne-p"><span class="ne-text" style="font-size: 16px">使用随机数：</span></p><ol class="ne-ol"><li id="u411e9166" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">保证会话密钥唯一性，防止攻击人重放攻击或根据重复密钥推测通信内容</span></li><li id="uebbe11e2" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">增加密钥熵，提高不可预测性，保障安全</span></li></ol><p id="u3f4c202d" class="ne-p"><span class="ne-text" style="font-size: 16px">为什么要三个，只要第三个不行吗</span></p><ol class="ne-ol"><li id="u82bdf69b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">随机性更强，并且保证向前保密</span></li><li id="u76a141a5" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">让密钥生成过程和算法协商过程解耦，更加灵活</span></li></ol></details>
<details class="lake-collapse"><summary id="u3ecb5473"><strong><span class="ne-text" style="font-size: 16px">数字证书签发和校验过程</span></strong></summary><p id="u608e70e2" class="ne-p"><span class="ne-text" style="font-size: 16px">签发：</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1，CA把持有者公钥、用途、颁发者、有效时间等信息打包成一个包，对这些信息进行HASH计算，2，CA使用私钥将该hash值加密，生成Certificate Signature，也就是数字签名，3，将 Certificate Signature 添加在文件证书上，形成数字证书。</span></p><p id="ue044d062" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">校验：1，客户端使用同样的Hash算法获取证书Hash值H1，2，通常浏览器和操作系统集成了CA公钥信息，浏览器收到证书后可以使用CA公钥解密Certificate Signature，得到哈希值H2，3，对比H1和H2，如果值相同则可信。</span></p></details>
### DNS
DNS，域名管理系统，它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。DNS 要解决的是域名和 IP 地址的映射问题。

默认端口：53

**DNS基于UDP**，但也可以使用TCP：使用UDP主要是轻量，简单，快，低延迟。也可以用TCP，比如大响应/要求可靠传输。

<details class="lake-collapse"><summary id="u38936515"><strong><span class="ne-text" style="font-size: 16px">DNS服务器</span></strong></summary><p id="u6504b1da" class="ne-p"><span class="ne-text">D</span><span class="ne-text" style="font-size: 16px">NS服务器是把域名转化成IP的域名解析服务器，还可以反向解析，缓存结果和递归查询。</span></p><ul class="ne-ul"><li id="u9d68a0ad" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">根 DNS 服务器</span><span class="ne-text" style="font-size: 16px">：提供顶级域（如 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">.com</span></code><span class="ne-text" style="font-size: 16px">、</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">.org</span></code><span class="ne-text" style="font-size: 16px">）信息</span></li><li id="u79a0837e" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">顶级域（TLD）服务器</span><span class="ne-text" style="font-size: 16px">：管理具体顶级域</span></li><li id="ucee109e6" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">权威 DNS 服务器</span><span class="ne-text" style="font-size: 16px">：存储具体域名的 IP 信息，是最终解析来源</span></li><li id="u51f9e906" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">递归 DNS 服务器：客户端请求先到这里，它负责逐级查询直到拿到 IP</span></li></ul></details>
<details class="lake-collapse"><summary id="u9ccd7d0a"><strong><span class="ne-text" style="font-size: 16px">解析过程/工作原理</span></strong></summary><ol class="ne-ol"><li id="u7eaac925" data-lake-index-type="0"><span class="ne-text">查询浏览器缓存和本地缓存，没命中则请求网络配置指定的本地DNS服务器</span></li><li id="ub26562c5" data-lake-index-type="0"><span class="ne-text">还是没有就会开始迭代查询，先查根DNS服务器，然后从返回的顶级域服务器查，再从返回的权威DNS服务器查到IP，缓存后返回给客户端</span></li></ol></details>
<details class="lake-collapse"><summary id="u17555485"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">DNS 劫持</span></strong></summary><p id="u67bc2a76" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。这种劫持可以通过植入恶意的DNS记录或劫持用户的DNS流量来实现。</span></p></details>
**其他**

<details class="lake-collapse"><summary id="ubf19f08e"><span class="ne-text" style="font-size: 16px">DNS报文格式</span></summary><p id="u42a0a01f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">DNS 报文分为查询和回答报文，两种形式的报文结构相同。</span></p><ul class="ne-ul"><li id="ub40b5a01" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">标识符。16 比特，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</span></li><li id="u57625a40" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">标志。1 比特的”查询/回答“标识位，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">0</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">表示查询报文，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">1</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">表示回答报文；1 比特的”权威的“标志位（当某 DNS 服务器是所请求名字的权威 DNS 服务器时，且是回答报文，使用”权威的“标志）；1 比特的”希望递归“标志位，显式地要求执行递归查询；1 比特的”递归可用“标志位，用于回答报文中，表示 DNS 服务器支持递归查询。</span></li><li id="u69feb430" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">问题数、回答 RR 数、权威 RR 数、附加 RR 数。分别指示了后面 4 类数据区域出现的数量。</span></li><li id="u1d96eebc" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">问题区域。包含正在被查询的主机名字，以及正被询问的问题类型。</span></li><li id="ub006ef78" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">回答区域。包含了对最初请求的名字的资源记录。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。</span></strong></li><li id="ua5f36667" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">权威区域。包含了其他权威服务器的记录。</span></li><li id="u4ee08eab" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">附加区域。包含了其他有帮助的记录。</span></li></ul></details>
### <font style="color:rgb(51, 51, 51);">WebSocket</font>
<font style="color:rgb(51, 51, 51);">WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</font>

<font style="color:rgb(51, 51, 51);">WebSocket继承了TCP 协议的全双工，并且解决了粘包的问题，因为它有明确的消息边界，每条信息都加了帧头，能让接收端准确解析完整消息。</font>

<font style="color:rgb(51, 51, 51);">使用场景：适用于需要服务器和客户端频繁交互的大部分场景</font>

<details class="lake-collapse"><summary id="u4644b523"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs HTTP</span></strong></summary><ol class="ne-ol"><li id="u13a2264f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket是状态化的</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">全双工通信模式；HTTP是无状态的请求-响应模型</span></li><li id="udf131684" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket长连接；HTTP/1.0默认短链接，HTTP/1.1默认长连接但仍然是客户端请求服务器响应</span></li><li id="uc4fc3034" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket初始为HTTP发起握手，确认后升级为 WebSocket 长连接；HTTP每次请求独立。</span></li><li id="u170795ec" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket 双方都可主动发送数据，适合</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 14px">高频、实时交互场景如实时聊天、在线游戏、推送通知等；</span><span class="ne-text" style="color: rgb(51, 51, 51)">HTTP  客户端必须先发起请求，适合传统网页通信</span></li></ol></details>
<details class="lake-collapse"><summary id="ufca8789c"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs 长、短轮询</span></strong></summary><ol class="ne-ol"><li id="u12826809" data-lake-index-type="0"><span class="ne-text">短轮询，客户端定期询问服务器是否有新数据，多次短连接，只能客户端到服务器，服务器资源浪费，实时性差</span></li><li id="u4dbab1e4" data-lake-index-type="0"><span class="ne-text">长轮询，客户端发起请求后若没有新数据则保持连接挂起请求，直到有数据再延迟响应，这时候服务端再请求。模拟长连接，服务器压力大，实时性较好，服务器资源浪费</span></li><li id="uec0aa285" data-lake-index-type="0"><span class="ne-text">WebSocket，持久双向连接，全双工，一次连接长期复用，实时性好服务器压力小</span></li></ol></details>
<details class="lake-collapse"><summary id="uc75fe7c2"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs SSE</span></summary><p id="u170b354b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">SSE</span><span class="ne-text">也是</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">实现服务器向浏览器实时推送消息的技术。</span><span class="ne-text">单向通信，只能服务器到客户端，是基于HTTP的扩展。</span><span class="ne-text" style="color: rgb(51, 51, 51)">SSE</span><span class="ne-text">的连接方式是客户端发起一次HTTP请求然后服务端不断推送事件流，优点是更加轻量和简单</span></p></details>
<details class="lake-collapse"><summary id="u26dfa493"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs Socket</span></summary><p id="u51fb2e3b" class="ne-p"><span class="ne-text">Socket 是操作系统提供的一组 API，是介于应用层和传输层之间的一层抽象，用来建立和管理 TCP/UDP 通信。</span></p><p id="ub761418b" class="ne-p"><span class="ne-text"> WebSocket 是一种基于 TCP Socket 的网络协议  </span></p></details>
<details class="lake-collapse"><summary id="u5431cced"><strong><span class="ne-text" style="font-size: 16px">工作原理</span></strong></summary><ol class="ne-ol"><li id="uc372ffe6" data-lake-index-type="0"><span class="ne-text">浏览器/客户端向服务器发送一个 HTTP 请求，其中包含特殊头部：请求升级协议为</span><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket、用于服务器生成响应校验的随机字符串、协议版本</span></li><li id="ud4ba5803" data-lake-index-type="0"><span class="ne-text"> 服务器接收到请求后，如果支持 WebSocket </span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">回复一个 HTTP 101 状态码，确认升级协议为</span><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket和版本，验证客户端的随机字符串</span></li><li id="u1da940e2" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">握手成功，可以双向发送消息</span></li></ol></details>
<details class="lake-collapse"><summary id="u1e6a71da"><span class="ne-text" style="font-size: 16px">消息格式</span></summary><p id="u24a5b768" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">数据包在WebSocket叫做帧，主要关注以下字段：</span></p><p id="ua63b4fb7" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">opcode字段</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：标志数据帧的类型，比如1是text(String)，2是二进制数据类型([]byte)，8关闭连接</span></p><p id="ue69f3743" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">payload字段</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：存放想要传输的数据的长度(单位：字节)</span></p><p id="uefdcd80d" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">payload data字段</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：真正要传输的数据</span></p></details>
### <font style="color:rgb(51, 51, 51);">RPC</font>
<font style="color:rgb(51, 51, 51);">RPC 是一种通信协议，它使得不同进程、不同机器上的程序能够像本地调用一样完成远程方法调用。在 Java 里比较典型的框架有 Dubbo 和 gRPC。</font>

<details class="lake-collapse"><summary id="ueaa237d6"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">核心原理</span></strong></summary><ol class="ne-ol"><li id="u09362a82" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">客户端调用代理（Stub）：客户端发起调用时，先调用本地的代理对象。</span></li><li id="u0e50adad" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">序列化请求</span><span class="ne-text" style="font-size: 16px">：将方法名、参数等信息序列化成二进制。</span></li><li id="ua6d28a94" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">网络传输</span><span class="ne-text" style="font-size: 16px">：通过网络（TCP/HTTP 等）发送给远程服务器。</span></li><li id="u5c0ed203" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">服务端反序列化</span><span class="ne-text" style="font-size: 16px">：服务端收到请求，反序列化得到方法和参数。</span></li><li id="uc26283a5" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">执行方法</span><span class="ne-text" style="font-size: 16px">：服务端执行对应方法，并返回结果。</span></li><li id="u1d71dc0c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">客户端接收结果：结果通过网络传回，客户端代理再反序列化，最终返回给调用方。</span></li></ol></details>
<details class="lake-collapse"><summary id="u06adf9c6"><span class="ne-text" style="font-size: 16px">为什么有HTTP还要有RPC</span></summary><p id="u85709a00" class="ne-p"><span class="ne-text" style="font-size: 16px">HTTP 是一种 应用层协议，它的目标是 标准化客户端和服务端的通信，让浏览器和服务器能互相理解。但它设计时的主要场景是 文档传输（网页、图片等资源），并不是专门为 服务调用 做的。</span></p><p id="u8d786996" class="ne-p"><span class="ne-text" style="font-size: 16px">而在微服务或分布式架构里，我们更需要的是：</span></p><ol class="ne-ol"><li id="u872d1ced" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">高效的服务调用</span><span class="ne-text" style="font-size: 16px">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u0170f522" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">HTTP 本身基于文本格式，协议头比较大，传输开销相对更高。</span></li><li id="ud8a9b310" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">RPC 框架通常会采用 </span><span class="ne-text" style="font-size: 16px">二进制协议</span><span class="ne-text" style="font-size: 16px">（如 gRPC 基于 HTTP/2 + Protobuf），序列化和反序列化更快，性能更高。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="u2f23414b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">跨语言调用</span><span class="ne-text" style="font-size: 16px">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uff283f4e" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">RPC 框架天然支持多语言，比如 gRPC 就支持 Java、Go、Python 等语言间的通信；</span></li><li id="u58cb8f50" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">而 HTTP 只定义了传输方式，本身不解决序列化和接口规范问题。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="u1c30328a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">接口约束和工具链支持</span><span class="ne-text" style="font-size: 16px">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ue24f95e1" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">RPC 一般基于 </span><span class="ne-text" style="font-size: 16px">IDL（接口描述语言）</span><span class="ne-text" style="font-size: 16px"> 定义接口，比如 Protobuf，可以自动生成客户端和服务端代码，保证一致性；</span></li><li id="u2b7bd73b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">HTTP 接口则需要手动维护接口文档和约定，容易出错。</span></li></ul></ul><ol start="4" class="ne-ol"><li id="u04ea6e1c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">更丰富的特性</span><span class="ne-text" style="font-size: 16px">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u91f8a769" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">RPC 框架往往内置 </span><span class="ne-text" style="font-size: 16px">负载均衡、服务发现、熔断、重试</span><span class="ne-text" style="font-size: 16px"> 等功能，更适合大规模分布式系统。</span></li><li id="ub0e44a97" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">HTTP 需要额外配合 Nginx、注册中心等组件来实现。</span></li></ul></ul></details>
## 传输层-网络协议
### <font style="color:rgb(51, 51, 51);">TCP</font>
<font style="color:rgb(51, 51, 51);">是面向连接的(必须一对一)、可靠的(保证一个报文一定到达接收端)、基于字节流(粘/拆包的“罪魁祸首”)的传输层通信协议</font>

<font style="color:rgb(51, 51, 51);">TCP 连接由</font>**<font style="color:rgb(51, 51, 51);">四元组</font>**<font style="color:rgb(51, 51, 51);">唯一标识：</font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">源 IP + 源端口 + 目标 IP + 目标端口</font>`

**<font style="color:rgb(51, 51, 51);">为什么要有TCP</font>**<font style="color:rgb(51, 51, 51);">：IP层是不可靠的，不保证网络包的交付、按序交付、也不保证网络包的数据的完整性。那么就需要上层TCP协议来负责。TCP是一个工作在传输层的可靠数据传输的服务。</font>

<details class="lake-collapse"><summary id="u5921d3dd"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">TCP头格式</span></summary><p id="u89ee3d2d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">序列号（解决网络包乱序问题），确认应答号（解决丢包问题），控制位</span></p><ul class="ne-ul"><li id="u724d2edb" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用来解决网络包乱序问题。</span></strong></li><li id="u0328961b" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。</span></li><li id="u740ba16b" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">控制位：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u31eca8b5" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</span></li><li id="u23e22e7c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</span></li><li id="u2aff6f4d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</span></li><li id="u39361f9e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</span></li></ul></ul></details>
<details class="lake-collapse"><summary id="uf1b77c51"><strong><span class="ne-text" style="font-size: 16px">TCP 的粘包和拆包</span></strong></summary><p id="u1de30ad6" class="ne-p"><span class="ne-text" style="font-size: 16px">TCP是面向字节流协议，没有消息边界概念，所以应用层发送的多次数据在传输层就有可能被合并发送(粘包)或拆开发送(拆包)</span></p><ol class="ne-ol"><li id="u172b61ae" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">粘包即多个应用层数据包被合并到一个TCP报文，可能是TCP的Nagle优化算法把多个练习的小数据收集一次性发送导致的</span></li><li id="u0d8665ee" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">拆包即一个应用层数据包被拆成多个 TCP 报文段发送，一般是</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">要发送的数据大于 TCP 发送缓冲区剩余空间的大小，或待发送数据大于最大报文长度</span></li><li id="u628f6c66" data-lake-index-type="0"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">解决方案：</span></li></ol><ul class="ne-ul"><li id="uebf708eb" data-lake-index-type="0"><span class="ne-text"> 每条消息长度固定，接收方按长度读取，简单高效</span></li><li id="ua23f26a9" data-lake-index-type="0"><span class="ne-text"> 每条消息末尾添加分隔符  </span></li><li id="ub4943949" data-lake-index-type="0"><span class="ne-text"> 在消息头部加上“数据长度字段”  </span></li></ul></details>
<details class="lake-collapse"><summary id="u0c229f79"><strong><span class="ne-text" style="font-size: 16px">TCP 如何保证传输的可靠性</span></strong></summary><p id="ud371b9d2" class="ne-p"><span class="ne-text" style="font-size: 16px">TCP 通过一系列机制来保证数据传输的可靠性。首先，TCP 是面向连接的协议，在传输前必须建立一个可靠的连接，即 三次握手，保证双方能够通信。数据传输过程中，TCP 会使用 序列号 和 确认号 来确保数据按顺序到达。</span></p><p id="u018af011" class="ne-p"><span class="ne-text" style="font-size: 16px">具体来说，TCP 保证可靠性的方式包括：</span></p><ol class="ne-ol"><li id="ufdbeb80f" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">数据分段与重组</span><span class="ne-text" style="font-size: 16px">：大数据会被分割成小数据包传输，每个数据包都有序列号，接收方可以按序号重新组合数据，确保数据的顺序性。</span></li><li id="ufa63bdaf" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">确认机制</span><span class="ne-text" style="font-size: 16px">：每当接收方收到数据包时，都会向发送方发送一个确认消息，告诉发送方自己已成功接收到数据。</span></li><li id="uf7bce1c2" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">重传机制</span><span class="ne-text" style="font-size: 16px">：如果发送方没有在规定时间内收到确认消息，或者接收到的确认号不符合预期，TCP 会重新发送未确认的数据包，确保数据不丢失。</span></li><li id="uc6e74c4c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">流量控制</span><span class="ne-text" style="font-size: 16px">：通过滑动窗口机制，TCP 控制发送方的数据发送速度，避免接收方处理不过来导致丢包。</span></li><li id="u2aa5d9fe" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">拥塞控制：通过算法如慢开始、拥塞避免、快速重传等，TCP 在网络出现拥塞时，动态调整发送速率，避免网络负载过重导致的数据丢失。</span></li></ol></details>
<details class="lake-collapse"><summary id="u5dad081f"><span class="ne-text" style="font-size: 16px">TCP 如何实现流量控制</span></summary><p id="u3abdee4a" class="ne-p"><span class="ne-text" style="font-size: 16px">TCP 实现流量控制的主要机制是 滑动窗口。流量控制的目的是防止发送方发送的数据超过接收方的处理能力，避免数据丢失。</span></p><p id="u7fc94f76" class="ne-p"><span class="ne-text" style="font-size: 16px">具体来说，TCP 通过以下方式实现流量控制：</span></p><ol class="ne-ol"><li id="u26ec1204" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">接收窗口</span><span class="ne-text" style="font-size: 16px">：每个 TCP 连接都有一个接收窗口，表示接收方的缓存空间大小。接收方通过 </span><span class="ne-text" style="font-size: 16px">窗口大小</span><span class="ne-text" style="font-size: 16px"> 告诉发送方自己当前能接受的最大数据量。窗口的大小会动态变化，反映接收方的处理能力和缓冲区空间。</span></li><li id="u899b7a49" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">滑动窗口机制</span><span class="ne-text" style="font-size: 16px">：发送方根据接收方反馈的窗口大小来控制数据的发送量。接收方窗口的大小决定了发送方能在没有确认的情况下发送的数据量。</span><span class="ne-text" style="font-size: 16px">窗口的滑动</span><span class="ne-text" style="font-size: 16px">意味着随着接收方处理完部分数据，接收窗口逐渐“打开”，发送方可以继续发送更多数据。</span></li><li id="u872fe938" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">调整发送速率</span><span class="ne-text" style="font-size: 16px">：如果接收方的窗口大小变小（比如缓冲区已满），发送方会减少数据发送的速率，避免产生溢出或丢包。</span></li></ol><p id="uc3fc107e" class="ne-p"><span class="ne-text" style="font-size: 16px">通过滑动窗口机制，TCP 能够根据接收方的处理能力动态调整发送的数据量，确保数据传输不会因为接收方处理能力不足而丢失或造成过载。</span></p></details>
<details class="lake-collapse"><summary id="u9f599098"><span class="ne-text" style="font-size: 16px">TCP 如何实现拥塞控制</span></summary><p id="uc038114f" class="ne-p"><span class="ne-text" style="font-size: 16px">TCP 的拥塞控制通过动态调整数据发送速率来避免网络拥塞，确保网络的稳定性。TCP 使用了四种主要的拥塞控制算法：</span></p><ol class="ne-ol"><li id="u99073ea3" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">慢启动（Slow Start）</span><span class="ne-text" style="font-size: 16px">：</span><span class="ne-text" style="font-size: 16px">当连接开始时，TCP 发送方会将拥塞窗口设置为一个较小的值（通常是 1 或 2 个最大段大小 MSS）。每当收到一个确认（ACK），拥塞窗口就增加 1 个 MSS，直到达到一个阈值，进入后续阶段。慢启动的目的是迅速探测网络的带宽，避免初期发送过多数据导致拥塞。</span></li><li id="ud8ae0205" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">拥塞避免（Congestion Avoidance）</span><span class="ne-text" style="font-size: 16px">：</span><span class="ne-text" style="font-size: 16px">当拥塞窗口大小超过慢启动阈值时，进入拥塞避免阶段。此时，TCP 不再以指数增长的方式增加窗口，而是采用线性增长。每收到一个确认，窗口增大 1/MSS，窗口增大速度减缓，以避免过快增加负载导致拥塞。</span></li><li id="ufe4f9be1" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">快速重传（Fast Retransmit）</span><span class="ne-text" style="font-size: 16px">：</span><span class="ne-text" style="font-size: 16px">当发送方连续收到 3 个重复的 ACK 时，表示某个数据包丢失了。此时，TCP 立即重传丢失的数据包，而无需等待超时，从而减少了重传的延迟。</span></li><li id="u88fb918d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">快速恢复（Fast Recovery）：在快速重传后，TCP 进入快速恢复阶段。此时，拥塞窗口大小被设置为丢失数据包时窗口大小的一半，继续通过线性增长的方式进行拥塞避免。这使得 TCP 可以迅速恢复并继续传输数据，而不是重新进入慢启动阶段。</span></li></ol></details>
<details class="lake-collapse"><summary id="ub80af070"><span class="ne-text" style="font-size: 16px">TCP 如何实现重传机制</span></summary><p id="u7c2483dd" class="ne-p"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">重传机制是当报文丢失或延迟时，必须能检测并重新发送，保证可靠</span></p><p id="u6c5198d1" class="ne-p"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">主要重传机制有：</span></p><ol class="ne-ol"><li id="uf3e7195a" data-lake-index-type="0"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">超时重传：发送方在发送每个报文后启动定时器，超时时间内没有收到ACK就重传。简单但是延迟大</span></li><li id="u958fbfaf" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">快速重传：当接收方收到失序报文时，会重复发送上一个 ACK；发送方若连续收到 3 个相同 ACK，就认为该段丢失，立即重传，无需等超时。速度更快</span></li><li id="u551dc36c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">SACK 选择性确认： 普通 ACK 只能告诉“已收到第几字节前的数据”，而 SACK 允许接收方告诉发送方“哪些片段已收到”，这样发送方只需重传</span><strong><span class="ne-text">丢失的部分</span></strong><span class="ne-text" style="font-size: 16px">，而不是整段。 重传效率高。</span></li></ol></details>
---

<details class="lake-collapse"><summary id="u3f01166e"><strong><span class="ne-text" style="font-size: 16px">三次握手</span></strong></summary><p id="u524d30be" class="ne-p"><span class="ne-text" style="font-size: 16px">三次握手是</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为了确保双方接收和发送能力都正常，建立一条可靠的全双工通信通道。</span></p><ol class="ne-ol"><li id="u526c8b57" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">一开始客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</span></li><li id="ue313dafa" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">客户端随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。然后把SYN报文发送给服务端表示向服务端发起连接，之后客户端处于 SYN-SENT 状态</span></li><li id="ue3e679ea" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">服务端收到客户端的 SYN 报文后，随机初始化自己的序号（server_isn）并填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1，接着把 SYN 和 ACK 标志位置为 1。然后发送给客户端，之后服务端处于 SYN-RCVD 状态</span></li><li id="ue4b8ce1e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">客户端收到服务端报文后回应最后一个应答报文，应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据(但很少)，之后客户端处于 ESTABLISHED 状态</span></li><li id="u37188b32" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态，此时连接就已建立完成</span></li></ol></details>
<details class="lake-collapse"><summary id="u86f818dd"><span class="ne-text" style="font-size: 16px">为什么要三次握手，不能两次？四次？</span></summary><ol class="ne-ol"><li id="u315c1ae0" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">三次握手是</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为了确保双方接收和发送能力都正常，建立一条可靠的全双工通信通道。</span></li><li id="uad4be709" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">如果两次，可能有已失效的连接请求报文突然又传到服务端，从而造成错误的连接建立。比如客户端第一次发送的 SYN 因网络延迟滞留很久，客户端以为超时了就重新发了一个 SYN 并完成连接，这个时候滞留的旧 SYN 报文又到达服务器，服务器误以为客户端又要建新连接，于是回 SYN+ACK，并进入半连接状态，造成资源浪费</span></li><li id="ue23322ed" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">如果四次，其实是把第二次握手的SYN和ACK分开发送给客户端，但是可以合并成一次</span></li></ol></details>
<details class="lake-collapse"><summary id="u35a293ed"><span class="ne-text" style="font-size: 16px">握手丢失了会发生什么</span></summary><ol class="ne-ol"><li id="u3ae1e231" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">当第一次握手丢失：当客户端一直收不到第二次握手的回应，会触发超时重传机制，重新发送报文，并且与之前的序列号一样。（每次重传的超时时间是上次的2倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</span></li><li id="ude0aa814" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">当第二次握手丢失：因为第二次丢失对客户端的影响一样，所以也会触发上面的操作。同时对于服务器自然也收不到第三次握手，那么服务端会重传 SYN-ACK 报文，也就是第二次握手的超时重传。所以，当第二次握手丢失了，客户端和服务端都会重传。</span></li><li id="ue1f388ab" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">当第三次握手丢失：服务端会重传 SYN-ACK 报文，当服务器重传到最大重传次数就断开连接。ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文，最后服务器关闭连接。</span></li></ol></details>
<details class="lake-collapse"><summary id="u69b4a35d"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">服务端收到客户端发起的SYN后发生了什么</span></summary><p id="u2127b900" class="ne-p"><span class="ne-text" style="font-size: 16px">服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到</span><span class="ne-text" style="color: rgb(51, 51, 51)">全连接队列</span><span class="ne-text" style="font-size: 16px">，等待进程调用 accept() 函数时从全连接队列中取出该连接进行通信。</span></p></details>
<details class="lake-collapse"><summary id="u6f826fe8"><span class="ne-text" style="font-size: 16px">为什么初始化的序列号要求不一样，如何随机产生的</span></summary><p id="u6d267d4b" class="ne-p"><span class="ne-text" style="font-size: 16px">为了防止旧数据混入新连接、避免TCP 重放攻击，并确保每个连接的独立性和安全性。</span></p><ol class="ne-ol"><li id="udf4d24be" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">若新连接使用与已关闭连接相同的序号，网络中滞留的旧数据包可能被误认为属于新连接，造成数据混淆或逻辑错误  </span></li><li id="u67bd3bb0" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">攻击者可以猜测和伪造数据包，进行TCP 重放攻击</span></li></ol><hr id="J7k1k" class="ne-hr"><p id="ua89e5522" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">TCP 的初始序列号 ISN 现代做法多用内核保密的种子/密钥结合连接信息和时间通过哈希/PRF 生成，使序号既唯一又难以预测，从而提升可靠性与安全性。  </span></p></details>
<details class="lake-collapse"><summary id="u2f43d7b6"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">半连接队列和全连接队列</span></strong></summary><p id="u52b85230" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">在 TCP 三次握手过程中，Linux 内核会维护两个队列来管理连接请求：</span></p><p id="u2ce60994" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">半连接队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">（也称 SYN Queue）：当服务端收到客户端的 SYN 请求时，此时双方还没有完全建立连接，它会把半连接状态的连接放在半连接队列。</span></p><p id="uc3496687" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">全连接队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">（也称 Accept Queue）：当服务端收到客户端对 ACK 响应时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。如果未收到客户端的 ACK 响应，会进行重传，重传的等待时间通常是指数增长的。如果重传次数超过系统规定的最大重传次数，系统将从半连接队列中删除该连接信息。</span></p><p id="u63092e4f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">这两个队列的存在是为了处理并发连接请求，确保服务端能够有效地管理新的连接请求。</span></p><p id="u99b9d0d5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包</span></p></details>
<details class="lake-collapse"><summary id="u725a2843"><strong><span class="ne-text" style="font-size: 16px">SYN 攻击</span></strong></summary><p id="u677eda50" class="ne-p"><span class="ne-text" style="font-size: 16px">攻击者向服务器伪造大量TCP连接请求（SYN包），并且在收到服务器的回应（SYN-ACK）后，拒绝发送最终的确认（ACK）。这会导致服务器上积压大量半连接，耗尽其资源，使其无法为正常用户提供服务。</span></p><p id="u6eeecca9" class="ne-p"><span class="ne-text" style="font-size: 16px">避免 SYN 攻击方式：</span></p><ul class="ne-ul"><li id="u5ae4e90c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">调大 netdev_max_backlog， 增大内核网络接收队列，治标不治本；</span></li><li id="uaabff677" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">增大 TCP 半连接队列，消耗内存；</span></li><li id="u2081c76d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">开启 tcp_syncookies，最有效轻量高效，在队列满时不分配资源、用算法验证合法 ACK， 只有能正确返回 Cookie 的合法客户端才会建立连接； </span></li><li id="ubb8a572b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">减少 SYN+ACK 重传次数，更快超时失败，但可能影响不稳定的正常连接</span></li></ul></details>
---

<details class="lake-collapse"><summary id="uae55a3ca"><strong><span class="ne-text" style="font-size: 16px">四次握手</span></strong></summary><p id="u02a0c3ee" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">四次挥手是 TCP 双方各自独立关闭发送通道的过程，确保数据传输完整、有序关闭连接，其中 FIN 表示主动关闭，ACK 表示确认关闭。</span></p><ol class="ne-ol"><li id="uad816ac3" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">客户端主动调用关闭连接的函数，向服务器发送FIN报文段，表示没有数据要发送，但是还能接收数据，进入FIN_WAIT_1状态</span></li><li id="u6525bda1" data-lake-index-type="0"><span class="ne-text">服务端收到FIN后，TCP 栈会在接收缓冲区中插入一个 EOF，服务端应用程序 </span><code class="ne-code"><span class="ne-text">read()</span></code><span class="ne-text"> 到它后，发现对方已关闭发送，回复ACK，进入CLOSE_WAIT状态。客户端收到这个 ACK 后进入 FIN_WAIT_2 状态。</span></li><li id="uaa4bc779" data-lake-index-type="0"><span class="ne-text">服务器处理完剩余数据并调用 </span><code class="ne-code"><span class="ne-text">close()</span></code><span class="ne-text">，发送FIN报文，进入 LAST_ACK 状态表明不再发送数据</span></li><li id="u407fde56" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态。服务器收到后进入CLOSE 状态</span></li><li id="u2ccf6832" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最后客户端经过 2MSL(2*报文最大生存时间) 时间之后，也进入 CLOSE 状态</span></li></ol><p id="u124e5914" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">双方都可以主动断开连接，但是主动关闭连接的，才有 TIME_WAIT 状态</span></p></details>
<details class="lake-collapse"><summary id="ud65d4594"><span class="ne-text" style="font-size: 16px">为什么要四次挥手，FIN和ACK不能一起发？</span></summary><p id="u7c244689" class="ne-p"><span class="ne-text" style="font-size: 16px">TCP是双工的，连接两端的关闭是独立的。服务端在收到 FIN 后可能还有数据要发送，因此不能立即发送 FIN，必须分两次完成 ACK 和 FIN。</span></p><p id="ue49f3d5c" class="ne-p"><span class="ne-text" style="font-size: 16px"> 如果服务端在收到客户端的 FIN 时，确实已经没有要发送的数据，就可以立即同时发送 ACK + FIN 报文，即 第二次和第三次合并成一次。  </span></p></details>
<details class="lake-collapse"><summary id="ufbfada9a"><span class="ne-text" style="font-size: 16px">握手丢失了会发生什么</span></summary><ol class="ne-ol"><li id="u22a6ca0a" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">第一次挥手丢失：客户端迟迟收不到服务端ACK，触发超时重传，重发报文，重发次数超过tcp_orphan_retries后会等待一段时间( *=2 )，如果还是没有收到就直接进入close状态</span></li><li id="u81f78e92" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">第二次挥手丢失：ACK 报文是不会重传的，客户端重复第一次挥手丢失的操作，导致服务端再次返回 ACK</span></li><li id="u8f215184" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">第三次挥手丢失： 客户端一直停在 FIN_WAIT2状态，等待服务端 FIN；若服务端 FIN 超时未发出，会重传；超过重传次数仍无响应则服务端主动关闭。  </span></li><li id="u81a3888c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">第四次挥手丢失： 客户端已进入 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">TIME_WAIT</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 状态等待 2MSL，服务端没收到 ACK 会重传 FIN。客户端收到后会重置计时器（重新等待 2MSL），最终双方正常关闭  </span></li></ol></details>
<details class="lake-collapse"><summary id="u65c17f10"><span class="ne-text" style="color: rgb(51, 51, 51)">为什么要等2MSL</span></summary><ol class="ne-ol"><li id="u3c360cec" data-lake-index-type="0"><span class="ne-text">防止最后一个 ACK丢失：如果第四次挥手的ACK丢失服务端重传FIN， 客户端等待 2MSL 的时间内仍然能收到这个重传的 FIN，如果不等直接关闭就会导致 服务端就会一直重传 FIN，浪费资源。</span></li><li id="u7e251a28" data-lake-index-type="0"><span class="ne-text"> 等待 2×MSL 可以确保所有旧连接中的延迟或乱序报文都从网络中消失，下次连接的时候不会收到上次连接遗留的数据  </span></li></ol></details>
### UDP
<font style="color:rgb(51, 51, 51);">UDP 是一个简单的、无连接的、不可靠的传输层协议。它只提供最基本的数据传输功能，不保证数据包的顺序、交付或避免重复，因此开销极小、延迟很低，有消息边界不会出现粘包问题，非常适合那些对实时性要求高于可靠性的应用。</font>

<details class="lake-collapse"><summary id="u2cd4f0bb"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">TCP vs UDP</span></strong></summary><ol class="ne-ol"><li id="u1f7c1e35" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">连接方式，TCP传输数据需要先建立连接；UDP不需要连接，即刻传输数据</span></li><li id="u8c864c93" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">可靠性：TCP是可靠传输，确保无差错、不丢失、不重复、按序到达；UDP不保证到达或顺序</span></li><li id="uaeeed8a5" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">传输方式，TCP是流式传输，没有边界，但保证顺序；UDP是一个包一个包发送，有边界但是可能丢包和乱序</span></li><li id="u3b606229" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">传输效率，TCP有 握手、校验、流控，慢；UDP开销极小、延迟很低，速度快</span></li><li id="u0a4a6b14" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">TCP有拥塞控制和流量控制机制，保证数据的安全性；但是UDP都没有，网络非常拥堵也不影响UDP发送速率</span></li><li id="u2c841181" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">适用场景：TCP适合数据准确性和完整性要求高的场景，如文件传输、HTTP、邮件等；UDP适合</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">对实时性和速度要求高于可靠性的场景，如实时通信、音视频、游戏、DNS 等</span></li></ol></details>
<details class="lake-collapse"><summary id="ud924d8b7"><span class="ne-text" style="font-size: 16px">QUIC---基于UDP的可靠传输</span></summary><p id="uc35096e1" class="ne-p"><span class="ne-text" style="font-size: 16px">UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输，在http3 就用了 quic 协议。</span></p><ul class="ne-ul"><li id="u2c9b40fd" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">连接迁移：QUIC支持在网络变化时快速迁移连接，例如从WiFi切换到移动数据网络，以保持连接的可靠性。</span></li><li id="ubfbd54d6" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">重传机制：QUIC使用重传机制来确保丢失的数据包能够被重新发送，从而提高数据传输的可靠性。</span></li><li id="ucb76a388" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">前向纠错：QUIC可以使用前向纠错技术，在接收端修复部分丢失的数据，降低重传的需求，提高可靠性和传输效率。</span></li><li id="u990f952a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">拥塞控制：QUIC内置了拥塞控制机制，可以根据网络状况动态调整数据传输速率，以避免网络拥塞和丢包，提高可靠性。</span></li></ul></details>
## 网络层-网络协议
### <font style="color:rgb(51, 51, 51);">IP</font>
IP（Internet Protocol，网际协议） 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

<details class="lake-collapse"><summary id="u0a60a10b"><strong><span class="ne-text" style="font-size: 16px">IP地址，IPv4 和 IPv6</span></strong></summary><p id="ub1d7609f" class="ne-p"><span class="ne-text" style="font-size: 16px">IP地址是分配给每台网络设备的唯一标识，用于在网络中定位和通信。</span></p><p id="u32d244e6" class="ne-p"><span class="ne-text" style="font-size: 16px">IPv4 和 IPv6是两个不同版本的IP协议：</span></p><ol class="ne-ol"><li id="u530fcc1a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">IPv4使用32位地址，以</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">点分十进制表示，最多约 42 亿个地址，已接近枯竭；而IPv6使用168位地址，以冒号分隔的十六进制表示，地址空间几乎无限</span></li><li id="u76178028" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">IPv4 报文头较复杂，有更多字段；IPv6 头部更简洁，设计更高效，易于路由器处理</span></li><li id="u34b2a29b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">IPv4 中广泛使用 NAT 解决地址不足；IPv6 不需要 NAT，每个设备可拥有唯一公网地址，避免了 IPv4 中因 NAT 带来的连接复杂、端到端通信受限等问题</span></li><li id="u8c6b5eae" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">IPv4 原生支持较弱，依赖额外配置；IPv6 原生支持 IPsec 协议，提供端到端的数据加密与身份认证，增强网络通信的安全性。支持自动配置，扩展性强</span></li></ol></details>


<details class="lake-collapse"><summary id="u5e923634"><span class="ne-text" style="font-size: 16px">IP地址过滤</span></summary><p id="uc3651eb9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问，是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用</span></p></details>
<details class="lake-collapse"><summary id="u4c5f24d6"><span class="ne-text" style="font-size: 16px">IP寻址流程</span></summary><ol class="ne-ol"><li id="u807de8ab" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">检查是否是同一网段：发送方通过子网掩码判断目标 IP 是否与自己处于同一网段。</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ud649caf8" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">如果是：直接通过局域网 ARP 协议获取目标设备的 MAC 地址，完成通信。</span></li><li id="ub54543d0" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">如果不是：将数据包交给默认网关（通常是路由器）转发。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="ue1ef9bbb" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">路由转发</span><span class="ne-text" style="font-size: 16px">：</span><span class="ne-text" style="font-size: 16px">如果目标 IP 不在本地网段，数据包会被交给路由器，路由器根据自己的</span><span class="ne-text" style="font-size: 16px">路由表</span><span class="ne-text" style="font-size: 16px">决定下一跳，将数据一跳一跳转发，直到到达目标网络。</span></li><li id="uf541b090" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">最终送达主机：到达目标网络后，最后一跳路由器使用 ARP 找到目标主机的 MAC 地址，完成局域网传输。</span></li></ol></details>
<details class="lake-collapse"><summary id="u66158f89"><span class="ne-text" style="font-size: 16px">NAT--- 地址转换技术  </span></summary><p id="uf52e74db" class="ne-p"><span class="ne-text"> 把私有 IP 地址转换为公网 IP 地址，实现多设备共享一个公网 IP， 解决 IPv4 地址不足问题 </span></p><p id="ub9042844" class="ne-p"><span class="ne-text"> 依赖 IP，通常在路由器</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">或防火墙设备</span><span class="ne-text">实现   </span></p><p id="u9e87f1f0" class="ne-p"><span class="ne-text">优点：</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">缓解了 IPv4 地址短缺的问题，隐藏内部网络IP地址提供了一定安全性</span></p><p id="u367a2752" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">缺点：破环端到端通信，并且因为维护映射表提高了网络配置的复杂性</span></p></details>
## 网络接口层-网络协议
### <font style="color:rgb(51, 51, 51);">ARP</font>
 ARP（地址解析协议）是用于 将网络层的 IP 地址映射到数据链路层的 MAC 地址 的协议。它工作在 数据链路层，在局域网（LAN）中非常重要。

ARP 工作在 TCP/IP 的网络接口层（相当于 OSI 的数据链路层），和 IP 协议配合使用。

<details class="lake-collapse"><summary id="uf9708ee6"><span class="ne-text" style="font-size: 16px">工作原理</span></summary><p id="u7c0f85f1" class="ne-p"><span class="ne-text" style="font-size: 16px">当设备需要与目标设备通信时，如果不知道目标设备的 MAC 地址，会通过广播发送 ARP 请求包，询问目标 IP 地址对应的 MAC 地址。局域网中的所有设备都会接收该请求。如果某设备的 IP 地址与请求中的目标 IP 地址匹配，它会发送 ARP 响应包，告知自己的 MAC 地址。ARP 会将 IP 地址和 MAC 地址的映射关系存储在本地的 ARP 缓存中。</span></p></details>
## <font style="color:rgb(51, 51, 51);">网络攻击</font>
### HTTP Flood 
<font style="color:rgb(51, 51, 51);">应用层攻击。</font>

HTTP Flood 是一种应用层 DDoS 攻击，攻击者伪装成正常用户，通过持续发送大量合法的 HTTP 请求来压垮服务器。

特点：高隐蔽性，请求行为和正常用户一样；占用宽带不大但是对服务器的影响大

<details class="lake-collapse"><summary id="uc0c21f85"><span class="ne-text" style="font-size: 16px">应对方法</span></summary><ol class="ne-ol"><li id="u71bc3d0d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">行为分析与挑战机制：引入验证码（如图形验证码、JS 校验）过滤掉非人类请求；</span></li><li id="u4043d7bc" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">接入 Web 应用防火墙（WAF）</span><span class="ne-text" style="font-size: 16px">：识别异常访问行为和请求模式；</span></li><li id="u77111c17" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用 CDN 进行缓存和流量缓冲</span><span class="ne-text" style="font-size: 16px">：减少源站压力；</span></li><li id="u6aee5f50" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">IP/UA 访问频率限制：针对高频访问 IP 做封禁或限流。</span></li></ol></details>
### <font style="color:rgb(51, 51, 51);">CSRF攻击</font>
<font style="color:rgb(51, 51, 51);">应用层攻击。</font>

<font style="color:rgb(51, 51, 51);">CSRF（跨站请求伪造）是一种攻击手段，攻击者通过诱导用户执行恶意操作，从而获取用户数据或执行恶意代码。CSRF攻击通常通过伪造一个合法的HTTP请求来实现，这个请求看起来是合法的，但实际上是为了执行一个攻击者控制的操作。</font>

<details class="lake-collapse"><summary id="u9c13a8d9"><span class="ne-text" style="font-size: 16px">应对方法</span></summary><ol class="ne-ol"><li id="u9533fe10" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">强制Referer头部：在服务器端检查请求的Referer头部，确保请求来自可信来源</span></li><li id="uab52729f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">添加校验token：</span><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token</span></li><li id="uf4ed865f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(44, 62, 80); font-size: 16px">敏感操作多重验证</span></li></ol></details>
### <font style="color:rgb(51, 51, 51);">XSS攻击</font>
<font style="color:rgb(51, 51, 51);">应用层攻击。</font>

<font style="color:rgb(51, 51, 51);">跨站脚本攻击，攻击者通过在Web页面中插入恶意脚本代码，然后诱使用户访问该页面，从而使得恶意脚本在用户浏览器中执行，从而盗取用户信息、会话信息等敏感数据，甚至控制用户账户。</font>

<details class="lake-collapse"><summary id="ub12ae121"><span class="ne-text" style="font-size: 16px">分类，三种</span></summary><ol class="ne-ol"><li id="u377c46e7" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">存储型XSS：脚本存储在服务器，访问页面的时候被执行，攻击影响大，可长期存在</span></li><li id="uf68099d3" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">反射型XSS：恶意脚本通过URL参数或者表单输入反射到页面输出，一次性攻击</span></li><li id="u58411be8" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">基于DOM的XSS：</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">修改原始的客户端代码，客户端JS操作DOM时触发，完全发生在浏览器</span></li></ol></details>
<details class="lake-collapse"><summary id="ufaa4ca16"><span class="ne-text" style="font-size: 16px">应对方法</span></summary><ul class="ne-ul"><li id="u65b640be" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">输入验证：对所有用户输入的数据进行有效性检验，过滤或转义特殊字符。例如，禁止用户输入HTML标签和JavaScript代码。</span></li><li id="udb337d3d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">输出编码：在网页输出用户输入内容时，使用合适的编码方式，如HTML转义、URL编码等，防止恶意脚本注入。</span></li><li id="ufa6bb92c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Content Security Policy（CSP）：通过设置CSP策略，限制网页中可执行的脚本源，有效防范XSS攻击。</span></li><li id="u3ef6253b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用HttpOnly标记：在设置Cookie时，设置HttpOnly属性，使得Cookie无法被JavaScript代码读取，减少受到XSS攻击的可能。</span></li></ul></details>
### <font style="color:rgb(51, 51, 51);">TCP重置攻击</font>
 传输层攻击。

攻击者向正在通信的任一端发送伪造的带有 RST（Reset） 标志 的 TCP 报文，企图使那端立即关闭连接，从而中断双方通信

特点：攻击隐秘；无需占用目标资源；对实时连接场景危害大

<details class="lake-collapse"><summary id="u6e417340"><span class="ne-text" style="font-size: 16px">应对方法</span></summary><ol class="ne-ol"><li id="uaf1a2d6d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用 TLS/SSL 加密通信，即使连接被断，也能校验完整性，避免数据丢失或伪造；</span></li><li id="u0a6c5212" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用更随机的初始序列号</span><span class="ne-text" style="font-size: 16px">，增加攻击者预测难度；</span></li><li id="ub5a3c11d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">在防火墙或网关中启用 TCP 检查机制</span><span class="ne-text" style="font-size: 16px">，过滤伪造 RST 包；</span></li><li id="uf5e275e8" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">启用 IDS/IPS 检测，发现频繁或异常的 RST 包行为。</span></li></ol></details>
### <font style="color:rgb(51, 51, 51);">UDP Flood</font>
传输层攻击。

UDP Flood 是一种基于 UDP 协议的 DDoS 攻击方式，通过持续向目标服务器发送大量伪造的 UDP 数据报，使服务器尝试处理或者返回不可达请求，以此来消耗服务器的处理能力和带宽资源。

<details class="lake-collapse"><summary id="uaa8f335a"><span class="ne-text">应对方法</span></summary><ol class="ne-ol"><li id="u2aaab20c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">限制 UDP 速率：在防火墙、网关或操作系统层面配置对 UDP 流量的速率限制。</span></li><li id="u2381b864" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">启用智能流量过滤</span><span class="ne-text" style="font-size: 16px">：通过 DPI（深度包检测）识别异常 UDP 流量特征。</span></li><li id="u45e70b39" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">接入抗 DDoS 清洗服务</span><span class="ne-text" style="font-size: 16px">：在云平台或运营商层引流清洗大规模 UDP 攻击流量。</span></li><li id="u4a059bb3" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">禁用不必要的 UDP 服务：减少攻击面，例如关闭不使用的 TFTP、DNS、NTP 等端口。</span></li></ol></details>
###  TCP 拒绝服务（DoS）  
传输/网络层攻击。

指的是利用TCP协议特性来耗尽服务器资源或宽带。最典型的是**SYN ****<font style="color:rgb(51, 51, 51);">Flood。</font>**

> 详见TCP-三次握手-SYN攻击
>

### <font style="color:rgb(51, 51, 51);">IP欺骗</font>
网络层攻击。

是一种伪造 IP 数据包源地址的攻击技术，攻击者通过将自己的 IP 地址伪装成另一个主机的地址，使得目标主机认为数据包是从一个信任的来源发送的，从而隐藏身份、绕过身份验证、发起其他攻击。

<details class="lake-collapse"><summary id="u995c8d31"><span class="ne-text">应对方法</span></summary><ol class="ne-ol"><li id="uc51b120b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">隐藏真实身份：攻击者可以隐藏自己的身份，避免被追踪。</span></li><li id="u350893c7" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">绕过身份验证</span><span class="ne-text" style="font-size: 16px">：通过伪装成受信任的主机，突破防火墙或安全认证机制。</span></li><li id="u3a56259e" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">发起其他攻击：例如 SYN Flood、DDoS 攻击等，攻击者利用伪造的 IP 地址将流量分散或隐藏攻击来源。</span></li></ol></details>
### <font style="color:rgb(51, 51, 51);">中间人攻击</font>
中间人攻击是一种典型的被动+主动结合的网络攻击方式，攻击者通过“夹在通信双方中间”，拦截、篡改或伪造双方传输的数据，从而窃取敏感信息或干扰通信内容。

<details class="lake-collapse"><summary id="u8fcdfef3"><span class="ne-text">常见方式</span></summary><ol class="ne-ol"><li id="u7474ec49" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Wi-Fi 嗅探：攻击者搭建恶意热点或监听公共 Wi-Fi，截获明文传输数据；</span></li><li id="u5568935b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">ARP 欺骗</span><span class="ne-text" style="font-size: 16px">：在局域网中伪装为网关，拦截局域网中的通信；</span></li><li id="u03cb410c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">DNS 劫持</span><span class="ne-text" style="font-size: 16px">：篡改域名解析结果，将用户引导到钓鱼网站；</span></li><li id="ue919712a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">SSL 劫持：伪造证书，欺骗客户端建立“假”的 HTTPS 连接，窃取加密数据。</span></li></ol></details>
<details class="lake-collapse"><summary id="uced61054"><span class="ne-text">应对方法</span></summary><ol class="ne-ol"><li id="uf4d5c547" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用 HTTPS + 合法数字证书，保障通信加密和身份认证；</span></li><li id="u2dcd0c84" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">启用 HSTS（HTTP Strict Transport Security）</span><span class="ne-text" style="font-size: 16px">，强制浏览器使用 HTTPS；</span></li><li id="u75d23dff" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">验证证书合法性</span><span class="ne-text" style="font-size: 16px">，防止伪造证书欺骗；</span></li><li id="u118f4c2a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">避免连接不可信 Wi-Fi 网络</span><span class="ne-text" style="font-size: 16px">，提升客户端安全意识；</span></li><li id="ub26cceb2" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">在局域网中启用 ARP 防护和网络隔离，防止本地伪造。</span></li></ol></details>
