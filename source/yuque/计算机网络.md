- [x] **网络模型**
- [x] **应用层-网络协议**
- [x] HTTP
- [x] HTTPS
- [x] DNS
- [x] <font style="color:rgb(51, 51, 51);">WebSocket</font>
- [ ] **传输层-网络协议**
- [ ] TCP
- [ ] UDP
- [ ] **网络层-网络协议**
- [ ] IP
- [ ] **网络接口层-网络协议**
- [ ] **网络攻击**
- [ ] **其他**

## 网络模型
> <font style="color:rgb(119, 119, 119);">OSI 是理论上的网络通信模型，TCP/IP 是实际应用层面上的网络通信模型</font>
>

### `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">OSI</font>`<font style="color:rgb(51, 51, 51);">模型</font>
OSI七层模型是理论上的网络分层模型，把通信过程分为七层，<font style="color:rgb(51, 51, 51);">主要用于教学和标准化</font>

1. **<font style="color:rgb(51, 51, 51);">应用层</font>**<font style="color:rgb(51, 51, 51);">：为用户提供网络服务，如HTTP、DNS、文件传输（FTP）等。</font>
2. **<font style="color:rgb(51, 51, 51);">表示层</font>**<font style="color:rgb(51, 51, 51);">：负责数据的格式化、加密和解密</font>
3. **<font style="color:rgb(51, 51, 51);">会话层</font>**<font style="color:rgb(51, 51, 51);">：管理设备之间的会话，负责会话的建立、维护和终止（如RPC）。</font>
4. **<font style="color:rgb(51, 51, 51);">传输层</font>**<font style="color:rgb(51, 51, 51);">：提供端到端的数据传输（如TCP、UDP协议）。</font>
5. **<font style="color:rgb(51, 51, 51);">网络层</font>**<font style="color:rgb(51, 51, 51);">：路由和寻址（如IP协议）。</font>
6. **<font style="color:rgb(51, 51, 51);">数据链路层</font>**<font style="color:rgb(51, 51, 51);">：保证数据在物理层上可靠地传输，错误检测与纠正（如以太网、MAC地址）。</font>
7. **<font style="color:rgb(51, 51, 51);">物理层</font>**<font style="color:rgb(51, 51, 51);">：数据的实际物理传输，比如电缆、光纤等。</font>

### `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">TCP/IP</font>`<font style="color:rgb(51, 51, 51);">四层模型</font>
<font style="color:rgb(51, 51, 51);">是广泛应用的网络模型，是互联网的基础</font>

1. **<font style="color:rgb(51, 51, 51);">应用层</font>**<font style="color:rgb(51, 51, 51);">：专注于提供应用功能，如HTTP、FTP、Telnet、DNS、SMTP 		-应用数据</font>
2. **<font style="color:rgb(51, 51, 51);">传输层</font>**<font style="color:rgb(51, 51, 51);">：为应用层提供网络支持，包括TCP和UDP 		-TCP/UDP头+应用数据</font>
3. **<font style="color:rgb(51, 51, 51);">网络层</font>**<font style="color:rgb(51, 51, 51);">：负责实际的传输功能，最常用的是IP协议		 -IP头+TCP/UDP头+应用数据</font>
4. **<font style="color:rgb(51, 51, 51);">网络接口层</font>**<font style="color:rgb(51, 51, 51);">：负责在</font>物理网络上<font style="color:rgb(51, 51, 51);">发送原始数据包 		-帧头+IP头+TCP/UDP头+应用数据+帧尾</font>
+ <font style="color:rgb(51, 51, 51);">分别对应OSI的1-3，4，5，6-7层</font>
+ 网络接口层的传输单位是帧，网络层 (IP等)的传输单位是包/数据报，传输层 (TCP等)的传输单位是段，应用层 (HTTP等)的传输单位是消息或报文。

<details class="lake-collapse"><summary id="u6cb35f3d"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为什么要分层</span></strong></summary><p id="u5e69d70a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">通过分层标准化交互的过程。</span></p><p id="u2fde0539" class="ne-p"><span class="ne-text" style="font-size: 16px">具体讲，分层一方面使各层相互独立，不需要考虑其他层的实现，只需要调用下层功能；另一方面提高了灵活性和可替换性，类似高内聚、低耦合的原则；并且使得复杂的计算机网络系统变得易于设计，实现和标准化。</span></p></details>
## 应用层-网络协议
### <font style="color:rgb(51, 51, 51);">HTTP</font>
HTTP，即超文本传输协议。

> 超文本：文字、图片、视频等的混合体，有超链接功能，最常见的：HTML
>

用于Web浏览器和服务器之间传输的协议。定义了浏览器如何请求网页，以及服务器如何响应这些请求。

默认端口：80

<details class="lake-collapse"><summary id="u3deb8d67"><strong><span class="ne-text">状态码</span></strong><span class="ne-text">---</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于描述请求的结果</span></summary><p id="u05d9ce7a" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1xx表示正在处理</span></strong></p><p id="u36ddfefa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">基本上没见过，100 Continue客户端应该继续发送请求</span></p><p id="u68c9eb75" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">102 Processing正在处理，</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">用于长时间操作</span></p><p id="u05c3145f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2xx表示正常处理完毕</span></strong></p><p id="u174527f3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">200 OK表示请求成功</span></p><p id="ud4da34a6" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">201 Created</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px"> 资源创建成功，如 POST 请求后返回新资源的 URL</span></p><p id="u75828305" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">204 No Content表示成功但是没有body数据</span></p><p id="ue264ea14" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">206 Partial Content表示资源只是一部分</span></p><p id="u4405bcba" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">3xx表示需要附加操作</span></strong></p><p id="u5c405b5b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">301Moved Permanently表示永久重定向，资源不存在了，需改用新的 URL</span></p><p id="u62efb4eb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">302 Found表示临时重定向，请求资源还在但是暂时需要另一个URL访问</span></p><p id="u22738dfb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">304 Not Modified 表示资源未修改，</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">仅用于缓存控制（客户端可复用本地缓存）</span></p><p id="u366f855f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">4xx表示服务器无法处理请求</span></strong></p><p id="uc36977ad" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">400 Bad Request </span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">客户端请求错误，如参数格式错误</span><span class="ne-text" style="font-size: 16px"> </span></p><p id="u01da6c77" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">401Unauthorized 未授权（未认证），用户未提供有效身份凭证（如未登录）</span></p><p id="u348706c7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">403 Forbidden 表示服务器拒绝执行，如权限不足、IP地址被封禁或网站配置错误</span></p><p id="u7c669d05" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">404 Not Found表示请求的资源不存在</span></p><p id="u1281f000" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">5xx表示服务器处理请求出错</span></strong></p><p id="u62ae5b09" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">500 Internal Server Error表示服务器内部错误</span></p><p id="u9c1ab064" class="ne-p"><span class="ne-text" style="font-size: 16px">501 </span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">Not Implemented</span><span class="ne-text" style="font-size: 16px"> 表示服务器不支持请求方法</span></p><p id="ud6d4fd56" class="ne-p"><span class="ne-text" style="font-size: 16px">502 Bad Gateway 网关服务器无法从上游服务器获得有效的响应，如上游服务器未启动、崩溃或超时</span></p><p id="u9d2a8c68" class="ne-p"><span class="ne-text" style="font-size: 16px">504 Gateway Time-out 表示网关服务器等待上游服务器响应超时，如上游服务器处理时间过长或网络延迟</span></p></details>
<details class="lake-collapse"><summary id="u22ffcc06"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">请求类型</span></strong></summary><p id="ufb8dbe56" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">GET：用于请求获取指定资源，通常用于获取数据。</span></p><p id="u8be94280" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</span></p><p id="uae7abbf5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。</span></p><p id="u129b8728" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">DELETE：用于请求服务器删除指定资源。</span></p><p id="uc8199233" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</span></p></details>
<details class="lake-collapse"><summary id="u651b9288"><span class="ne-text" style="font-size: 16px">GET 和 POST 有什么区别</span></summary><ol class="ne-ol"><li id="uff4fb0f1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">GET是从服务器获取指定的资源，请求的参数位置一般写在URL中，参数只允许ASCII，并且浏览器(不是HTTP)对URL长度有限制。GET是安全且幂等的，是“只读”操作，可被浏览器缓存。</span></li><li id="uc11aa29e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">POST是根据请求符合(报文body)对指定数据的资源做出处理，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。POST是不安全不幂等的，是“新增/提交数据”操作，会修改服务器资源，浏览器一般不会缓存POST请求。</span></li></ol><p id="u1c9b312b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">注：理论上，任何请求都可以带 body 的，只是规范上GET不带body；并且URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</span></p></details>
<details class="lake-collapse"><summary id="u5197f0f5"><strong><span class="ne-text" style="font-size: 16px">请求报文 / 响应报文</span></strong></summary><p id="u0517f072" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求报文</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：</span></p><p id="ue2a1f426" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。</span></p><p id="uc04a938a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。</span></p><p id="u2d4aed9d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">空行：请求头部和请求体之间用空行分隔。</span></p><p id="ub18dfd04" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。</span></p><p id="ue08eade7" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">响应报文</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：</span></p><p id="u93cfb4eb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">状态行：包含HTTP协议版本、状态码和状态信息。</span></p><p id="u2468d6c7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。</span></p><p id="u9e9ed68a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">空行：响应头部和响应体之间用空行分隔。</span></p><p id="u0d83804a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容。</span></p></details>
<details class="lake-collapse"><summary id="u78017288"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">HTTP常见字段</span></strong></summary><p id="u64e4ef9d" class="ne-p"><span class="ne-text">HTTP字段（HTTP field）是出现在HTTP请求或响应头部的一组键: 值结构，用于携带额外的指令或说明，帮助服务器和客户端正确处理HTTP消息。</span></p><ul class="ne-ul"><li id="uc79425c5" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HOST：可以将请求发往「同一台」服务器上的不同网站</span></li><li id="ud7499345" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Content-Length：表明本次回应的数据长度</span></li><li id="uba6c2e44" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Connection：最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用</span></li><li id="u27918e96" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Content-Type：用于服务器回应时，告诉客户端，本次数据是什么格式</span></li><li id="u2d6c8e85" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Content-Encoding：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</span></li></ul></details>
<details class="lake-collapse"><summary id="u2cf66d7e"><strong><span class="ne-text" style="font-size: 16px">HTTP版本</span></strong></summary><ol class="ne-ol"><li id="u94245ca3" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/0.9：</span></strong><span class="ne-text" style="font-size: 16px">只有 GET 方法，无头部，响应仅为 HTML。</span></li><li id="u9cd08d33" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/1.0：</span></strong><span class="ne-text" style="font-size: 16px">引入</span><strong><span class="ne-text" style="font-size: 16px">头部</span></strong><span class="ne-text" style="font-size: 16px">（Header）、状态码、多种请求方法（POST/HEAD），支持非 HTML 内容。</span></li><li id="ue3347fca" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/1.1：持久连接</span></strong><span class="ne-text" style="font-size: 16px">（默认保持连接复用）、管道化、缓存控制（如 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">Cache-Control</span></code><span class="ne-text" style="font-size: 16px">）、 Host 头（支持虚拟主机）。</span></li><li id="u1cb42dea" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/2：多路复用</span></strong><span class="ne-text" style="font-size: 16px">（一个连接并行传输多个请求）、头部压缩、服务器推送。</span></li><li id="uae0a5753" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px">HTTP/3：</span></strong><span class="ne-text" style="font-size: 16px">基于 </span><strong><span class="ne-text" style="font-size: 16px">QUIC 协议</span></strong><span class="ne-text" style="font-size: 16px">（UDP），减少连接建立延迟，解决队头阻塞问题。</span></li></ol></details>
<details class="lake-collapse"><summary id="uee2778d2"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/1.0</span></summary><ol class="ne-ol"><li id="ua99b9873" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">响应状态码：有16 种状态码。</span></li><li id="u8abb9361" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">缓存机制：服务器在返回响应时，告诉客户端这个资源的“过期时间”或“最后修改时间”，客户端在下次需要这个资源时，可以据此判断是直接使用本地副本，还是需要向服务器重新请求。存在的问题：依赖绝对时间，控制手段单一，不可靠不灵活。</span></li><li id="u0bb48044" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">连接方式：默认短连接， 每次请求都会重新建立并关闭一次 TCP 连接，频繁的三次握手与四次挥手造成明显的带宽和性能浪费。</span></li></ol></details>
<details class="lake-collapse"><summary id="ua1f61836"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/1.1</span></summary><ol class="ne-ol"><li id="u9cee579c" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">响应状态码：新增大量的状态码，如206等。</span></li><li id="uc724cda6" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">缓存机制：引入了Cache-Control头部和ETag机制，  提供了丰富的缓存指令，支持更精确控制，使用内容哈希标识资源版本而不是时间，缓存校验更加精准高效。</span></li><li id="uf35f6ebe" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">连接方式：默认长连接，</span><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px"> 通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">Connection: keep-alive</span></code><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px"> 保持 TCP 连接在多个请求间复用，显著减少连接开销，提高传输效率。  </span></li><li id="u1834bdd9" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">新增并强制使用Host头部：1.0中服务器无法区分同一 IP 下的多个网站，强制Host头的引入实现了虚拟主机支持，使一台服务器能同时服务多个域名  </span></li><li id="uf5d70e2d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">范围请求机制： 允许客户端只获取资源的部分字节（或多段），支持断点续传与按需加载。通过Range等头部配合多种状态码协调实现</span></li></ol><hr id="vzZ7u" class="ne-hr"><ol class="ne-ol"><li id="u11887a1f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">连接方式：串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接的限制</span></li><li id="u4111f81d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">传输格式：文本格式的报文</span></li><li id="uebd3418b" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">队头阻塞：请求-响应串行模型， 同一连接中一个慢请求阻塞后续  </span></li><li id="u3bd1b3bb" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">头部压缩：支持Body压缩，不支持Header压缩， 头部大量重复  </span></li></ol></details>
<details class="lake-collapse"><summary id="u5701ee68"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/2</span></summary><ol class="ne-ol"><li id="u0a5dbe10" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">连接方式：多路复用，在同一连接上可以同时传输多个请求和响应，互不干扰</span></li><li id="u90bc033f" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">传输格式：二进制分帧，更高效、更易解析  </span></li><li id="ua7f99edb" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">队头阻塞：多路复用技术允许多个请求和响应在单个 TCP 连接上并行交错传输，解决了 HTTP/1.1 应用层的队头阻塞问题，但 HTTP/2 依然受到 TCP 层队头阻塞 的影响。</span></li><li id="ub5a38e94" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">头部压缩： 使用 HPACK 压缩头部，大幅减少冗余  </span></li><li id="u6f984c0c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">服务器推送：可以在客户端请求一个资源时，将其他相关资源一并推送，减少客户端的请求次数和延迟</span></li><li id="u12393550" data-lake-index-type="0"><span class="ne-text" style="color: rgb(60, 60, 67); font-size: 16px">安全性：实际使用中，HTTP/2 实际等同于 HTTPS，总是基于TLS加密</span></li></ol><hr id="RCHF5" class="ne-hr"><ol class="ne-ol"><li id="ua00436de" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">传输协议：基于TCP协议</span></li><li id="uc43f8c22" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">握手性能：TCP三次握手+TLS握手，至少2RTT</span></li><li id="u206363f0" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">队头阻塞：存在传输层堵头阻塞</span></li><li id="u328dce7b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">加密机制： TLS 与传输分层独立，不加密TCP头部等信息</span></li><li id="ubd70d965" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">丢包处理：依赖于TCP的全局重传，容易阻塞</span></li></ol></details>
<details class="lake-collapse"><summary id="u86a44a6c"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">HTTP/3</span></summary><ol class="ne-ol"><li id="u1425c23f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">传输协议：使用QUIC协议，在UDP基础上实现了可靠传输、多路复用、加密和连接迁移</span></li><li id="u9ef5449b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">握手性能：首次连接1次RTT，复用则0次</span></li><li id="u958bdf2a" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">队头阻塞：完全消除队头阻塞</span></li><li id="ud0339293" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">加密机制：TLS内嵌于GUIC，对整个数据包加密，更加安全</span></li><li id="uc2b92747" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">丢包处理：QUIC 局部重传，仅影响丢失的数据流  </span></li><li id="ub0f219d0" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">连接迁移：QUIC使用64位标识连接，网络环境改变也能保持连接</span></li></ol></details>
<details class="lake-collapse"><summary id="uc6d000ce"><strong><span class="ne-text"> URI 和 URL 的区别是什么</span></strong></summary><p id="u07739e64" class="ne-p"><span class="ne-text">URL是URI的一种</span></p><p id="u1e0b0f59" class="ne-p"><span class="ne-text">URI是统一资源标识符，</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">唯一标识一个资源</span></p><p id="u1b7f1cd8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">URL是统一资源定位符，指出资源访问位置和方式</span></p></details>
<details class="lake-collapse"><summary id="ubcff9f6e"><span class="ne-text"> </span><strong><span class="ne-text" style="font-size: 16px">HTTP 是不保存状态的协议, 如何保存用户状态?  </span></strong></summary><p id="u093709cd" class="ne-p"><span class="ne-text" style="font-size: 16px">HTTP是无状态协议，每次请求都是独立的，必须依靠额外机制显式传递状态信息</span></p><ol class="ne-ol"><li id="u02d610a4" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Cookie，最基础的状态存储机制， 由服务器通过响应头 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">Set-Cookie</span></code><span class="ne-text" style="font-size: 16px"> 发送给客户端，浏览器自动在后续请求中携带  </span></li><li id="uaef0d597" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Session，基于Cookie的服务器状态保存方案， 服务器在内存/数据库中保存用户状态，客户端仅保存一个 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">SessionID</span></code><span class="ne-text" style="font-size: 16px">（通常放在 Cookie 中），用来关联状态</span></li><li id="u4dd0b1ad" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">Token/JWT：无状态认证方案，适合分布式系统， 服务器签发加密 Token（如 JWT），客户端每次请求携带（通常放在 Header 的 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">Authorization</span></code><span class="ne-text" style="font-size: 16px"> 中），服务器验证后识别用户</span></li></ol></details>
<details class="lake-collapse"><summary id="ueb027d4c"><strong><span class="ne-text" style="font-size: 16px">缓存技术</span></strong></summary><p id="ud0af145b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器/中间服务器在本地保存资源副本，减少重复请求、提示加载速度、节省宽带</span></p><p id="u599ad48c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">有两种实现方式：强制缓存和协商缓存</span></p><ol class="ne-ol"><li id="ud77c25ba" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">强制缓存即HTTP/1.0的Expires绝对过期时间判断和HTTP/1.1的Cache-Control 相对过期时间和策略判断</span></li><li id="uc525c169" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">协商缓存即HTTP/1.0的 通过资源修改时间判断是否更新  和HTTP/1.1的 内容哈希标识判断是否更新  </span></li></ol><p id="u572e01cd" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">协商缓存是强制缓存的“备胎”，只有强制缓存失效时才会触发协商缓存流程。</span></p></details>
### <font style="color:rgb(51, 51, 51);">HTTPS</font>
HTTPS，即超文本传输安全协议。 是在 HTTP 协议基础上<font style="color:rgb(51, 51, 51);">通过SSL/TLS协议加密，加密层在HTTP和TCP之间。</font>

默认端口：443

<details class="lake-collapse"><summary id="u3b626525"><strong><span class="ne-text" style="font-size: 16px">HTTPS如何解决了HTTP的安全问题</span></strong></summary><p id="u3c05579c" class="ne-p"><span class="ne-text" style="font-size: 16px">首先明白HTTP的安全问题：</span></p><ol class="ne-ol"><li id="ufc4c9ef6" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">明文存储，存在窃听风险</span></li><li id="ub1bb5559" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">可以截获数据包并修改内容，存在篡改风险</span></li><li id="u1de6fd0f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">无法确认与你通信的服务器的身份，存在冒充风险</span></li></ol><p id="ue969c056" class="ne-p"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">对应的，HTTPS：</span></p><ol class="ne-ol"><li id="ue6d76fd1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 16px">混合加密，即对称加密和非对称加密，握手阶段通过</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">非对称加密交换会话密钥，通信过程全部使用对称加密加密明文数据</span></li><li id="u74746ed7" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">HMAC，是摘要算法的变种，</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">摘要算法即哈希函数</span><span class="ne-text" style="font-size: 16px">，直接发送“数据摘要+数据”可能二者都被伪造，所以HMAC发送的摘桃来源于数据和对称密钥。</span></li><li id="u49597818" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">数字证书的数字签名，通过校验收到的服务器公钥是否具有权威机构CA的证明来判断是不是伪造的</span></li></ol></details>
<details class="lake-collapse"><summary id="u8d9e0c34"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">SSL/TLS 协议</span></strong></summary><p id="u1335395a" class="ne-p"><span class="ne-text" style="font-size: 16px">TLS 是 SSL 的升级版，同一个东西的不同版本，只是SSL叫习惯了所以保留了</span></p></details>
<details class="lake-collapse"><summary id="ufeaba4ed"><span class="ne-text">握手过程</span></summary><ol class="ne-ol"><li id="u0b8ef44d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">ClientHello：客户端向服务器发起ClientHello加密通信请求，发送了客户端支持的TLS协议版本 + 客户端生产的随机数(用来生成对话密钥) + 支持的密码套件系列(加密算法)</span></li><li id="ud9ae9158" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">SeverHello：服务器做出响应，发送 确认TLS协议版本(不支持该版本就关闭加密通信) + 服务器生产的随机数(用来生成对话密钥) + 确认密码套件系列 + 服务器的数字证书</span></li><li id="u088c1f41" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">客户端回应：客户端收到回应后，先通过浏览器/操作系统的CA公钥确认数字证书真实性，随后从数字证书取出服务器公钥，生成一个随机数(pre-master  Secret )用服务器公钥加密后发送给服务器。然后客户端使用三个随机数用协商的加密算法各自生成本次通信的会话密钥，客户端发送 加密的 Finished 消息校验握手完整性  </span></li><li id="u9131ead4" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">服务端计算会话密钥，发送 加密 Finished 消息  </span></li></ol><hr id="Zv5co" class="ne-hr"><p id="uacbcc1ce" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">至此握手阶段结束，进入加密通信，完全使用HTTP协议，只不过使用会话密钥加密内容(对称加密+HMAC)。</span></p></details>
<details class="lake-collapse"><summary id="udcf92195"><span class="ne-text" style="font-size: 16px">握手为什么要使用随机数，以及为什么要三个随机数</span></summary><p id="uc10b2de5" class="ne-p"><span class="ne-text" style="font-size: 16px">使用随机数：</span></p><ol class="ne-ol"><li id="u411e9166" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">保证会话密钥唯一性，防止攻击人重放攻击或根据重复密钥推测通信内容</span></li><li id="uebbe11e2" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">增加密钥熵，提高不可预测性，保障安全</span></li></ol><p id="u3f4c202d" class="ne-p"><span class="ne-text" style="font-size: 16px">为什么要三个，只要第三个不行吗</span></p><ol class="ne-ol"><li id="u82bdf69b" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">随机性更强，并且保证向前保密</span></li><li id="u76a141a5" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">让密钥生成过程和算法协商过程解耦，更加灵活</span></li></ol></details>
<details class="lake-collapse"><summary id="u3ecb5473"><strong><span class="ne-text" style="font-size: 16px">数字证书签发和校验过程</span></strong></summary><p id="u608e70e2" class="ne-p"><span class="ne-text" style="font-size: 16px">签发：</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1，CA把持有者公钥、用途、颁发者、有效时间等信息打包成一个包，对这些信息进行HASH计算，2，CA使用私钥将该hash值加密，生成Certificate Signature，也就是数字签名，3，将 Certificate Signature 添加在文件证书上，形成数字证书。</span></p><p id="ue044d062" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">校验：1，客户端使用同样的Hash算法获取证书Hash值H1，2，通常浏览器和操作系统集成了CA公钥信息，浏览器收到证书后可以使用CA公钥解密Certificate Signature，得到哈希值H2，3，对比H1和H2，如果值相同则可信。</span></p></details>
### DNS
DNS，域名管理系统，它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。DNS 要解决的是域名和 IP 地址的映射问题。

默认端口：53

**DNS基于UDP**，但也可以使用TCP：使用UDP主要是轻量，简单，快，低延迟。也可以用TCP，比如大响应/要求可靠传输。

<details class="lake-collapse"><summary id="u38936515"><strong><span class="ne-text" style="font-size: 16px">DNS服务器</span></strong></summary><p id="u6504b1da" class="ne-p"><span class="ne-text">D</span><span class="ne-text" style="font-size: 16px">NS服务器是把域名转化成IP的域名解析服务器，还可以反向解析，缓存结果和递归查询。</span></p><ul class="ne-ul"><li id="u9d68a0ad" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">根 DNS 服务器</span><span class="ne-text" style="font-size: 16px">：提供顶级域（如 </span><code class="ne-code"><span class="ne-text" style="font-size: 16px">.com</span></code><span class="ne-text" style="font-size: 16px">、</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">.org</span></code><span class="ne-text" style="font-size: 16px">）信息</span></li><li id="u79a0837e" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">顶级域（TLD）服务器</span><span class="ne-text" style="font-size: 16px">：管理具体顶级域</span></li><li id="ucee109e6" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">权威 DNS 服务器</span><span class="ne-text" style="font-size: 16px">：存储具体域名的 IP 信息，是最终解析来源</span></li><li id="u51f9e906" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">递归 DNS 服务器：客户端请求先到这里，它负责逐级查询直到拿到 IP</span></li></ul></details>
<details class="lake-collapse"><summary id="u9ccd7d0a"><strong><span class="ne-text" style="font-size: 16px">解析过程/工作原理</span></strong></summary><ol class="ne-ol"><li id="u7eaac925" data-lake-index-type="0"><span class="ne-text">查询浏览器缓存和本地缓存，没命中则请求网络配置指定的本地DNS服务器</span></li><li id="ub26562c5" data-lake-index-type="0"><span class="ne-text">还是没有就会开始迭代查询，先查根DNS服务器，然后从返回的顶级域服务器查，再从返回的权威DNS服务器查到IP，缓存后返回给客户端</span></li></ol></details>
<details class="lake-collapse"><summary id="u17555485"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">DNS 劫持</span></strong></summary><p id="u67bc2a76" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。这种劫持可以通过植入恶意的DNS记录或劫持用户的DNS流量来实现。</span></p></details>
**其他**

<details class="lake-collapse"><summary id="ubf19f08e"><span class="ne-text" style="font-size: 16px">DNS报文格式</span></summary><p id="u42a0a01f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">DNS 报文分为查询和回答报文，两种形式的报文结构相同。</span></p><ul class="ne-ul"><li id="ub40b5a01" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">标识符。16 比特，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</span></li><li id="u57625a40" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">标志。1 比特的”查询/回答“标识位，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">0</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">表示查询报文，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">1</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">表示回答报文；1 比特的”权威的“标志位（当某 DNS 服务器是所请求名字的权威 DNS 服务器时，且是回答报文，使用”权威的“标志）；1 比特的”希望递归“标志位，显式地要求执行递归查询；1 比特的”递归可用“标志位，用于回答报文中，表示 DNS 服务器支持递归查询。</span></li><li id="u69feb430" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">问题数、回答 RR 数、权威 RR 数、附加 RR 数。分别指示了后面 4 类数据区域出现的数量。</span></li><li id="u1d96eebc" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">问题区域。包含正在被查询的主机名字，以及正被询问的问题类型。</span></li><li id="ub006ef78" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">回答区域。包含了对最初请求的名字的资源记录。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。</span></strong></li><li id="ua5f36667" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">权威区域。包含了其他权威服务器的记录。</span></li><li id="u4ee08eab" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">附加区域。包含了其他有帮助的记录。</span></li></ul></details>
### <font style="color:rgb(51, 51, 51);">WebSocket</font>
<font style="color:rgb(51, 51, 51);">WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</font>

<font style="color:rgb(51, 51, 51);">WebSocket继承了TCP 协议的全双工，并且解决了粘包的问题，因为它有明确的消息边界，每条信息都加了帧头，能让接收端准确解析完整消息。</font>

<font style="color:rgb(51, 51, 51);">使用场景：适用于需要服务器和客户端频繁交互的大部分场景</font>

<details class="lake-collapse"><summary id="u4644b523"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs HTTP</span></strong></summary><ol class="ne-ol"><li id="u13a2264f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket是状态化的</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">全双工通信模式；HTTP是无状态的请求-响应模型</span></li><li id="udf131684" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket长连接；HTTP/1.0默认短链接，HTTP/1.1默认长连接但仍然是客户端请求服务器响应</span></li><li id="uc4fc3034" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket初始为HTTP发起握手，确认后升级为 WebSocket 长连接；HTTP每次请求独立。</span></li><li id="u170795ec" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket 双方都可主动发送数据，适合</span><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 14px">高频、实时交互场景如实时聊天、在线游戏、推送通知等；</span><span class="ne-text" style="color: rgb(51, 51, 51)">HTTP  客户端必须先发起请求，适合传统网页通信</span></li></ol></details>
<details class="lake-collapse"><summary id="ufca8789c"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs 长、短轮询</span></strong></summary><p id="udd940aad" class="ne-p"><br></p></details>
<details class="lake-collapse"><summary id="uc75fe7c2"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs SSE</span></summary><p id="u170b354b" class="ne-p"><br></p></details>
<details class="lake-collapse"><summary id="u26dfa493"><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket vs Socket</span></summary><p id="u51fb2e3b" class="ne-p"><br></p></details>
<details class="lake-collapse"><summary id="u5431cced"><strong><span class="ne-text" style="font-size: 16px">工作原理</span></strong></summary><ol class="ne-ol"><li id="uc372ffe6" data-lake-index-type="0"><span class="ne-text">浏览器/客户端向服务器发送一个 HTTP 请求，其中包含特殊头部：请求升级协议为</span><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket、用于服务器生成响应校验的随机字符串、协议版本</span></li><li id="ud4ba5803" data-lake-index-type="0"><span class="ne-text"> 服务器接收到请求后，如果支持 WebSocket </span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">回复一个 HTTP 101 状态码，确认升级协议为</span><span class="ne-text" style="color: rgb(51, 51, 51)">WebSocket和版本，验证客户端的随机字符串</span></li><li id="u1da940e2" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">握手成功，可以双向发送消息</span></li></ol></details>




















