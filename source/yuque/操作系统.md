- [x] 操作系统基础
- [x] 进程和线程
- [x] 内存管理
- [x] 文件系统
- [x] 网络IO
- [ ] 其他

## 操作系统基础
<font style="color:rgb(51, 51, 51);">操作系统是管理计算机硬件和软件资源的系统程序，本质上是一个运行在计算机上的软件程序 ，它为用户和应用程序提供统一的接口和运行环境，并且为用户提供了便捷的交互方式，使计算机系统高效、稳定、可用。</font>

<details class="lake-collapse"><summary id="u898e8b48"><span class="ne-text">操作系统主要有哪些功能</span></summary><ol class="ne-ol"><li id="u97729700" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程和线程的管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</span></li><li id="u8fb31222" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">存储管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：内存和外存（磁盘等）的分配和管理等。</span></li><li id="u568491fb" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">文件管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：文件的读、写、创建及删除等。</span></li><li id="uea922ef2" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">设备管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：设备（输入输出设备和外部存储设备等）的请求或释放以及启动等。</span></li><li id="ucfc6577f" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">网络管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：管理计算机网络的配置、连接、通信和安全等。</span></li><li id="u78c88fbe" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">安全管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：用户的身份认证、访问控制、文件加密等。</span></li></ol></details>
### 内核
<font style="color:rgb(51, 51, 51);">它是操作系统的核心。它的核心职责是作为应用程序和计算机硬件之间的桥梁，管理所有系统资源，并为上层应用提供一个安全、稳定、统一的运行环境。</font>

### <font style="color:rgb(51, 51, 51);">内核态和用户态</font>
<font style="color:rgb(51, 51, 51);">内核态和用户态是操作系统中的两种运行模式。是CPU的运行状态。</font>

<font style="color:rgb(51, 51, 51);">内核态：CPU可以执行所有的指令和访问所有的硬件资源，拥有非常高的权限。主要用于操作系统内核的运行。</font>

<font style="color:rgb(51, 51, 51);">用户态：用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。主要用于运行用户程序。</font>

<details class="lake-collapse"><summary id="u3147bcfb"><strong><span class="ne-text" style="font-size: 16px">内核空间和用户空间</span></strong></summary><p id="uac41b5ed" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">在计算机系统中，内存可以分为两大区域：内核空间和用户空间。这种划分主要用于保护系统稳定性和安全性。</span></p><p id="u354122f3" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内核空间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，是操作系统内核代码及其运行时数据结构所在的内存区域，拥有对系统所有资源的完全访问权限。</span></p><p id="ud749d5db" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">⽤户空间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，是操作系统为应用程序（如用户运行的进程）分配的内存区域，用户空间中的进程不能直接访问硬件或内核数据结构，只能通过系统调用与内核通信。</span></p></details>
<details class="lake-collapse"><summary id="uf4b7b39d"><span class="ne-text" style="font-size: 16px">为什么要划分</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内核态和用户态</span></summary><p id="u85bf3694" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1，通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。</span></p><p id="u76271ef8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2，当用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃。</span></p><p id="u94d9ce20" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">3，这种划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。</span></p></details>
<details class="lake-collapse"><summary id="u28fd56e3"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内核态和用户态如何切换</span></summary><p id="u415efc01" class="ne-p"><span class="ne-text" style="font-size: 16px">用户态切换到内核态的方式有三种：</span></p><p id="u42156219" class="ne-p"><span class="ne-text" style="font-size: 16px">1，</span><span class="ne-text" style="font-size: 16px">系统调用</span><span class="ne-text" style="font-size: 16px">：指用户态主动要求切换到内核态执行某些需要特殊权限的操作，最常用、最主动的方式。</span></p><p id="ue0d760ab" class="ne-p"><span class="ne-text" style="font-size: 16px">2，</span><span class="ne-text" style="font-size: 16px">异常</span><span class="ne-text" style="font-size: 16px">：当CPU在执行用户态程序时，发生了不可预知的</span><span class="ne-text" style="font-size: 16px">异常</span><span class="ne-text" style="font-size: 16px">（如除零错误、缺页异常、非法指令），CPU会自动停止当前工作，转而去执行内核中对应的异常处理程序。</span></p><p id="ue44cae24" class="ne-p"><span class="ne-text" style="font-size: 16px">3，中断：由硬件发起(如键盘输入、网卡收到数据、磁盘IO完成)，CPU会立即暂停当前执行流程，转而去执行内核中对应的中断处理程序。</span></p><hr id="WP2pM" class="ne-hr"><p id="ucbdb2fb3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">当用户态需要切换到内核态时，会触发一个称为 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">“陷入”</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 的机制：</span></p><p id="uc01fc680" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">当触发系统调用/异常/中断，CPU会把当前用户进程的信息保存到这个进程的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内核栈</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，然后将自己的工作模式从用户态提升至内核态，然后根据预先由操作系统设置好的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">中断向量表</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，查找并确定该由哪个内核中的服务程序来处理当前事件，然后执行这个服务程序真正操作硬件或管理资源。内核程序执行完毕后，会执行一条</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">中断返回指令</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。这条指令会触发CPU将之前保存的现场信息从内核栈中恢复出来，并将CPU的工作模式从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内核态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">切换回</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，然后继续执行原来的用户进程。</span></p></details>
### 中断
<font style="color:rgb(51, 51, 51);">中断是CPU响应外部事件的一种机制，它允许CPU暂停当前正在执行的程序，转而去处理外部设备发出的紧急请求或内部CPU产生的异常事件，处理完毕后又能恢复原来程序的执行。</font>

<details class="lake-collapse"><summary id="u3e5db499"><span class="ne-text" style="font-size: 16px">外部中断 和 内部中断</span></summary><p id="u0bf2dce8" class="ne-p"><span class="ne-text">中断主要可以分为两大类：外部中断和内部中断。</span></p><p id="u0c540cfc" class="ne-p"><span class="ne-text">1，外部中断（硬件中断）</span></p><p id="u5e32758f" class="ne-p"><span class="ne-text">这类中断由</span><span class="ne-text">CPU外部的硬件设备</span><span class="ne-text">发起，通过中断信号线通知CPU。它通常是</span><span class="ne-text">异步</span><span class="ne-text">的，意味着中断请求的到来与CPU正在执行的指令无关。</span></p><ul class="ne-ul"><li id="ube3f19d7" data-lake-index-type="0"><span class="ne-text">可屏蔽中断</span><span class="ne-text">：大部分由外部I/O设备产生，如网卡接收到数据包、硬盘完成数据读写、键盘被敲击、定时器到期等。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u838213ac" data-lake-index-type="0"><span class="ne-text">特点</span><span class="ne-text">：CPU可以通过设置</span><span class="ne-text">中断屏蔽位</span><span class="ne-text">（如IF标志位）来暂时忽略这些中断请求。这用于保护重要的、不希望被打断的代码段（临界区）。</span></li></ul></ul><ul class="ne-ul"><li id="u40d806fd" data-lake-index-type="0"><span class="ne-text">不可屏蔽中断</span><span class="ne-text">：通常用于处理非常紧急的硬件故障，如电源掉电、内存校验错误等。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u5fe15f95" data-lake-index-type="0"><span class="ne-text">特点</span><span class="ne-text">：</span><span class="ne-text">CPU必须立即响应</span><span class="ne-text">，无法通过软件指令屏蔽。这是最高优先级的中断。</span></li></ul></ul><p id="u6159522f" class="ne-p"><span class="ne-text">2，内部中断（软件中断）</span></p><p id="u2255f7e1" class="ne-p"><span class="ne-text">这类中断由</span><span class="ne-text">CPU内部在执行指令时</span><span class="ne-text">根据代码执行情况自动触发，是</span><span class="ne-text">同步</span><span class="ne-text">的，即它的发生一定是由正在执行的某条指令导致的。</span></p><ul class="ne-ul"><li id="ua05bb3fe" data-lake-index-type="0"><span class="ne-text">陷阱</span><span class="ne-text">：</span><span class="ne-text">有意</span><span class="ne-text">安排的，用于实现系统功能调用或调试。执行后，CPU会记录下一条指令的地址（以便返回）。比如：应用程序调用 </span><code class="ne-code"><span class="ne-text">printf</span></code><span class="ne-text">函数，最终会通过一条类似于 </span><code class="ne-code"><span class="ne-text">int 0x80</span></code><span class="ne-text">或 </span><code class="ne-code"><span class="ne-text">syscall</span></code><span class="ne-text">的指令陷入内核，这就是一种陷阱。调试时的断点也是陷阱。</span></li><li id="ubfa62ce0" data-lake-index-type="0"><span class="ne-text">故障</span><span class="ne-text">：是一种</span><span class="ne-text">可修复</span><span class="ne-text">的错误。CPU在执行指令</span><span class="ne-text">前</span><span class="ne-text">检测到异常条件，触发中断。处理完后，CPU会</span><span class="ne-text">重新执行</span><span class="ne-text">刚才那条出错的指令。比如：</span><span class="ne-text">缺页异常</span><span class="ne-text">是最典型的故障。当访问的页面不在内存中时，CPU触发缺页中断；操作系统将页面从磁盘调入后，再让CPU重新执行那条访问内存的指令，这次就能成功了。</span></li><li id="u11585ec9" data-lake-index-type="0"><span class="ne-text">终止：处理不可修复的严重错误。CPU在执行指令后检测到致命错误，无法恢复，通常只能强制终止当前程序。比如：硬件故障、非法指令、系统数据结构被破坏（如Linux中的 Kernel Panic）。</span></li></ul></details>
<details class="lake-collapse"><summary id="u90e19d7d"><span class="ne-text" style="font-size: 16px">作用</span></summary><ol class="ne-ol"><li id="u05697071" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">最重要的作用是让 CPU 不需要轮询来检查设备状态，提高了 CPU 利用率</span></li><li id="u200d5fe1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">中断机制为异常事件提供了统一的处理入口，保障了系统的稳定性和可靠性</span></li><li id="u7033b34d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为用户程序提供安全稳定可靠的请求操作系统为其服务的方式</span></li><li id="u69fc6c1f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为高优先级的事件提供一种打断当前任务的方式，从而满足严格的实时性要求</span></li></ol></details>
## 进程和线程
<details class="lake-collapse"><summary id="u50711581"><strong><span class="ne-text" style="font-size: 16px">进程与线程</span></strong></summary><p id="ud72c062d" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是操作系统中进行资源分配和调度的基本单位，它拥有自己的独立内存空间和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。因此其稳定性和安全性相对较高，但同时上下文切换的开销也较大，因为需要保存和恢复整个进程的状态。</span></p><p id="uad7ac13f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">线程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是进程内的一个执行单元，也是CPU调度和分派的基本单位。线程共享进程的内存空间，包括堆和全局变量。线程之间通信更加高效，因为它们可以直接读写共享内存。线程的上下文切换开销较小，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此存在数据竞争和线程安全的问题，需要通过同步和互斥机制来解决。</span></p><p id="u4cbf7a61" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程与线程的关系</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：进程是容器，线程是容器中的执行单元。线程必须依附于进程存在，离开进程线程无法单独存在。</span></p></details>
<details class="lake-collapse"><summary id="u9d507f1a"><strong><span class="ne-text" style="font-size: 16px">进程切换与线程切换</span></strong></summary><p id="u47bd7d16" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程切换</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：进程切换涉及到更多的内容，包括整个进程的地址空间、全局变量、文件描述符等。因此，进程切换的开销通常比线程切换大。</span></p><p id="u3a57c594" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">线程切换</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：线程切换只涉及到线程的堆栈、寄存器和程序计数器等，不涉及进程级别的资源，因此线程切换的开销较小。</span></p><p id="u13384090" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为什么线程切换比进程切换快</span></strong></p><p id="ud2622f17" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">线程切换比进程切换快是因为线程共享同一进程的地址空间和资源，线程切换时只需切换堆栈和程序计数器等少量信息，而不需要切换地址空间，避免了进程切换时需要切换内存映射表等大量资源的开销，从而节省了时间和系统资源。</span></p></details>
<details class="lake-collapse"><summary id="udd699ccb"><span class="ne-text" style="font-size: 16px">为什么有进程了还要有线程？</span></summary><p id="u82b82b58" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为了提高效率和改善程序结构。</span></p><p id="ue7957624" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1，线程创建和切换开销更小。</span></p><p id="u2d8e6772" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2，线程的通信和数据共享更简单，而进程间通信需要借助管道、消息队列等复杂机制，速度慢且麻烦。</span></p><p id="uaaa34681" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">3，多线程程序可以同时被调度到多个CPU核心上并行执行，从而更好地利用多核CPU。</span></p></details>
### 进程
<details class="lake-collapse"><summary id="u41fdadbc"><strong><span class="ne-text" style="font-size: 16px">进程有哪些状态</span></strong></summary><ol class="ne-ol"><li id="uf8ff3503" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">就绪（Ready）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程已具备运行条件，正在等待被 CPU 调度执行。</span></li><li id="u842402d0" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">运行（Running）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程正在使用 CPU 执行指令，是唯一处于执行状态的进程（在单核系统中）。</span></li><li id="u8635f1cd" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">阻塞（Blocked）/等待（Waiting）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程因等待某些事件（如 I/O 完成、资源可用）而暂停执行，即使有 CPU 也不能运行。</span></li><li id="u67190dff" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">新建（New）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程正在被创建，尚未进入就绪队列。</span></li><li id="u7791bc0d" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">结束（Terminated）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程已完成执行或被强制终止，正在释放资源。</span></li></ol></details>
<details class="lake-collapse"><summary id="u254ce1c0"><strong><span class="ne-text" style="font-size: 16px">进程上下文</span></strong></summary><p id="u9740733a" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程上下文</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是进程在执行过程中某一时刻的状态的快照。它包含了操作系统为了能够</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">暂停当前进程并在之后准确地恢复它</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">所需要的所有信息。</span></p><p id="u452784a1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">它主要包含两大部分信息：</span></p><ol class="ne-ol"><li id="u204cd506" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">CPU现场</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：当时CPU各个寄存器的值（如程序计数器、栈指针等），这记录了进程执行到哪一步了。</span></li><li id="uae2b8c0c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程信息</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：进程状态、内存管理信息（如页表）、打开的文件等资源清单。</span></li></ol><p id="u957f5066" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">上下文切换的过程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">就是保存当前进程的CPU状态到其PCB，切换内存空间，再从下一个进程的PCB中恢复其状态到CPU的过程。</span></p></details>
<details class="lake-collapse"><summary id="u60b91ea5"><strong><span class="ne-text" style="font-size: 16px">进程间通信方式</span></strong></summary><p id="u7e3e84d4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程间通信（IPC）是指不同进程之间交换数据的机制。</span></p><p id="u06d39282" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">首先，最经典的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">管道</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。它分为两种：</span></p><p id="uc15030e3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">匿名管道</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：这是一种单向通信 channel，只能在具有亲缘关系（如父子进程）的进程间使用。它的底层实现是内存中的一个缓冲区，数据遵循先进先出的原则。</span></p><p id="uaf1c6c3a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">命名管道</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：它解决了匿名管道亲缘关系的限制，通过一个文件系统中的命名管道文件，可以让任何无关的进程找到并进行通信。</span></p><p id="u219177e3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">第二，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">消息队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。它是由操作系统内核维护的一个消息链表。进程可以向队列中写入或读取特定格式和优先级的消息。与管道相比，它的优势在于可以按消息类型读取，而不必须是严格的先进先出，并且通信过程是异步的。</span></p><p id="u8532a7ac" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">第三，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">共享内存</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。这是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最快</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">的一种IPC方式。它让多个进程将同一块物理内存映射到它们各自的虚拟地址空间中。这样，一个进程写入共享内存的数据，另一个进程立刻就能看到，省去了内核在中间拷贝数据的过程。但正因为这种直接的共享，通常需要配合</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">信号量</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">或</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">互斥锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">等同步机制来避免数据竞争。</span></p><p id="u5a6c8511" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">第四，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">信号量</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。它本质上是一个计数器，主要用于进程间的同步与互斥，用来控制多个进程对共享资源的访问，避免出现竞态条件。它支持P（等待）和V（发送）两种原子操作。</span></p><p id="u1c08b2e0" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最后，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Socket</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。它最初是为网络通信设计的，但也可以用于同一台主机上的进程间通信。它功能强大，可以支持不同机器上的进程通信，是分布式系统的基础。</span></p><p id="u4fdc0e98" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">总结， 如果需要高性能且能处理同步问题，首选</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">共享内存</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">；如果只是简单的数据流传输，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">管道</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">就足够；而</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Socket</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">则提供了最广泛的跨机通信能力。</span></p></details>
<details class="lake-collapse"><summary id="uc004ff5a"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">进程的调度算法</span></strong></summary><p id="u05cf9680" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程调度算法是操作系统决定哪个进程获得 CPU 执行权的策略。</span></p><p id="ua84100eb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">首先，是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">先来先服务调度算法</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。顾名思义按照进程到达就绪队列的先后顺序进行调度。这是一种非抢占式的算法，实现简单且公平。但它的主要缺点是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">不利于短作业</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，因为如果一个长作业先到达，后面的短作业就需要等待很长时间，从而导致平均等待时间较长。</span></p><p id="ufe352bf9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为了解决短作业等待时间长的问题，引入了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">短作业优先调度算法</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。它会优先选择预计运行时间最短的进程来执行。这个算法可以</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最小化平均等待时间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，理论上是非抢占式算法中最优的。但它有一个明显的缺点：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">可能导致长进程饥饿</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，如果一直有短进程到达，长进程可能永远得不到执行。同时，它严重依赖于进程运行时间的准确性预测，而这在实际中是很难精确做到的。</span></p><p id="uaa0692e3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为了平衡长短作业，并保证每个进程都能获得一定的CPU时间，引入了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">时间片轮转调度算法</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。这是为分时系统设计的、最经典的一种</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">抢占式</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">算法。系统会为每个进程分配一个固定的时间片。当一个进程的时间片用完后，它会被剥夺CPU并重新放回就绪队列的末尾，然后调度下一个进程。这种方式保证了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">公平性和响应性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，但时间片大小的设置是关键：太小会导致频繁的上下文切换，开销过大；太大又会退化成先来先服务，影响响应速度。</span></p><p id="ub5f0423d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">接下来是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最高优先级调度算法</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。它会选择优先级最高的进程优先执行。优先级可以静态指定，也可以动态调整。为了防止高优先级进程导致低优先级进程饥饿，通常可以结合</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">老化</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">技术，即随着低优先级进程等待时间的增加，逐步提高其优先级。这个算法的核心挑战在于如何公平合理地确定和调整优先级。</span></p><p id="uf93365b6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最后，是结合了上述多种算法思想的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">多级反馈队列调度算法</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。这被认为是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最通用、最综合</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">的一种算法，许多现代操作系统都以其为原型。它的核心设计是设立多个不同优先级的多级队列，每个队列拥有不同的时间片大小。新进程会先进入最高优先级的队列，如果它在一个时间片内没有执行完，就会被降级到下一个队列。下级队列的优先级更低，但分配的时间片更长。这样既能优先处理短作业（能在高优先级队列快速完成），又不会完全饿死长作业（最终会在低优先级大时间片的队列中得到执行）。</span></p></details>
<details class="lake-collapse"><summary id="u035c8bc4"><strong><span class="ne-text" style="font-size: 16px">僵尸进程 和 孤儿进程</span></strong></summary><p id="u9eac5e56" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">僵尸进程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">“死而不葬”</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> ，父进程还活着但失职，没有为其收尸（回收资源）。</span></p><p id="u74877345" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">具体指的是一个进程已经终止，但是其父进程尚未调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">waitpid()</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">系统调用来回收它，那么这个已死的子进程就成为了一个僵尸进程。</span></p><p id="u0083501b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">它几乎已经放弃所有内存空间，但是在内核的进程表中保留一个退出状态的条目，等待父进程读取。如果父进程一直不回收，僵尸进程的条目就会一直占用着进程号等系统资源。系统中存在少量僵尸进程影响不大，但如果大量产生且得不到清理，就会耗尽可用的进程号，导致系统无法创建新的进程。</span></p><p id="u5dae5549" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">如何避免</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：父进程应通过调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">系列函数来主动回收子进程，或者可以捕获 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">SIGCHLD</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">信号并在信号处理函数中进行异步回收。</span></p><hr id="Q0tbn" class="ne-hr"><p id="ua16181e0" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">孤儿进程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">“父死子活”</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> ，父进程先死了，但操作系统（init进程）会负责抚养它，并在它死后为其收尸，因此它本身不会造成问题。</span></p><p id="u130347c7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">具体指的是一个子进程的父进程先于它终止了，那么这个子进程就成为了一个孤儿进程。</span></p><p id="ub963c41e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">为了解决孤儿进程无人回收的问题，操作系统有一个内置机制：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">init进程（PID为1的进程）会自动成为所有孤儿进程的新父进程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。init进程会定期调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">来回收这些孤儿进程的退出状态。因此，孤儿进程在结束后会被init进程自动清理，不会变成僵尸进程。</span></p></details>
### 线程
<details class="lake-collapse"><summary id="ub27aff53"><strong><span class="ne-text" style="font-size: 16px">线程上下文，切换过程</span></strong></summary><p id="u6ccaabd0" class="ne-p"><span class="ne-text" style="font-size: 16px">当发生线程主动让出CPU、时间片耗尽或线程调用阻塞类型的系统中断的时候就会发送线程切换，即上下文切换。</span></p><p id="u23519eea" class="ne-p"><span class="ne-text" style="font-size: 16px">切换过程：</span></p><ol class="ne-ol"><li id="u480fb1ac" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">上下文保存：当操作系统决定切换线程的时候，首先保存当前线程的上下文，上下文信息包括寄存器状态、程序计数器、堆栈指针等，用于保存线程的执行状态。保存的位置一般是TCB。</span></li><li id="uf59810aa" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">切换到调度器：操作系统将执行权切换到调度器。调度器负责选择下一个要执行的线程，并根据调度算法做出决策。</span></li><li id="u489f11b8" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">上下文恢复</span><span class="ne-text" style="font-size: 16px">：调度器选择了下一个要执行的线程后，它会从该线程保存的上下文信息中恢复线程的执行状态。</span></li><li id="u84a711b1" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">切换到新线程：调度器将执行权切换到新线程，使其开始执行。</span></li></ol></details>
<details class="lake-collapse"><summary id="ufb7287b6"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程间同步方式</span></strong></summary><ol class="ne-ol"><li id="ubf7528de" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">互斥锁(Mutex)</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 关键词和各种 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">Lock</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 都是这种机制。</span></li><li id="u06e08eb1" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">读写锁（Read-Write Lock）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> ：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</span></li><li id="ud46974e5" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">信号量(Semaphore)</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</span></li><li id="ufcbcb15e" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">屏障（Barrier）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">CyclicBarrier</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 是这种机制。</span></li><li id="u86d6a2ac" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">事件(Event)</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</span></li></ol></details>
### 死锁
<details class="lake-collapse"><summary id="u22c29d74"><strong><span class="ne-text" style="font-size: 16px">死锁是什么？产生条件？</span></strong></summary><p id="uf47016d8" class="ne-p"><span class="ne-text" style="font-size: 16px">死锁（Deadlock） 是指两个或多个线程在执行过程中，因争夺资源而导致相互等待对方释放资源，从而使得所有线程都无法继续执行的情况。</span></p><p id="u5db854e6" class="ne-p"><span class="ne-text" style="font-size: 16px">死锁的四个必要条件</span><span class="ne-text" style="font-size: 16px">：</span></p><ol class="ne-ol"><li id="u1d7e850d" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">互斥</span><span class="ne-text" style="font-size: 16px">：至少有一个资源是处于</span><span class="ne-text" style="font-size: 16px">独占模式</span><span class="ne-text" style="font-size: 16px">的，即某一时刻只能有一个线程使用该资源。</span></li><li id="u66f0a42e" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">持有并等待</span><span class="ne-text" style="font-size: 16px">：一个线程已经持有了至少一个资源，但又在等待其他线程持有的资源。</span></li><li id="ud1a8889f" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">非抢占</span><span class="ne-text" style="font-size: 16px">：资源不能被强制抢占，只有线程自己释放资源。</span></li><li id="u8c6487c1" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">循环等待：一组线程之间存在一种“环形等待”关系，即线程A等待线程B持有的资源，线程B又在等待线程A持有的资源。</span></li></ol></details>
<details class="lake-collapse"><summary id="u8038c105"><strong><span class="ne-text" style="font-size: 16px">如何避免</span></strong></summary><ul class="ne-ul"><li id="uc697919b" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">固定加锁顺序</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：确保所有线程获取资源的顺序一致，避免循环等待。</span></li><li id="u3ca5f964" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">一次性申请所有资源</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：避免线程在持有部分资源后再去申请其他资源。</span></li><li id="u03fb226b" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">加锁时限（tryLock）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">ReentrantLock.tryLock()</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px"> 等方式设置超时时间，如果获取不到锁就放弃，避免无限等待。</span></li></ul></details>
```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```

## 内存管理
<font style="color:rgb(51, 51, 51);">内存管理是操作系统负责分配、回收和保护内存资源的一项核心功能，确保多个进程在使用内存时高效且互不干扰。</font>

<details class="lake-collapse"><summary id="ubf330e91"><strong><span class="ne-text" style="font-size: 16px">职责/作用</span></strong></summary><ol class="ne-ol"><li id="u62d485ea" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">地址空间管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：为每个进程分配独立的虚拟地址空间，并映射到物理内存，保障安全隔离。</span></li><li id="u7b631a60" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内存分配与回收</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：按需为进程分配内存，在进程结束或释放时及时回收。</span></li><li id="u3d0b75d5" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内存保护</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：防止进程非法访问不属于自己的内存区域。</span></li><li id="u45b04c1a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">换页/置换管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：当物理内存不足时，将不活跃数据暂存到磁盘（如交换空间），实现虚拟内存扩展。</span></li><li id="u10bfe5e3" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内存共享和重定位</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：支持多个进程共享公共代码段，提高效率。</span></li></ol></details>
<details class="lake-collapse"><summary id="ubf11cdda"><strong><span class="ne-text" style="font-size: 16px">虚拟内存</span></strong></summary><p id="ubf1475f5" class="ne-p"><span class="ne-text">是操作系统提供的一种内存管理技术，它的主要目的是为每个进程提供一个巨大、统一且安全的虚拟地址空间。</span></p><p id="u2a7198e6" class="ne-p"><span class="ne-text">核心思想是：将进程的虚拟地址空间与实际的物理内存分离开来。</span></p></details>
<details class="lake-collapse"><summary id="uacb751e9"><span class="ne-text" style="font-size: 16px">虚拟内存的实现技术</span></summary><p id="u6c1eca93" class="ne-p"><span class="ne-text">虚拟内存实现技术：</span></p><p id="ub5d96249" class="ne-p"><span class="ne-text">1，分页机制：分页，分段，内存碎片</span></p><p id="u42e316e2" class="ne-p"><span class="ne-text">2，按需调页：多级分页、快表</span></p><p id="u2a689e35" class="ne-p"><span class="ne-text">3，页面置换：换页机制、缺页中断、交换空间、常见的页面置换算法</span></p><hr id="s01Yu" class="ne-hr"><p id="u8630731c" class="ne-p"><span class="ne-text">它通过以下三个主要技术来实现：</span></p><ol class="ne-ol"><li id="uff64698d" data-lake-index-type="0"><span class="ne-text">分页机制</span><span class="ne-text">：操作系统将进程的虚拟地址空间和物理内存都划分成固定大小的块（页和页框）。通过页表这个数据结构，来建立虚拟页到物理页框的映射关系。当一个进程访问它的虚拟内存时，由内存管理单元（MMU）和操作系统共同协作，通过查询页表来完成地址转换，找到实际的物理内存位置。</span></li><li id="uc6241c68" data-lake-index-type="0"><span class="ne-text">按需调页</span><span class="ne-text">：这是虚拟内存高效工作的关键。进程开始执行时，并不会将其所有代码和数据都加载到物理内存中，而只是加载一小部分必要的页（如启动代码）。当进程尝试访问一个尚未加载到内存的页面时，会触发一个</span><span class="ne-text">缺页中断</span><span class="ne-text">。此时，操作系统的中断处理程序会被调用，负责从磁盘上将该页面</span><span class="ne-text">换入</span><span class="ne-text">物理内存，然后更新页表，最后再让进程继续执行刚才的访问指令。这个过程对应用程序是完全透明的。</span></li><li id="ubdaea797" data-lake-index-type="0"><span class="ne-text">页面置换：物理内存是有限的，当需要为新的页面腾出空间时，操作系统会使用特定的页面置换算法（如经典的LRU-最近最少使用算法）来选择“牺牲”一个旧的页面。如果这个旧页面被修改过（称为脏页），则需要先把它换出到磁盘上的交换空间，然后再将新的页面换入。</span></li></ol></details>
<details class="lake-collapse"><summary id="u88116525"><span class="ne-text" style="font-size: 16px">缺页中断--&gt;换页机制</span></summary><p id="u607dc10b" class="ne-p"><span class="ne-text" style="font-size: 16px">缺页中断</span><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是一个由硬件自动检测并发起的信号，是CPU通知操作系统“所需资源不在位”，是换页机制的触发者。</span></p><div class="ne-quote"><p id="ud8ad9bfd" class="ne-p"><span class="ne-text" style="font-size: 16px">换页机制的</span><span class="ne-text">工作流程可以用一个图书馆的比喻来理解：</span></p><p id="u6cfbc973" class="ne-p"><span class="ne-text">1，初始状态：图书馆的书架（物理内存）空间有限，上面只存放着最热门的一些书籍（活跃内存页）。而绝大部分书籍都存放在后方的大仓库（硬盘/交换空间）里。</span></p><p id="u150b9977" class="ne-p"><span class="ne-text">2，</span><span class="ne-text">触发请求</span><span class="ne-text">：当您想借阅一本书时，会先去书架上查找。如果能直接找到（</span><span class="ne-text">内存命中</span><span class="ne-text">），就可以立即阅读，速度非常快。</span></p><p id="u3683f268" class="ne-p"><span class="ne-text">3，</span><span class="ne-text">处理缺货</span><span class="ne-text">：如果您发现书不在书架上（</span><span class="ne-text">缺页</span><span class="ne-text">），您会向管理员登记（</span><span class="ne-text">触发缺页中断</span><span class="ne-text">）。管理员（</span><span class="ne-text">操作系统</span><span class="ne-text">）会启动处理流程：他需要去仓库取书，但如果书架已满，他必须依据一套规则（</span><span class="ne-text">页面置换算法</span><span class="ne-text">，如“最近最少使用”）先决定将哪本书移回仓库（</span><span class="ne-text">换出</span><span class="ne-text">），以腾出空位。</span></p><p id="u07a95b2f" class="ne-p"><span class="ne-text">4，完成调配：管理员将新书从仓库取出放到书架上（换入），并更新图书目录（更新页表）。至此，您需要的书就触手可及了，借阅流程得以继续。</span></p></div><p id="u524ddde7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">换页机制是实现虚拟内存的核心技术。它的核心思想是：并非将进程的所有页面都装入内存才能运行，而是允许进程的页在内存和磁盘之间动态地换入换出。</span></p><p id="u33534d49" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">优势：</span></p><ul class="ne-ul"><li id="u6669ecfa" data-lake-index-type="0"><span class="ne-text">内存超载：它使得应用程序可以运行在比实际物理内存大得多的虚拟地址空间上。</span></li><li id="u36123a98" data-lake-index-type="0"><span class="ne-text">高效利用内存</span><span class="ne-text">：物理内存中只保留活跃的页面，避免了闲置数据长期占用宝贵的内存资源。</span></li><li id="u58d55d39" data-lake-index-type="0"><span class="ne-text">简化编程与内存管理：为程序员提供了巨大的、连续且统一的地址空间，无需手动管理数据的覆盖和交换。</span></li></ul></details>
<details class="lake-collapse"><summary id="u8f8fcc1d"><span class="ne-text" style="color: rgb(51, 51, 51)">常见的页面置换算法</span></summary><p id="udfd3cd3f" class="ne-p"><span class="ne-text">常见的页面置换算法主要有以下四种：</span></p><p id="uaa8db614" class="ne-p"><span class="ne-text">首先，是最简单的</span><strong><span class="ne-text">理想置换算法</span></strong><span class="ne-text">。这是一种理论上的算法，无法实际实现。它的策略是选择在未来最长时间内不再被访问的页面进行淘汰。虽然无法实现，但它为衡量其他算法的效率提供了一个最优 benchmark，可以用来判断其他算法的好坏。</span></p><p id="u42216aa1" class="ne-p"><span class="ne-text">第二，是</span><strong><span class="ne-text">先进先出算法</span></strong><span class="ne-text">。它的策略是选择最早调入内存的页面进行淘汰。实现非常简单，只需要维护一个队列。但它固有的缺点是：可能会淘汰掉一些虽然较早进入但仍在被频繁访问的页面（比如一个初始化后一直使用的核心库），而且会出现一种反常现象，即分配更多的页框给进程，有时反而会导致缺页率上升。</span></p><p id="u309ddf4f" class="ne-p"><span class="ne-text">第三，是</span><strong><span class="ne-text">最近最久未使用算法</span></strong><span class="ne-text">。这是最著名且高效的算法之一。它的策略是选择最长时间没有被访问的页面进行淘汰。LRU 算法的理念符合程序的局部性原理，性能接近理想算法，效果非常好。但它的挑战在于实现开销较大。为了实现它，需要在每次访问内存时都更新数据结构（如链表或栈），或者借助硬件的“访问位”来近似实现，这带来了不小的开销。</span></p><p id="u47b2107c" class="ne-p"><span class="ne-text">正因为 LRU 的实现开销大，实践中产生了它的一个近似算法，称为</span><strong><span class="ne-text">时钟算法</span></strong><span class="ne-text">。时钟算法是 LRU 和 FIFO 的一个折衷。它维护一个类似钟面的环形链表，并利用页表项中的“访问位”。当需要置换时，指针顺时针扫描，如果遇到访问位为 1 的页面，就将其置为 0 并跳过；如果遇到访问位为 0 的页面，就选择它进行置换。这个过程就像时钟的指针在循环扫描。它在保持了接近 LRU 性能的同时，大大降低了实现的开销。</span></p><p id="ub44b6ef9" class="ne-p"><span class="ne-text">总结来说， 选择哪种算法是一种权衡：OPT 是理想标杆，FIFO 简单但性能不佳，LRU 性能优异但实现复杂，而时钟算法则是实践中在性能和开销之间一个非常好的平衡选择。</span></p></details>
<details class="lake-collapse"><summary id="u22bfd76b"><span class="ne-text" style="font-size: 16px">虚拟内存有什么好处</span></summary><p id="u03517645" class="ne-p"><span class="ne-text">1，内存保护：每个进程拥有独立的虚拟地址空间，一个进程无法直接访问另一个进程的内存，这极大地提升了系统的安全性和稳定性。</span></p><p id="u976d6c45" class="ne-p"><span class="ne-text">2，</span><span class="ne-text">简化编程</span><span class="ne-text">：程序员无需关心物理内存的具体布局和限制，只需在统一的、巨大的虚拟地址空间中进行编程。</span></p><p id="uae351ddc" class="ne-p"><span class="ne-text">3，高效利用物理内存：通过按需调页和页面置换，使得物理内存中只保留活跃的页面，从而可以运行比实际物理内存大得多的程序，实现了“小内存跑大程序”的效果。</span></p></details>
<details class="lake-collapse"><summary id="u44432e2c"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内存分页与页表</span></strong></summary><div class="ne-quote"><p id="u26f099ad" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119); font-size: 16px">分页就像集装箱仓库，仓库是页框，大小固定的集装箱是页，页表是映射关系。优点是可以轻松找到任何空位放入新集装箱，或者调换集装箱的位置，几乎不会产生“空货架”（外部碎片）。缺点是破坏了逻辑结构，比如说一段代码分散在几个不同的集装箱。</span></p></div><p id="u0e8ed54e" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内存分页</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是一种内存管理方案。它将</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进程的虚拟地址空间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">划分为一系列固定大小的块，称为</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">页</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。同时，将</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">物理内存</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">也划分为同样大小的块，称为</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">页框</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。</span></p><p id="ud67ea35f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">页表</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">是实现上述分页映射的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">关键数据结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，页表的每个条目记录了一个虚拟页号到物理页框号的映射关系，以及一些控制位。</span></p><p id="u7a513410" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">地址转换过程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：当进程访问一个虚拟地址时，CPU中的内存管理单元（MMU）会：</span></p><ol class="ne-ol"><li id="ucefc6211" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">将虚拟地址拆解为</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">虚拟页号</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">和</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">页内偏移量</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。</span></li><li id="uca30b7ff" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">以虚拟页号为索引，去查询当前进程的页表，找到对应的页表项。</span></li><li id="u9d1f7302" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">从页表项中取出</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">物理页框号</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。</span></li><li id="uf52c9c58" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">将</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">物理页框号</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">和原始的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">页内偏移量</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">组合起来，得到最终的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">物理地址</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，从而完成访问。</span></li></ol><p id="u94b943f7" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">优势：</span></strong></p><ol class="ne-ol"><li id="u9a83bd01" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内存保护</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：每个进程有独立的页表，无法访问其他进程的物理内存。</span></li><li id="u1b3bb4c9" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">简化管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：消除了外部碎片，物理内存得以高效利用。</span></li><li id="u0d45f436" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">实现虚拟内存</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：通过“存在位”和缺页中断，可以将暂时不用的页面换出到磁盘，使得进程可以运行在比实际物理内存大得多的虚拟地址空间上。</span></li></ol></details>
<details class="lake-collapse"><summary id="ub22edc15"><span class="ne-text" style="font-size: 16px">多级分页 和 快表 TLB</span></summary><div class="ne-quote"><p id="u4364d8e5" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119); font-size: 16px">举例：学校里面，每个学生都有一页个人信息表放在档案室，单级分页是拿着全部学生的档案表查找，占用很大空间，并且很多学生已经毕业（内存未被使用），他们的记录也依然占着位置。多级分页是把学生根据年级划分，我需要大一的信息，我就去大一的档案室找，而不需要在意其他年级的档案。如果某个年级没有学生也不需要分配档案柜。核心思想在于“节省空间”和“按需分配”。</span></p></div><p id="u6ac7c157" class="ne-p"><span class="ne-text" style="font-size: 16px">多级页表是一种为了解决单级页表空间开销过大问题而设计的优化方案。</span></p><p id="u7b29fd92" class="ne-p"><span class="ne-text" style="font-size: 16px">它的核心思想是</span><span class="ne-text" style="font-size: 16px">按需分配</span><span class="ne-text" style="font-size: 16px">，通过引入页目录进行间接寻址，从而避免为整个虚拟地址空间创建完整的映射表。</span></p><p id="ub7a367d7" class="ne-p"><span class="ne-text" style="font-size: 16px">本质上是时间换空间。</span></p><p id="u5564cb59" class="ne-p"><span class="ne-text" style="font-size: 16px">优势：</span></p><p id="uad3d2326" class="ne-p"><span class="ne-text" style="font-size: 16px">1，</span><span class="ne-text" style="font-size: 16px">大幅节省内存</span><span class="ne-text" style="font-size: 16px">：这是最主要的目的。如果一个页表对应的整个虚拟地址区间都未被使用，那么只需在页目录中做一个“无效”标记，而根本不用分配整个页表所需的内存。这使得页表的内存开销与进程实际使用的虚拟内存大小成正比，而不是与整个虚拟地址空间的大小成正比。</span></p><p id="ud3539f8d" class="ne-p"><span class="ne-text" style="font-size: 16px">2，</span><span class="ne-text" style="font-size: 16px">便于管理</span><span class="ne-text" style="font-size: 16px">：页目录和页表本身也可以被分页，方便操作系统进行内存管理。</span></p><p id="ucaf22ac6" class="ne-p"><span class="ne-text" style="font-size: 16px">缺点：</span></p><p id="u189d298e" class="ne-p"><span class="ne-text" style="font-size: 16px">时间开销增加：一次地址转换需要多次访问内存（访问N级页表就需要N+1次内存访问），降低了转换速度。这个缺点通常通过TLB（快表） 来极大地缓解。</span></p><hr id="zmrmq" class="ne-hr"><p id="uca268ba4" class="ne-p"><span class="ne-text" style="font-size: 16px">快表 TLB，它是一种专门用于加速虚拟地址到物理地址转换的硬件缓存，设计思想有点像 JIT(即时编译)，本质就是内存管理单元内部的一块高速缓存缓存最近最常使用的页表项。</span></p></details>
<details class="lake-collapse"><summary id="u346fde6b"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内存分段与段表</span></strong></summary><div class="ne-quote"><p id="u498dd295" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119); font-size: 16px">分段像逻辑货架仓库，仓库有不同型号大小不一的货架，比如“代码货架”、“数据货架”、“堆货架”、“栈货架”。优点是逻辑清晰，“xx货架存xx”，缺点是会产生空货架，小空间放不进大货架。</span></p></div><p id="u4f0468c5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内存分段和段表是一种与分页不同的内存管理方案，它更侧重于反映程序的逻辑结构。</span></p><p id="u0faa0c97" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">其核心思想是：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">将一个程序的地址空间划分为若干个逻辑段</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，每个段代表一个具有特定意义的连续内存区域，例如代码段、数据段、堆段、栈段等。</span></p><p id="ua26b8bbc" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">功能</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：每个进程都有一个段表，它就像是这个进程的“分段地图”。段表中的每一个条目（段描述符）都记录了一个逻辑段的详细信息，主要包括：</span></p><ol class="ne-ol"><li id="u7caf8edc" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">段基址</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：该段在物理内存中的起始地址。</span></li><li id="u2128fdd7" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">段限长</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：该段的最大长度，用于进行越界检查，保护内存安全。</span></li></ol><p id="u7e498ceb" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">地址转换过程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：当CPU执行一条指令，访问一个逻辑地址（在分段中通常表示为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">&lt;段号, 段内偏移量&gt;</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">）时，会触发以下流程：</span></p><ol class="ne-ol"><li id="u6eb09f33" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">以指令中提供的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">段号</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">作为索引，去查找当前进程的段表，找到对应的段表项。</span></li><li id="u821e2b1e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">将指令中提供的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">段内偏移量</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">与段表项中的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">段限长</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">进行比较。如果偏移量大于限长，则说明是一次非法访问，会触发一个段错误异常，从而实现了内存保护。</span></li><li id="uffa19535" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">若检查通过，则将</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">段基址</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">与</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">段内偏移量</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">相加，得到最终的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">物理地址</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。</span></li></ol><p id="u92528f1c" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">优势：</span></strong></p><ol class="ne-ol"><li id="u189002ad" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">符合程序逻辑</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：它天然地反映了程序员和编译器的视角，便于实现代码和数据的共享与保护。例如，可以将代码段设置为只读并在多个进程间共享。</span></li><li id="ua0dddeb3" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">强大的内存保护</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：每个段都有自己的权限（读、写、执行）和长度限制，任何越界或越权的访问都会被硬件立即检查并阻止。</span></li></ol><p id="u69064b79" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">缺点：</span></strong></p><p id="u6635924e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">由于段的长度各不相同，并且在内存中不断被分配和回收，会在物理内存中产生大量不连续的小空闲区。也就是我们常说的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">外部碎片</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。</span></p></details>
<details class="lake-collapse"><summary id="u2cc54139"><span class="ne-text" style="font-size: 16px">内存碎片</span></summary><p id="ue91542a5" class="ne-p"><span class="ne-text">内存碎片是指由于频繁的内存分配与释放，导致内存空间被分割成很多无法有效利用的小块区域，从而降低了内存使用效率。</span></p><p id="u8760833c" class="ne-p"><span class="ne-text">根据位置不同，内存碎片分为两类：</span></p><ol class="ne-ol"><li id="uc56d9514" data-lake-index-type="0"><span class="ne-text">外部碎片</span><span class="ne-text">：指空闲内存被分散在不连续的区域中，虽然总空闲内存足够，但没有一块足够大的连续区域供分配。例如，有 100KB 空闲，但被分成多个 1~5KB 的小块，无法满足一个 30KB 的请求。</span></li><li id="u9d60e14b" data-lake-index-type="0"><span class="ne-text">内部碎片</span><span class="ne-text">：指实际分配给进程的内存大于其实际需要，未被使用的部分形成浪费。例如，申请 18 字节但系统按 32 字节对齐分配，剩余 14 字节就是内部碎片。</span></li></ol><p id="uae8f42a8" class="ne-p"><span class="ne-text">产生原因</span></p><p id="u8f762bdb" class="ne-p"><span class="ne-text">主要是由于动态内存分配机制（如 malloc/free），以及不同大小内存块频繁申请与释放，导致内存空间不再连续。</span></p><p id="u5a75ed28" class="ne-p"><span class="ne-text">解决方式</span></p><p id="u98495f9c" class="ne-p"><span class="ne-text">1，内存池（对象池）管理，避免频繁分配；</span></p><p id="u85bb9c9e" class="ne-p"><span class="ne-text">2，紧凑整理（如标记-整理算法）；</span></p><p id="u93c91e74" class="ne-p"><span class="ne-text">3，使用分页或分段机制，减少对连续内存的依赖。</span></p></details>
<details class="lake-collapse"><summary id="u73647a23"><span class="ne-text" style="font-size: 16px">交换空间</span></summary><p id="ubb19bf80" class="ne-p"><span class="ne-text">它是操作系统在硬盘上预留的一块特殊区域。它的核心作用是扩展物理内存，充当内存的“溢出缓冲区”或“后备仓库”，是虚拟内存系统得以实现的物理基础。</span></p></details>
<details class="lake-collapse"><summary id="u21bf44c5"><strong><span class="ne-text" style="font-size: 16px">共享内存</span></strong></summary><p id="u296d6322" class="ne-p"><span class="ne-text">共享内存是允许两个或多个进程直接读写同一块物理内存区域的IPC（进程间通信）方式。它是最快的一种IPC机制，因为数据不需要在内核和用户空间之间来回拷贝。</span></p><p id="u8f7b32be" class="ne-p"><span class="ne-text">优点</span><span class="ne-text">：</span></p><ul class="ne-ul"><li id="u1f592d73" data-lake-index-type="0"><span class="ne-text">极速</span><span class="ne-text">：避免了数据拷贝，是最快的IPC。</span></li><li id="u7f4218a1" data-lake-index-type="0"><span class="ne-text">自然</span><span class="ne-text">：使用方式与操作普通内存无异，非常方便。</span></li></ul><p id="u9cc2cc53" class="ne-p"><span class="ne-text">缺点与挑战</span><span class="ne-text">：</span></p><ul class="ne-ul"><li id="uc22f874a" data-lake-index-type="0"><span class="ne-text">需要同步</span><span class="ne-text">：这是共享内存最大的挑战。多个进程同时读写同一块内存会导致</span><span class="ne-text">竞态条件</span><span class="ne-text">。必须使用</span><span class="ne-text">同步机制</span><span class="ne-text">（如</span><span class="ne-text">信号量</span><span class="ne-text">、</span><span class="ne-text">互斥锁</span><span class="ne-text">或</span><span class="ne-text">文件锁</span><span class="ne-text">）来保护共享内存，确保数据的一致性。</span></li><li id="u69ba2b5d" data-lake-index-type="0"><span class="ne-text">生命周期管理</span><span class="ne-text">：共享内存段是独立于进程的。即使所有进程都崩溃了，共享内存段可能依然存在于内核中，需要手动清理（使用 </span><code class="ne-code"><span class="ne-text">ipcrm</span></code><span class="ne-text">命令）。</span></li></ul><hr id="LBKFM" class="ne-hr"><p id="ue823873f" class="ne-p"><span class="ne-text">底层原理（内存映射）</span></p><p id="u8c0d0151" class="ne-p"><span class="ne-text">这背后的魔法是</span><span class="ne-text">虚拟内存</span><span class="ne-text">和</span><span class="ne-text">页表</span><span class="ne-text">。</span></p><ul class="ne-ul"><li id="u58ac6102" data-lake-index-type="0"><span class="ne-text">每个进程都有自己的虚拟地址空间和页表，页表负责将虚拟地址映射到物理地址。</span></li><li id="udbef7bb0" data-lake-index-type="0"><span class="ne-text">当进程A和进程B都附加到同一块共享内存时，它们的页表中，</span><span class="ne-text">不同的虚拟地址页面</span><span class="ne-text">被映射到了</span><span class="ne-text">相同的物理内存帧</span><span class="ne-text">上。</span></li><li id="u406fd8d6" data-lake-index-type="0"><span class="ne-text">进程A写入其虚拟地址 </span><code class="ne-code"><span class="ne-text">0x1234</span></code><span class="ne-text">，通过页表转换，实际是写入了物理地址 </span><code class="ne-code"><span class="ne-text">0xAAAA</span></code><span class="ne-text">。</span></li><li id="ua61ef4fb" data-lake-index-type="0"><span class="ne-text">进程B读取其虚拟地址 </span><code class="ne-code"><span class="ne-text">0x5678</span></code><span class="ne-text">，通过页表转换，实际是从物理地址 </span><code class="ne-code"><span class="ne-text">0xAAAA</span></code><span class="ne-text">读取。</span></li><li id="ued83e8b2" data-lake-index-type="0"><span class="ne-text">这样，两个进程就通过共享的物理内存 </span><code class="ne-code"><span class="ne-text">0xAAAA</span></code><span class="ne-text">实现了通信。</span></li></ul></details>
## 文件系统
<font style="color:rgb(51, 51, 51);">文件系统主要负责管理和组织计算机存储设备上的文件和目录。</font>

<details class="lake-collapse"><summary id="u795f91d7"><span class="ne-text" style="font-size: 16px">作用/职责</span></summary><ol class="ne-ol"><li id="u332b9b13" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">存储管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：将文件数据存储到物理存储介质中，并且管理空间分配。</span></li><li id="ub1745add" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">文件管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</span></li><li id="u3df83e8c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">目录管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：目录的创建、删除、移动、重命名等等。</span></li><li id="u9bc6344a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">文件访问控制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：管理不同用户或进程对文件的访问权限。</span></li></ol></details>
<details class="lake-collapse"><summary id="u7fcb0942"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">硬链接和软链接</span></strong></summary><div class="ne-quote"><p id="u6b0e0637" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119); font-size: 16px">硬链接像一个人有多个外号，无论你用哪个外号称呼他，指的都是同一个人。这个人（文件数据）不会因为一个名字不用了而消失。</span></p><p id="uf8deb3ad" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119); font-size: 16px">软链接像一个快捷方式。</span></p></div><p id="u2fc13242" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">硬链接</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：本质是为同一个文件数据块创建多个目录条目。它直接指向文件的 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">inode</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">（索引节点）。它不能跨越文件系统，也不能对目录进行链接。</span></p><p id="u1349ee82" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1，原始文件删除后，只要还有一个硬链接存在，文件数据就不会被真正删除</span></p><p id="u2d5f78e0" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2，所有硬链接都是平等的，没有主次之分。它们只是同一个inode的不同名字。</span></p><p id="u61247cb2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">3，修改任何一个硬链接的内容，所有链接看到的内容都会同步改变，因为它们访问的是同一份数据。</span></p><p id="u94df19b9" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">软链接</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">：本质是一个特殊的文件，这个文件的内容是另一个文件的路径名。有独⽴的 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">inode</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。能跨越文件系统。</span></p><p id="u4eefe4f2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1，⽬标⽂件被删除了，链接⽂件还是在的，只不过打不开指向的文件了而已。</span></p><p id="u29c94bf2" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">硬链接为什么不能跨文件系统</span></strong></p><p id="u8a914d06" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。</span></p><p id="u1d1e3871" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</span></p></details>
## 网络IO
<details class="lake-collapse"><summary id="ucb1a155c"><strong><span class="ne-text" style="font-size: 16px">零拷贝</span></strong></summary><p id="ufee909e3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">零拷贝是一种用于提升I/O性能的关键技术，它的核心目标是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">减少甚至完全避免数据在内存中的不必要的拷贝次数</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，从而降低CPU开销和上下文切换，显著提升吞吐量。</span></p><p id="ud9812ad2" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">1. 传统方式的瓶颈：</span></strong></p><p id="u363ae279" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">以‘服务器发送文件’这个经典场景为例。传统方式下，数据需要经历：</span></p><ul class="ne-ul"><li id="ucf4d3905" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">read</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">调用：数据从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">磁盘</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">-&gt;</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内核缓冲区</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">-&gt;</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户缓冲区</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">（1次拷贝）。</span></li><li id="u91c1be36" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">write</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">调用：数据从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户缓冲区</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">-&gt;</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">套接字缓冲区</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">（第2次拷贝）。</span></li></ul><p id="uff3eabe7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">最后再从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">套接字缓冲区</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">送到网卡。</span></p><p id="u13d3bd68" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">这个过程涉及</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">4次上下文切换</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">和</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2次CPU数据拷贝</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">，效率很低。</span></p><p id="ucd1b7970" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">2. 零拷贝的解决方案：</span></strong></p><p id="u6ec9068a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Linux主要通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">sendfile</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">系统调用实现零拷贝。它允许数据直接在</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">内核缓冲区</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">和</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">套接字缓冲区</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">之间传输，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">完全绕过了用户空间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。这样就将拷贝次数从2次减少到了1次（仅内核内拷贝）。</span></p><p id="ua1d0cca2" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">3. 真正的‘零’拷贝：</span></strong></p><p id="uf223ddb8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">在支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Scatter-Gather DMA</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">的网卡控制器上，可以做到真正的零拷贝。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244); font-size: 16px">sendfile</span></code><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">调用时，内核不再拷贝数据本身，而是将数据在内存中的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">地址和长度信息</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">（描述符）直接发给网卡。之后，网卡的DMA引擎会</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">根据这些描述符，直接从内核缓冲区读取数据并发送</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。整个过程</span><strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">完全不需要CPU参与数据搬运</span></strong><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">。</span></p><p id="u782adadc" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">这也是Nginx、Kafka等高性能中间件能够实现极高吞吐量的核心技术之一。</span></p></details>
<details class="lake-collapse"><summary id="u27b7f7ec"><strong><span class="ne-text" style="font-size: 16px">IO 模型有哪些</span></strong></summary><p id="u87a39dd6" class="ne-p"><span class="ne-text">I/O模型主要分为五种，区别在于应用程序在等待数据就绪和数据拷贝这两个阶段的行为不同。</span></p><ol class="ne-ol"><li id="u7771e990" data-lake-index-type="0"><span class="ne-text">阻塞I/O</span><span class="ne-text">：最传统的方式。应用程序调用I/O操作后，线程会一直挂起等待，直到数据完全准备好并从内核拷贝到用户空间。</span><span class="ne-text">简单，但性能差</span><span class="ne-text">，一个线程只能处理一个连接。</span></li><li id="ua8490ce4" data-lake-index-type="0"><span class="ne-text">非阻塞I/O</span><span class="ne-text">：应用程序调用I/O操作后，如果数据没准备好，会立刻返回一个状态码。线程需要通过</span><span class="ne-text">不断轮询</span><span class="ne-text">来检查数据是否就绪，在拷贝数据时依然会阻塞。</span><span class="ne-text">避免了线程挂起，但轮询消耗大量CPU</span><span class="ne-text">。</span></li><li id="u98ccc555" data-lake-index-type="0"><span class="ne-text">I/O多路复用</span><span class="ne-text">：这是</span><span class="ne-text">高并发编程的基石</span><span class="ne-text">。应用程序将多个I/O请求注册到一个多路复用器（如</span><code class="ne-code"><span class="ne-text">select</span></code><span class="ne-text">, </span><code class="ne-code"><span class="ne-text">epoll</span></code><span class="ne-text">），然后阻塞在这个复用器上。当任何一个请求的数据就绪时，复用器返回通知，应用程序再逐个处理。</span><span class="ne-text">核心优势是一个线程可以高效地管理成千上万个连接</span><span class="ne-text">。</span></li><li id="u7393d212" data-lake-index-type="0"><span class="ne-text">信号驱动I/O</span><span class="ne-text">：应用程序在发起I/O请求后就可以继续执行。当数据就绪时，内核会发送一个信号来通知应用程序，随后应用程序再进行数据拷贝（该阶段阻塞）。</span><span class="ne-text">通知机制是异步的，但拷贝仍是同步的</span><span class="ne-text">，实践中较少使用。</span></li><li id="ue7c79cb8" data-lake-index-type="0"><span class="ne-text">异步I/O</span><span class="ne-text">：</span><span class="ne-text">真正的异步模型</span><span class="ne-text">。应用程序发起I/O请求后立即返回，内核会负责完成从等待数据到数据拷贝的所有工作。完成后，内核通过回调等方式通知应用程序。</span><span class="ne-text">应用程序在两个阶段都不会被阻塞</span><span class="ne-text">。</span></li></ol><hr id="ZIuow" class="ne-hr"><p id="u558fa68c" class="ne-p"><span class="ne-text">前四种模型（阻塞、非阻塞、多路复用、信号驱动）都属于同步I/O，因为真正的I/O读写操作都会在某个时间点阻塞进程。只有最后一种异步I/O才是真正的异步。目前，I/O多路复用是Linux系统下实现高并发网络应用最主流、最高效的模型。</span></p></details>
<details class="lake-collapse"><summary id="u5e818168"><span class="ne-text" style="color: rgb(51, 51, 51)">I/O 多路复用三种实现机制</span></summary><h4 id="PV4vT"><span class="ne-text">select、poll、epoll</span></h4><p id="u6ef3913c" class="ne-p"><code class="ne-code"><span class="ne-text">select</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">poll</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">epoll</span></code><span class="ne-text">都是 Linux 下实现 I/O 多路复用的核心机制，但它们的设计和性能有着代际般的差异。</span></p><p id="u18ccf452" class="ne-p"><span class="ne-text">首先是最基础的 </span><code class="ne-code"><span class="ne-text">select</span></code><span class="ne-text">。</span><span class="ne-text"> 它的工作方式是轮询，每次调用都需要将整个需要监听的文件描述符集合从用户态拷贝到内核态，然后由内核线性扫描所有描述符来判断是否就绪。它的主要问题是性能会随着连接数的增加而线性下降，并且有 1024 这个连接数的硬性限制。</span></p><p id="u41dd96a9" class="ne-p"><span class="ne-text">然后是 </span><code class="ne-code"><span class="ne-text">poll</span></code><span class="ne-text">。</span><span class="ne-text"> 它改进了 </span><code class="ne-code"><span class="ne-text">select</span></code><span class="ne-text">的一些缺陷，用动态的 pollfd 结构数组替代了固定的位图，从而解除了连接数的限制。但它的本质依然是轮询，内核依然需要线性扫描所有被监视的描述符，所以性能瓶颈依然存在。</span></p><p id="u12c87f55" class="ne-p"><span class="ne-text">最后是现代高性能的 </span><code class="ne-code"><span class="ne-text">epoll</span></code><span class="ne-text">。</span><span class="ne-text"> 它完全采用了事件驱动的设计。我们通过 </span><code class="ne-code"><span class="ne-text">epoll_ctl</span></code><span class="ne-text">预先将描述符注册到内核，内核会通过回调机制来管理事件就绪的通知。当调用 </span><code class="ne-code"><span class="ne-text">epoll_wait</span></code><span class="ne-text">时，它只是从内核的一个就绪事件链表中取出结果并返回，而无需遍历整个集合。这使得它的性能不会随着连接数的增加而下降，只与活跃连接的数量正相关，因此能够轻松应对数万甚至数十万的并发连接。</span></p><p id="u0af3bfd3" class="ne-p"><span class="ne-text">总结来说，三者的演进路径是从低效的轮询（select/poll）走向了高效的事件通知（epoll）。</span><code class="ne-code"><span class="ne-text">select</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">poll</span></code><span class="ne-text">适用于跨平台或连接数极少的场景，而 </span><code class="ne-code"><span class="ne-text">epoll</span></code><span class="ne-text">则是 Linux 下构建高性能网络服务的绝对首选和基石，像 Nginx 和 Redis 都深度依赖它。</span></p></details>








