- [x] 多线程
- [x] 锁
- [x] JMM
- [x] 线程池
- [x] 关键字/并发类/工具
- [ ] 其他

## 多线程
### 线程
<details class="lake-collapse"><summary id="ub73c0a90"><span class="ne-text" style="font-size: 16px">Java 线程的生命周期和状态，</span><span class="ne-text" style="color: rgb(51, 51, 51)">阻塞和 等待（Waiting）有什么区别</span></summary><p id="uff612c8e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java线程大致有 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">六种状态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，定义在 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Thread.State</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 枚举中，整个生命周期如下：</span></p><p id="ub1cce698" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">1. 新建（New）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 线程对象刚创建，还没调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">start()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法。</span></p><p id="uabf3c7bf" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">2. 就绪（Runnable）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">start()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 后，线程进入就绪队列，等待 CPU 调度。此时并没有运行。</span></p><p id="u4fa09d73" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">3. 运行中（Running）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 线程真正获得 CPU 时间片，开始执行 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">run()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法的代码。</span></p><p id="u583e4343" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">4. 阻塞（Blocked）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 线程尝试获取某个被别的线程持有的锁（比如 synchronized），获取不到就进入阻塞状态，直到拿到锁。</span></p><p id="ua4f39df9" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">5. 等待（Waiting）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 线程主动等待别的线程的通知，例如调用了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">join()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，没有设置超时。必须通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">join()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 结束才会被唤醒。</span></p><p id="u9f716f41" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">6. 计时等待（Timed Waiting）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 和等待类似，但设置了超时时间，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep(1000)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait(1000)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">join(1000)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="u6151d990" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">7. 终止（Terminated）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 线程运行完了，或者抛异常终止了，生命周期结束。</span></p><hr id="ETwTC" class="ne-hr"><p id="u5b161912" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">阻塞 和 等待有什么区别</span></strong></p><p id="u412a240f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Blocked 状态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 表示线程</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">正在等待获取某个锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也就是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">被阻塞在同步块或同步方法上</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。它是由 Java 的内置锁（synchronized）竞争引起的。当一个线程试图进入一个被其他线程锁住的 synchronized 代码块时，就会进入 Blocked 状态，直到锁可用。</span></p><p id="u26e36502" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Waiting 状态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 表示线程</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">主动进入等待</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，等待其他线程执行特定操作来唤醒它，比如调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">join()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LockSupport.park()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法。处于 Waiting 状态的线程不占用 CPU，也不在竞争锁，只有被显式唤醒（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">unpark()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）才会继续执行。</span></p><ul class="ne-ul"><li id="uea361dc2" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">BLOCKED是锁竞争失败后被被动触发的状态，WAITING是人为的主动触发的状态</span></li><li id="u4bb989f1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">BLCKED的唤醒时自动触发的，而WAITING状态是必须要通过特定的方法来主动唤醒</span></li></ul></details>
<details class="lake-collapse"><summary id="u7775879c"><span class="ne-text" style="font-size: 16px">Java 创建线程的方式</span></summary><p id="u4261716e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第一种是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">继承 Thread 类</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，重写它的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">run()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，然后创建实例调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">start()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法启动线程。这种方式简单直观，但因为 Java 不支持多继承，所以灵活性较差。</span></p><p id="uf9b3ab61" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第二种是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">实现 Runnable 接口</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，把线程逻辑写在 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">run()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法中，再把这个实现类传给 Thread 构造器。这种方式更灵活，适合资源共享，也更符合面向接口编程的思想。</span></p><p id="u598552a6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三种是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">实现 Callable 接口并结合 FutureTask 使用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。这个方式的优势是可以有返回值，且可以抛出异常，更适合需要拿到线程执行结果的场景。</span></p><p id="u531c7d29" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">如果使用</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程池</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，比如通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ExecutorService</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来提交任务，那底层其实也是通过 Callable 或 Runnable 实现的，只是线程的创建和管理交给了线程池，效率更高、控制力更强，但也增加了程序的复杂度。</span></p></details>
<details class="lake-collapse"><summary id="u5caa188e"><span class="ne-text" style="font-size: 16px">Java 终止线程运行的方式</span></summary><p id="u3d951322" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 中，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">停止线程的方式主要有以下几种</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></p><p id="u938e2f5d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第一，调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Thread.stop()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法强行终止线程，不推荐，会导致线程突然释放所有锁，可能造成数据不一致等问题。</span></p><p id="u4d55bc98" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第二，使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或标志变量自定义停止逻辑，我们可以在线程类中定义一个volatile布尔类型的标志位，通过修改这个标志位的值来控制线程是否继续执行。线程在运行时定期检查这个标志位，当标志位变为false时，线程就会自然退出run方法。</span></p><p id="uc33a35dc" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三，通过调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">interrupt()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法进行协商式中断，Java提供了interrupt()方法来请求中断线程。线程可以通过isInterrupted()方法检查中断状态，或者在执行可中断的阻塞操作（如sleep、wait等）时捕获InterruptedException来响应中断请求。</span></p><p id="uad889919" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">更推荐第三种。</span></p></details>
<details class="lake-collapse"><summary id="u69ee4e85"><span class="ne-text" style="color: rgb(51, 51, 51)">interrupt方法，notify 方法，run 方法</span></summary><h3 id="lvCkj"><span class="ne-text" style="color: rgb(51, 51, 51)">interrupt方法</span></h3><p id="u87c705e6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">interrupt()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是一种用于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">中断线程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的机制，但它并不会强制终止线程，而是通过</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">设置中断标志位</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">来通知线程“你该停下来了”，属于一种协商式中断。</span></p><p id="ubdfbd4e1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当调用某个线程的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">interrupt()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法时，线程的中断标志会被置为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">true</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。这个标志不会自动影响线程的运行状态，因此需要在线程内部通过检查 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Thread.currentThread().isInterrupted()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，或在阻塞方法（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">join()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）中捕获 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InterruptedException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来响应中断请求。</span></p><p id="u27d65506" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">也就是说，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程是否中断取决于线程自己是否响应中断信号。</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 此外，调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">interrupt()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 也不会中断处于运行状态的线程，只会对处于阻塞状态的线程产生影响。</span></p><p id="u209072fc" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">所以 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">interrupt()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的正确使用方式是：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">在外部发出中断信号，在线程内部主动检查和处理。</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">这样既安全又可控，符合线程的生命周期管理原则。</span></p><hr id="NBk28" class="ne-hr"><h3 id="s7ScL"><span class="ne-text" style="color: rgb(51, 51, 51)">notify 方法</span></h3><p id="u25675635" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Object</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类提供的方法，用于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">唤醒一个正在等待该对象监视器（monitor）的线程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。它通常与 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 搭配使用，实现线程间的协作。</span></p><p id="u9bec1845" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当一个线程调用了某个对象的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法后，会释放该对象的锁并进入 Waiting 状态，等待其他线程调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notifyAll()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的作用就是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">随机唤醒一个</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">正在等待这个对象锁的线程，让它从 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 中恢复，进入阻塞队列，等待重新获取锁。</span></p><ul class="ne-ul"><li id="ue09b422a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不会立刻让被唤醒的线程执行</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，它只是把线程唤醒并放入锁的等待队列中，线程仍需竞争锁。</span></li><li id="u9a4d844c" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 必须在 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">同步块或同步方法中调用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，否则会抛出 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">IllegalMonitorStateException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li><li id="ud91e8027" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notifyAll()</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会唤醒所有等待线程，适用于多个线程可能都需要重新判断条件的场景，比如多线程并发依赖同一个共享状态时更为安全。</span></li></ul><hr id="ees9z" class="ne-hr"><h3 id="4ef8f9ba"><span class="ne-text" style="color: rgb(51, 51, 51)">Thread 类的 run 方法</span></h3><p id="u6abeeb40" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可以直接调用 Thread 类的 run 方法吗？</span></strong></p><p id="u8ad559b4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">可以，但是一般不会直接调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">run()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，而是使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">start()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来正确启动线程。</span></p><p id="u983ab7cb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">直接调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">run()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 并不会启动一个新线程，它只是一个普通的方法调用，会在当前线程中执行，不具备多线程的效果。</span></p><p id="uf51c6989" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">正常启动线程，应该调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">start()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">start()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会由 JVM 创建新的线程，然后自动调用该线程的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">run()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，真正实现多线程并发。</span></p></details>
<details class="lake-collapse"><summary id="u55325785"><span class="ne-text" style="font-size: 16px">sleep 方法和 wait 方法有什么区别，为什么</span><span class="ne-text" style="color: rgb(119, 119, 119)">不属一个类</span></summary><p id="u8a7869f4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在Java中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 都是控制线程执行流程的方法，两者都可以暂停线程的执行。</span></p><p id="u67d5ebcb" class="ne-p"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep()</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Thread</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类的方法，用于让当前线程暂停执行指定的时间。线程在暂停期间不会释放持有的锁。它通常用于线程执行的延时，比如定时任务或控制任务的执行频率。当线程调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 后，它会进入 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">“Timed Waiting”</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 状态，直到指定时间过去后自动唤醒。需要注意的是，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会抛出 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InterruptedException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，如果线程在睡眠过程中被中断。</span></p><p id="u32d8308f" class="ne-p"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Object</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类的方法，必须在同步块或同步方法中调用，因为它需要持有对象的锁。当线程调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 后，它会进入 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">“Waiting”</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 状态，直到其他线程通过调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notifyAll()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来唤醒它。与 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不同，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会释放持有的锁，允许其他线程访问共享资源。这种机制通常用于线程间的通信，例如生产者-消费者问题。</span></p><p id="uccd491db" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">简单来说，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">sleep()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 用于让线程休眠一段时间，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 用于线程间的协调和同步，通常结合 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notifyAll()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 一起使用。</span></p><hr id="mmKtf" class="ne-hr"><p id="u98aadbe2" class="ne-p"><strong><span class="ne-text" style="color: rgb(119, 119, 119)">为什么不属一个类？</span></strong></p><p id="u5fcbccdd" class="ne-p"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">wait()</span></strong></code><strong><span class="ne-text" style="color: rgb(119, 119, 119)">属于</span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">Object</span></strong></code><strong><span class="ne-text" style="color: rgb(119, 119, 119)"> 类</span></strong><span class="ne-text" style="color: rgb(119, 119, 119)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">Object</span></code><span class="ne-text" style="color: rgb(119, 119, 119)">）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">Object</span></code><span class="ne-text" style="color: rgb(119, 119, 119)">）而非当前的线程（</span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">Thread</span></code><span class="ne-text" style="color: rgb(119, 119, 119)">）。</span></p><p id="u27ffee0b" class="ne-p"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">sleep()</span></strong></code><strong><span class="ne-text" style="color: rgb(119, 119, 119)"> 属于 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">Thread</span></strong></code><span class="ne-text" style="color: rgb(119, 119, 119)"> ：因为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(119, 119, 119); background-color: rgb(243, 244, 244)">sleep()</span></code><span class="ne-text" style="color: rgb(119, 119, 119)"> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</span></p></details>
<details class="lake-collapse"><summary id="udd39c6de"><span class="ne-text" style="font-size: 16px">守护线程</span></summary><p id="u744d3d97" class="ne-p"><br></p></details>
<details class="lake-collapse"><summary id="u11784652"><span class="ne-text" style="font-size: 16px">Java 线程间通信方式</span></summary><p id="u2d740289" class="ne-p"><br></p></details>


### 多线程
<details class="lake-collapse"><summary id="ud813f9da"><span class="ne-text" style="font-size: 16px">为什么要使用多线程</span></summary><p id="udd14981f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">使用多线程的核心目的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">提升程序的效率和响应能力</span></strong></p><p id="uf501e8e9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第一，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">提高资源利用率</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。现代 CPU 都是多核的，多线程可以让多个核心同时工作，实现真正的并行，提高处理能力。如果单线程运行，只能用到一个核心，浪费硬件资源。</span></p><p id="u3c0b892e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第二，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">提升程序响应性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。比如在图形界面或 Web 应用中，一个线程处理用户输入，另一个线程处理后台逻辑，可以避免界面卡顿，提升用户体验。</span></p><p id="u066cbf36" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">简化模型结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。像生产者-消费者、事件驱动、定时任务等，如果用多线程实现，会比纯粹的轮询或状态机更自然、清晰。</span></p><p id="uc3b7fdde" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第四，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">加快任务处理速度</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。比如同时处理多个客户端请求，或者将一个大任务拆分为多个线程并发处理，能够显著缩短整体耗时。</span></p></details>
<details class="lake-collapse"><summary id="ua17fc3a7"><span class="ne-text" style="font-size: 16px">线程越多越好吗</span></summary><ul class="ne-ul"><li id="ue9a71e03" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">上下文切换的开销</span></strong></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u6f5163bd" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">这是最核心的负面影响。CPU从执行一个线程切换到执行另一个线程时，需要保存当前线程的上下文（寄存器状态、程序计数器等）并加载下一个线程的上下文。</span></li><li id="ud2be68de" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">这个过程本身需要消耗CPU周期。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程数越多，切换就越频繁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，大量的CPU时间会浪费在管理线程上，而不是执行实际任务。当开销大于并发带来的收益时，性能就会不升反降。</span></li></ul></ul><ul class="ne-ul"><li id="u4e7d7bab" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">同步与锁的开销</span></strong></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u7bfbbfd7" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">多个线程共享资源时（如内存中的数据），必须使用锁（如互斥锁）来保证线程安全，避免数据竞争。</span></li><li id="ua3138770" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">锁竞争</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：线程数越多，对锁的竞争就越激烈。大量线程可能处于等待锁的状态（阻塞），这会导致性能下降。</span></li><li id="u30383051" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">死锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：线程数量的增加会使复杂的锁依赖关系更容易出现，极大地提高了出现死锁等复杂问题的风险，调试非常困难。</span></li></ul></ul><ul class="ne-ul"><li id="u466667e6" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">资源消耗</span></strong></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u448cb5da" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">每个线程都需要独立分配一些资源，最典型的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程栈</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">（通常为几MB）。创建成千上万的线程会消耗巨大的内存，可能导致内存不足。</span></li><li id="u6e78c5ad" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">操作系统内核也需要额外的空间来管理线程对象（如TCB）。</span></li></ul></ul><ul class="ne-ul"><li id="ud651bb76" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">设计复杂性</span></strong></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u568b1343" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">编写正确的、高效的多线程程序远比单线程程序复杂。需要考虑线程安全、原子性、可见性、顺序性等问题，对开发者的要求很高。</span></li></ul></ul><ul class="ne-ul"><li id="u41100e1a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">单核性能极限</span></strong></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u484d9f1d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">对于计算密集型任务，在单核CPU上增加线程数量纯粹是添乱，因为CPU一次只能执行一个线程，多线程带来的只有上下文切换的开销。</span></li></ul></ul></details>
<details class="lake-collapse"><summary id="u2ebc0cac"><span class="ne-text" style="font-size: 16px">使用多线程有什么注意事项</span></summary><p id="ub50f0ef1" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">原子性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和synchronized关键字来确保原子性；</span></p><p id="u385d446f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可见性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；</span></p><p id="ud6f40528" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">有序性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。</span></p></details>
## 锁
<details class="lake-collapse"><summary id="u12fcc6d6"><span class="ne-text" style="font-size: 16px">Java 有哪些锁</span></summary><p id="u5ddf03af" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内置锁（synchronized）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：Java中的synchronized关键字是内置锁机制的基础，可以用于方法或代码块。当一个线程进入synchronized代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。其中，syncronized加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。</span></p><p id="uc5e90462" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">ReentrantLock</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.util.concurrent.locks.ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">是一个显式的锁类，提供了比</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">更高级的功能，如可中断的锁等待、定时锁等待、公平锁选项等。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">使用</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">lock()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">和</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">unlock()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。</span></p><p id="u26a26bf4" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">读写锁（ReadWriteLock）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.util.concurrent.locks.ReadWriteLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。</span></p><p id="ub7fed1bc" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">乐观锁和悲观锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：：悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">和</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。</span></p><p id="uad827328" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自旋锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：：自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。</span></p></details>
<details class="lake-collapse"><summary id="u321d34f2"><span class="ne-text" style="font-size: 16px">可重入锁</span></summary><p id="u4debbbe5" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可重入锁（Reentrant Lock）指的是同一个线程在获取锁之后，可以再次获取这把锁而不会发生死锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="uea856e56" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">换句话说，如果一个线程已经获得了某个锁，它可以在没有释放该锁的情况下再次进入同一个锁保护的代码块，系统会自动记录</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">锁的重入次数</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，等线程退出时再逐层释放。</span></p><p id="ucd129f26" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java 中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 都是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可重入锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的实现。</span></p><p id="u3791de22" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">举个例子说明：如果一个线程调用一个加了锁的方法，而这个方法内部又调用了另一个加了相同锁的方法，由于同一个线程已经持有了锁，所以可以顺利进入内层方法，不会被自己阻塞。</span></p><p id="u13eb6b37" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">可重入锁的好处是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">避免了递归调用或内部方法调用时死锁的问题</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也让程序结构更加清晰。</span></p></details>
<details class="lake-collapse"><summary id="u4691803b"><span class="ne-text" style="font-size: 16px">乐观锁和悲观锁，怎么实现一个乐观锁</span></summary><p id="u1b29bed6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">乐观锁和悲观锁本质上是两种并发控制策略，它们的核心区别在于对</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">数据冲突的预期不同</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="ueb041163" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">悲观锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">认为并发冲突是很常见的，因此每次访问共享资源时都会</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">先加锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，比如使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来保证同一时刻只有一个线程访问资源。这种方式安全性高，适用于并发写多、冲突频繁的场景，比如转账、订单扣库存等。</span></p><p id="u2681f48d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">乐观锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">则认为并发冲突是少数，它</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不加锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，而是每次读取数据时带上一个版本号或时间戳，修改时再比对当前版本是否一致。如果一致就更新成功，否则就重试。像 Java 中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AtomicInteger</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AtomicReference</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，底层就是基于 CAS 实现的乐观锁。数据库中也常用乐观锁，比如用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">version</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 字段控制更新。</span></p><p id="u5dccac3b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">简单来说，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">悲观锁重在预防，乐观锁重在事后校验</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="u202cb08f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LongAdder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">），也是可以考虑使用乐观锁的，要视实际情况而定。</span></p><p id="u173d9729" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</span></p><hr id="KiGvA" class="ne-hr"><h3 id="885e2bf9"><span class="ne-text" style="color: rgb(51, 51, 51)">Java实现一个乐观锁的方式</span></h3><p id="u703f05ef" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">CAS（Compare and Swap）操作</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">： CAS 是乐观锁的基础。Java 提供了 java.util.concurrent.atomic 包，包含各种原子变量类（如 AtomicInteger、AtomicLong），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁。</span></p><p id="ue41f3394" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">版本号控制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：增加一个版本号字段记录数据更新时候的版本，每次更新时递增版本号。在更新数据时，同时比较版本号，若当前版本号和更新前获取的版本号一致，则更新成功，否则失败。</span></p><p id="u6d2bbaf5" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">时间戳</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：使用时间戳记录数据的更新时间，在更新数据时，在比较时间戳。如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败。</span></p></details>
<details class="lake-collapse"><summary id="ued2001bd"><span class="ne-text" style="font-size: 16px">版本号机制</span></summary><p id="ud2f70a04" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">版本号机制是实现乐观锁的常见方式之一，主要用于解决并发修改共享数据的问题。</span></p><p id="ud89eb1c3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它的核心思路是：每条数据都加一个版本号字段（如 version），每次读取数据时一并读取当前版本号，更新时也携带这个版本号。</span></p><p id="u43b4d9b7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当进行更新操作时，系统会检查当前数据库中的版本号是否与之前读取的一致：</span></p><ul class="ne-ul"><li id="u9fe599a4" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">如果一致，说明这段时间内没人改动过这条数据，就允许更新，并把版本号 +1；</span></li><li id="u7e0a27e5" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">如果不一致，说明其他线程已经修改过了，当前更新失败，可以选择重试或提示用户。</span></li></ul><p id="u48b51e90" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这个机制避免了加锁，也能有效防止脏写（Lost Update）问题。</span></p></details>
<details class="lake-collapse"><summary id="ud43b6664"><span class="ne-text" style="color: rgb(51, 51, 51)">CAS算法</span></summary><p id="ua21261b6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">CAS，全称是 Compare-And-Swap（比较并交换），是一种常见的无锁并发原子操作，底层由硬件指令支持。</span></p><p id="u1f660aa5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它的核心思想是：在更新某个共享变量时，先比较它的当前值是否是预期值，如果是，则更新为新值；如果不是，说明已经被其他线程修改过，更新失败，通常会进行重试。</span></p><p id="u58f5796c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.util.concurrent.atomic</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 包下的原子类，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AtomicInteger</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AtomicReference</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，就是基于 CAS 实现的乐观锁。</span></p><hr id="bWNls" class="ne-hr"><p id="u2bc04928" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">ABA 问题</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是 CAS 算法中一个典型的并发陷阱。</span></p><p id="u15119cdf" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">会有 ABA 的问题，变量值在操作过程中先被其他线程从 A 修改为 B ，又被改回 A ，CAS 无法感知中途变化，导致操作误判为“未变更”。</span></p><p id="u4313c3d2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">CAS 只比较当前值和预期值是否相等，但</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">并不知道这个值在期间是否发生过变化又被改回来了</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也就是说，它只能比较“值”，但不知道“过程”。为了避免 ABA 问题，Java 提供了带版本号的原子引用类：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AtomicStampedReference</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：每次更新时不仅比较值，还比较一个“版本号”或“时间戳”，确保值和版本都没变，从而检测到中间的变化。</span></p></details>
<details class="lake-collapse"><summary id="uf17c09f2"><span class="ne-text" style="font-size: 16px">公平锁和非公平锁，非公平锁的吞吐量为什么比公平锁大</span></summary><p id="ue880e02d" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">公平锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> : 指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点在于各个线程公平平等，每个线程等待一段时间后，都有执行的机会，而它的缺点就在于整体执行速度更慢，吞吐量更小。</span></p><p id="uee759d9a" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">非公平锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：多个线程加锁时直接尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。非公平锁的优势就在于整体执行速度更快，吞吐量更大，但同时也可能产生线程饥饿问题，也就是说如果一直有线程插队，那么在等待队列中的线程可能长时间得不到运行。</span></p><p id="u5f846b3f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Synchronized不属于公平锁，ReentrantLock是公平锁。</span></p><hr id="CTvqz" class="ne-hr"><h3 id="5ce1d198"><span class="ne-text" style="color: rgb(51, 51, 51)">非公平锁吞吐量为什么比公平锁大？</span></h3><p id="u73e26aba" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">公平锁执行流程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。</span></p><p id="ufb1aadd8" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">非公平锁执行流程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。</span></p></details>
<details class="lake-collapse"><summary id="uc70cd3b6"><span class="ne-text" style="font-size: 16px">可中断锁和不可中断锁</span></summary><p id="u17b21164" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可中断锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，指的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程在等待获取锁的过程中，可以被中断，从而提前退出等待</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">；而</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不可中断锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">则不支持这种机制，一旦开始等待锁，就必须等到锁可用才能继续执行，期间不能响应中断。</span></p><p id="u312d5fbb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是一种</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不可中断锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。如果一个线程在尝试进入 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 块时被阻塞，那么它只能无限等待下去，除非获取到锁或者线程被强制终止，中间无法通过中断机制来提前结束。</span></p><p id="u2d56019e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可中断锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，它提供了一个方法叫做 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">lockInterruptibly()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，线程在调用这个方法加锁时，如果被其他线程中断，会立刻抛出 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InterruptedException</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，从而退出等待。这种机制在高并发或者死锁预防场景中非常有用。</span></p></details>
<details class="lake-collapse"><summary id="u7cb9c78d"><span class="ne-text" style="font-size: 16px">共享锁和独占锁</span></summary><p id="u268ffd8b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">区别主要体现在是否允许多个线程同时持有锁。</span></p><p id="u7f4aef6c" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">独占锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">指的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">同一时刻只能被一个线程持有</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，其他线程必须等待锁释放后才能继续执行。这种锁常用于写操作，目的是防止多个线程同时修改共享资源，从而确保数据一致性。Java 中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 都属于独占锁的典型实现。</span></p><p id="u86abb296" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">共享锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">允许</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">多个线程同时持有</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，只要它们执行的操作不会互相冲突。共享锁通常用于读操作，也叫“读锁”。多个线程可以同时读取共享数据，只要没有线程进行写操作，这种方式可以显著提高读密集型场景下的并发性能。</span></p></details>
<details class="lake-collapse"><summary id="u92d68f93"><span class="ne-text" style="font-size: 16px">自旋锁和互斥锁</span></summary><p id="u0eb2fc1c" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自旋锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是一种</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">忙等待</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的锁机制。当一个线程尝试获取一个已经被占用的自旋锁时，它不会立即进入睡眠状态，而是会在一个循环中</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">持续地检查锁是否被释放</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，直到成功获取锁为止。</span></p><p id="u0e81ec29" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">互斥锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：一种用于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">阻塞等待</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的锁机制。当一个线程需要访问共享资源时，它会先尝试“锁住”该资源。如果锁已被其他线程占用，该线程会</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">进入睡眠状态（阻塞）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，被操作系统挂起并放入等待队列。直到锁被释放，操作系统才会唤醒其中一个等待的线程。</span></p><hr id="dgj1U" class="ne-hr"><p id="u7d68c5e8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">自旋锁与互斥锁最根本的区别在于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程获取锁失败时的等待策略</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="ufcec4da7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">互斥锁采取一种</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">被动等待</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的策略。当线程无法立即获得锁时，它会主动放弃CPU，进入睡眠状态，并将自己加入到等待队列中。这个行为会导致</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">上下文切换</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，即从用户态陷入内核态，由操作系统内核来调度其他线程运行。直到锁被释放后，操作系统再唤醒等待的线程来获取锁。因此，互斥锁的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">开销主要来自于两次上下文切换</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">（睡眠和唤醒）的成本。</span></p><p id="uda9af4d6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而与互斥锁的“睡眠等待”截然不同，自旋锁采取一种</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">主动忙等待</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的策略。线程在获取锁失败时，不会放弃CPU，也不会进入睡眠，而是会持续不断地在一个循环中检查锁的状态，就像在原地不停地旋转一样，直到锁被释放并成功获取。这意味着</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自旋锁在等待期间会持续占用CPU时间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">进行空转，但其优势是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">完全避免了上下文切换的开销</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="u5f556187" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这种策略上的根本差异，直接决定了两者截然不同的适用场景。互斥锁通过睡眠来节省CPU资源，更适用于锁持有时间较长的场景；而自旋锁则通过消耗CPU时间来换取极致的响应速度，因此只能在锁持有时间极短的多核环境下使用。</span></p></details>
<details class="lake-collapse"><summary id="u44d3ccd4"><span class="ne-text" style="font-size: 16px">活锁和饥饿锁</span></summary><p id="uebd3c574" class="ne-p"><span class="ne-text">饥饿 和 活锁 都是并发编程中线程无法正常执行的问题，但原因不同。</span></p><ol class="ne-ol"><li id="u4919347f" data-lake-index-type="0"><span class="ne-text">饥饿</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u1c578306" data-lake-index-type="0"><span class="ne-text">是什么</span><span class="ne-text">：一个或多个线程因为</span><span class="ne-text">优先级太低</span><span class="ne-text">或</span><span class="ne-text">始终无法竞争到资源</span><span class="ne-text">（如CPU时间、锁），而</span><span class="ne-text">长期得不到执行</span><span class="ne-text">的情况。</span></li><li id="ub21b085f" data-lake-index-type="0"><span class="ne-text">比喻</span><span class="ne-text">：就像在食堂排队，总是有人插队到你前面，导致你永远打不到饭。</span></li><li id="uc326b926" data-lake-index-type="0"><span class="ne-text">原因</span><span class="ne-text">：通常由不合理的调度策略（如总是让短任务优先）或锁的抢占不公平导致。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="uc70e6c98" data-lake-index-type="0"><span class="ne-text">活锁</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u952aa9d9" data-lake-index-type="0"><span class="ne-text">是什么</span><span class="ne-text">：线程</span><span class="ne-text">没有被阻塞</span><span class="ne-text">，而是在持续地尝试某个失败的操作来响应其他线程，</span><span class="ne-text">彼此谦让或冲突</span><span class="ne-text">，导致所有线程都在“忙等”但都无法取得进展。</span></li><li id="u49d0c5d1" data-lake-index-type="0"><span class="ne-text">比喻</span><span class="ne-text">：两个人在狭窄的走廊迎面相遇，都试图让对方先过：你向左移，我也向左移，结果又挡住了；你向右移，我也向右移， again挡住了。我们都在动，但谁都没过去。</span></li><li id="u8624d26d" data-lake-index-type="0"><span class="ne-text">原因</span><span class="ne-text">：通常是由于设计了不完善的冲突重试机制。</span></li></ul></ul><p id="uf7324af4" class="ne-p"><span class="ne-text">核心区别</span><span class="ne-text">：</span></p><ul class="ne-ul"><li id="ub51b619b" data-lake-index-type="0"><span class="ne-text">饥饿</span><span class="ne-text">是线程“</span><span class="ne-text">根本抢不到</span><span class="ne-text">”资源，状态是</span><span class="ne-text">被动等待</span><span class="ne-text">。</span></li><li id="u21ddb7d3" data-lake-index-type="0"><span class="ne-text">活锁是线程“在努力抢”但“徒劳无功”，状态是主动忙等。</span></li></ul></details>
## Java 内存模型


## 线程池
<details class="lake-collapse"><summary id="ue8291520"><strong><span class="ne-text" style="font-size: 16px">线程池是什么，有什么好处</span></strong></summary><p id="udd734513" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">线程池（Thread Pool）是 Java 并发编程中一种\线程管理机制，它的作用是：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">预先创建一组线程并重复利用，避免频繁创建和销毁线程的开销</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，从而提升系统性能和资源利用率。</span></p><p id="ue45603d4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在没有线程池的情况下，每次执行任务都要新建线程，而线程的创建和销毁是昂贵的系统操作，频繁使用会导致性能下降，甚至资源耗尽。线程池通过</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">复用已存在的线程来执行多个任务</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，大大降低了系统开销。</span></p><p id="u9534bcc0" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">好处：</span></p><ul class="ne-ul"><li id="uab22bf31" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">复用线程，避免频繁创建销毁，提高性能；</span></li><li id="u09db7653" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">统一调度任务，便于控制并发量和资源使用；</span></li><li id="ud8b3d0b3" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">支持任务排队</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">、</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">定时执行</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">、</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">取消等高级特性；</span></li><li id="u6b0ffe89" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">适用于高并发、高吞吐量的服务端程序。</span></li></ul></details>
<details class="lake-collapse"><summary id="u4d197c07"><strong><span class="ne-text" style="font-size: 16px">线程池的主要参数</span></strong></summary><p id="u494d9d98" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">常见的几个参数包括：核心线程数、最大线程数、线程存活时间、任务队列、线程工厂和拒绝策略。</span></p><p id="u7669b5c3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先是核心线程数，也就是 corePoolSize。它表示线程池中始终保留的线程数量，即使这些线程空闲，也不会被销毁。当有新任务到来时，如果当前线程数还没达到这个值，就会优先创建新线程来处理任务。</span></p><p id="u0dc71754" class="ne-p"><strong><span class="ne-text" style="color: rgb(119, 119, 119)">核心线程数可以设置为0</span></strong><span class="ne-text" style="color: rgb(119, 119, 119)"> : 当核心线程数为 0 时，来了一个任务之后，会先将任务添加到任务队列，同时也会判断当前工作的线程数是否为 0，如果为 0，则会创建线程来执行线程池的任务。</span></p><p id="ud8d8a38d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">接着是最大线程数，也就是 maximumPoolSize。它定义了线程池允许创建的最大线程数量。当任务很多，核心线程都在忙，并且任务队列也满了，线程池才会创建超过核心数量的线程，但不会超过这个最大值。</span></p><p id="u1f424590" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">然后是 keepAliveTime，它表示线程在空闲状态下的最大存活时间。超过这个时间没有新任务时，非核心线程会被回收掉。如果配置了允许核心线程超时，这个参数对核心线程也生效。</span></p><p id="uc832c6a4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">任务队列是线程池内部用于缓存等待执行任务的数据结构。比较常见的有有界队列和无界队列。如果使用无界队列，比如默认的 LinkedBlockingQueue，在任务堆积过多时容易导致内存溢出。生产环境中更推荐使用有界队列，能更好地控制系统负载。</span></p><p id="u04454f2c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">线程工厂用于定制线程的创建方式，比如给线程起个有意义的名字，设置是否为守护线程等。合理命名线程有助于排查问题和监控线程状态。</span></p><p id="u42452a4f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最后是拒绝策略。当线程池达到最大线程数并且任务队列已满时，新的任务就无法被接受，这时就会触发拒绝策略。常见的策略包括直接抛出异常、由调用线程执行任务、丢弃任务，或者丢弃最旧的任务。</span></p><p id="ufbbc22d3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">整体来看，线程池参数的配置需要根据具体业务场景来调整。核心线程数决定基本并发能力，最大线程数控制系统极限，队列影响任务调度方式，拒绝策略则决定在资源耗尽时如何应对。合理配置这些参数，才能构建出稳定、高效、可控的并发系统。</span></p></details>
<details class="lake-collapse"><summary id="u6e7ec88c"><strong><span class="ne-text" style="font-size: 16px">线程池越大越好吗</span></strong></summary><p id="u1583cc96" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">线程池并不是越大越好，它的大小应该根据业务特性、系统资源和任务类型来合理设定。过小的线程池会导致并发能力不足，处理速度慢；但过大的线程池会消耗大量系统资源，甚至引发线程切换频繁、内存压力大或系统崩溃等问题。</span></p><p id="u960aa0de" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">设定线程池大小时，通常要区分任务是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">CPU 密集型</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">还是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">IO 密集型</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="u290cbc85" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">对于 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">CPU 密集型任务</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，例如大量计算、加密等，这类任务几乎不涉及阻塞，CPU 是主要瓶颈。线程数设置得太多反而导致频繁上下文切换，反而降低效率。比较合理的配置是：</span></p><p id="ued27deea" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">线程数 ≈ CPU 核心数 或 CPU 核心数 + 1</span></p><p id="u27a0d50d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">对于 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">IO 密集型任务</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，比如读写文件、访问数据库、网络请求等，线程大部分时间都在等待 IO 完成。这种情况下线程是“阻塞多、运行少”，可以适当增加线程数来提高吞吐。常见经验值是：</span></p><p id="udfe320fb" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">线程数 ≈ CPU 核心数 × 2 或更高（甚至 2~4 倍）</span></p><p id="u5ee6b1f9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当然这些只是经验估算，实际项目中最好通过 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">压测</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">监控指标</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">进行动态调整，找到一个平衡点。还要结合服务器内存、上下文切换成本、业务响应时间要求等因素。</span></p><p id="ubb667d09" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">此外，对于不同类型的业务，建议</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">将线程池拆分多个子池</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">分别管理，避免一个高延迟业务拖慢其他任务处理，提升系统整体可控性。</span></p></details>
<details class="lake-collapse"><summary id="u87d0a834"><span class="ne-text" style="font-size: 16px">线程池的 工作流程</span></summary><p id="ue46bcdc5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">线程池处理任务的过程，其实可以分为几个阶段，按照“能否创建线程”、“队列是否有空间”、“是否超过最大线程数”这样的判断逻辑来一步步决定任务的去向。</span></p><p id="ue7fc3408" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当线程池调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">execute()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 提交一个任务时，它会按照以下顺序处理：</span></p><p id="u4e75e8eb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第一步，线程池会判断当前运行的线程数量是否小于核心线程数。如果还没达到核心数，就会直接创建一个新的线程来执行这个任务，这样可以快速响应初始请求。</span></p><p id="u8c799570" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第二步，如果核心线程已经满了，线程池会尝试将任务放入任务队列中。如果队列还有空间，任务就会被缓存等待，由已有的线程来逐个处理。</span></p><p id="u94f87c0f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三步，如果队列也满了，说明线程池已经有压力了，此时线程池会判断当前线程数是否还没达到最大线程数。如果还没到上限，就会继续创建新的线程来处理任务。</span></p><p id="u57422892" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第四步，如果最大线程数也达到了，并且队列也满了，这时就说明线程池完全饱和了，新的任务将会被拒绝，具体怎么拒绝则由拒绝策略决定。</span></p><p id="uce5bd74b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从这个流程可以看出，线程池会优先使用核心线程快速响应，其次是队列缓冲，最后才是扩容线程，目的是在保证性能的同时，尽可能避免资源过度使用。</span></p></details>
<details class="lake-collapse"><summary id="uded51428"><span class="ne-text" style="font-size: 16px">线程池有哪些种类</span></summary><p id="u9db97f40" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java 中的线程池主要由 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Executors</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 工具类提供，它封装了多种常用线程池实现，常见的线程池类型包括：</span></p><ol class="ne-ol"><li id="u83e85710" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">FixedThreadPool（固定大小线程池）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">核心线程数固定，适用于任务量稳定、对资源控制较严格的场景。空闲线程会复用，不会被销毁。</span></li><li id="ub5edd80a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">CachedThreadPool（可缓存线程池）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程数不固定，适用于执行大量短期异步任务。线程闲置超过 60 秒会被回收，适合任务突发场景。</span></li><li id="ub40bab25" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">SingleThreadExecutor（单线程线程池）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">始终只有一个线程串行执行任务，保证任务执行的顺序性。</span></li><li id="uf72b6cff" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">ScheduledThreadPool（定时任务线程池）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">支持定时或周期性执行任务，常用于替代 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Timer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的功能。</span></li><li id="ue34005b4" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">WorkStealingPool（JDK 1.8+ 引入）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">基于 ForkJoinPool 实现的线程池，支持任务窃取，适合 CPU 密集型任务并行处理。</span></li></ol></details>
<details class="lake-collapse"><summary id="u503e9089"><span class="ne-text" style="font-size: 16px">核心线程</span></summary><p id="ud4b74bbb" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadPoolExecutor</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 默认不会回收核心线程，即使它们已经空闲了。</span></p><p id="ufb6ecaeb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">核心线程空闲时，其状态分为以下两种情况：</span></p><ul class="ne-ul"><li id="uecc8af15" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">设置了核心线程的存活时间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> ：核心线程在空闲时，会处于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">WAITING</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 状态，等待获取任务。如果阻塞等待的时间超过了核心线程存活时间，则该线程会退出工作，将该线程从线程池的工作线程集合中移除，线程状态变为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">TERMINATED</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 状态。</span></li><li id="u729f4981" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">没有设置核心线程的存活时间</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> ：核心线程在空闲时，会一直处于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">WAITING</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 状态，等待获取任务，核心线程会一直存活在线程池中。</span></li></ul><p id="u516dba49" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当队列中有可用任务时，会唤醒被阻塞的线程，线程的状态会由 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">WAITING</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 状态变为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">RUNNABLE</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 状态，之后去执行对应任务。</span></p></details>
<details class="lake-collapse"><summary id="uf4a040b2"><span class="ne-text" style="font-size: 16px">拒绝策略，</span><span class="ne-text" style="color: rgb(119, 119, 119)">CallerRunsPolicy 拒绝策略有什么风险</span></summary><p id="ucdb2ba0a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">线程池的拒绝策略是指，当线程池中的线程数量已经达到最大限制，任务队列也满了，这时再有新任务提交，线程池该如何处理。这种情况通常出现在高并发或任务堆积时，是系统的一种保护机制。</span></p><p id="u0841ac91" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java 提供了四种内置的拒绝策略。第一种是默认的策略，叫做 AbortPolicy，它的行为是直接抛出异常，告诉调用者任务提交失败。这种方式可以让系统快速感知到线程池的饱和状态，适合对任务执行可靠性要求高的场景。</span></p><p id="u672ee743" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第二种是 CallerRunsPolicy，它不会抛异常，而是把任务交给调用线程自己去执行。也就是说，谁提交的任务，谁来处理。这种方式会拖慢任务提交速度，相当于起到一个自动限流的作用，能在一定程度上保护线程池不被压垮。（如果想要保证任何一个任务请求都要被执行的话选择）</span></p><p id="ud4f3365c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三种是 DiscardPolicy，顾名思义，就是直接丢弃新提交的任务，不处理也不抛异常。它的优点是简单粗暴，但缺点也很明显，任务可能悄无声息地被丢掉，适合那些可以容忍部分任务失败的场景，比如日志采集或监控上报。</span></p><p id="ua9063d11" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第四种是 DiscardOldestPolicy，它会丢弃任务队列中最早的那个任务，然后尝试把当前任务放进去。适用于那些老任务可能已经没什么意义，而新任务更重要的业务，比如某些实时推送场景。</span></p><p id="u728283c7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">总体来看，AbortPolicy强调任务不能丢；CallerRunsPolicy强调保护线程池，通过牺牲调用方速度来降压；DiscardPolicy牺牲任务可靠性换取线程池稳定性；而 DiscardOldestPolicy则是一种保新弃旧的权衡策略。</span></p><p id="uc5574be1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">选择哪种拒绝策略，取决于业务是否允许任务丢失、能否接受延迟处理，或者是否需要快速失败提示。在高并发系统中，合理设置拒绝策略是保障系统稳定运行的重要一环。</span></p><hr id="rt4Yp" class="ne-hr"><p id="u0a6bb7b0" class="ne-p"><strong><span class="ne-text" style="color: rgb(119, 119, 119)">CallerRunsPolicy 拒绝策略有什么风险</span></strong></p><p id="ud353483f" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">最典型的问题是阻塞主线程。比如在 Web 请求中，如果任务提交者是主线程或处理 HTTP 请求的线程，当线程池压力过大时，请求线程会被强制执行后台任务，导致处理变慢，甚至请求堆积，引发系统响应变慢、吞吐下降，进而影响整体可用性。</span></p><p id="u0a5e5764" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">解决这个问题的关键在于风险可控和任务隔离。常见的做法包括：</span></p><p id="uea2dd403" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">第一，合理设置线程池的核心线程数、最大线程数和任务队列长度，确保在正常负载下不会轻易触发拒绝策略。</span></p><p id="uc7f21f99" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">第二，对于核心任务，尽量使用限流、降级、熔断等机制提前兜底，避免所有请求都压进线程池。</span></p><p id="ua0d12d3c" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">第三，可以为重要线程池设置更严格的容量限制，并使用监控告警及时发现线程池拥堵。</span></p><p id="u598afbfd" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">第四，如果业务允许，也可以考虑自定义拒绝策略，比如记录日志、异步入队重试、或发送报警通知。</span></p></details>
<details class="lake-collapse"><summary id="ue54e027f"><span class="ne-text" style="font-size: 16px">阻塞队列</span></summary><p id="ucdbe3062" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 的线程池中，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">阻塞队列（BlockingQueue）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">用于保存等待执行的任务。</span></p><p id="ucbc53543" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">第一，ArrayBlockingQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 这是一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">有界的、基于数组的队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，在创建时必须指定容量。它按先进先出（FIFO）顺序存储任务。</span><span class="ne-text" style="color: rgb(51, 51, 51)"> 由于队列容量固定，可以防止任务无限堆积，常用于生产环境中限制系统负载，是最推荐的一种阻塞队列。</span></p><p id="u9809ce61" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">第二，LinkedBlockingQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 这是一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">基于链表的队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，可以选择有界也可以无界。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Executors.newFixedThreadPool()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 默认使用的就是它。</span><span class="ne-text" style="color: rgb(51, 51, 51)"> 它的特点是队列默认容量非常大（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Integer.MAX_VALUE</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">），如果不设上限，任务可能会在高并发下不断堆积，最终导致内存溢出。实际使用时应避免无界，建议手动设定合理上限。</span></p><p id="u053e113a" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">第三，SynchronousQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 这是一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不存储元素的队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，每一个 put 操作必须等待一个 take，任务不会进入队列，而是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">直接交给线程执行</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span><span class="ne-text" style="color: rgb(51, 51, 51)"> 这种队列通常与 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">maximumPoolSize</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 搭配使用，适合任务非常短、非常频繁、线程创建成本较低的场景。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Executors.newCachedThreadPool()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 就使用了它。</span></p><p id="u3627008f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">第四，PriorityBlockingQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 这是一个支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">任务优先级排序</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的队列，元素需要实现 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口或提供自定义 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Comparator</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span><span class="ne-text" style="color: rgb(51, 51, 51)"> 线程池根据任务优先级调度执行，适合对任务有强优先级要求的场景，比如调度系统、限速队列等。</span><span class="ne-text" style="color: rgb(51, 51, 51)"> 但要注意，它是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">无界的</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也可能导致内存溢出，需谨慎使用。</span></p><ul class="ne-ul"><li id="u88274217" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">ArrayBlockingQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：常用、有界、安全，推荐；</span></li><li id="u66c89dd8" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">LinkedBlockingQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：默认无界，使用时应设上限；</span></li><li id="u4927ae76" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">SynchronousQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：无队列，适合高并发短任务；</span></li><li id="uc7d111ac" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">PriorityBlockingQueue</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：支持优先级，适合调度型场景。</span></li></ul></details>
## 关键字/并发类/工具
### <font style="color:rgb(51, 51, 51);">volatile</font>
<details class="lake-collapse"><summary id="u31e8ebb4"><span class="ne-text" style="color: rgb(51, 51, 51)">volatile 是什么，怎么解决可见性问题，保证原子性操作吗，能保证线程安全吗</span></summary><p id="ub80910af" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 中一种轻量级的内存同步机制，用于修饰变量，确保变量的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可见性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">和</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">禁止指令重排序</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。然而，它并不保证操作的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">原子性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="uc79b153a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 中，每个线程都有自己的工作内存，当线程操作一个变量时，首先会从主内存拷贝该变量的副本到工作内存，线程只会操作工作内存中的副本，最后在合适的时候将结果刷新回主内存。如果没有适当的同步机制，可能导致多个线程读取到的变量值不同，从而出现可见性问题。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 通过确保线程写入变量时，会立刻将其更新到主内存，并且线程每次读取时，都会从主内存中获取最新的值，从而解决了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可见性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">问题。</span></p><p id="ue753fc6d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">为了提高性能，计算机可能对程序指令进行重排序，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 可以禁止对带有 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 变量的写操作和后续读操作的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">重排序</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，确保这些操作按顺序执行。当一个变量被声明为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 时，Java 编译器和 CPU 会在它的读写操作前后插入特定的内存屏障。</span></p><p id="u51511a70" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">然而，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 并不保证</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">原子性操作</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。比如对 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 变量的递增操作（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">++</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）可能仍然会出现竞态条件，因为它涉及多个步骤：读取、修改和写入。因此，仍然需要 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或其他机制来保证原子性。</span></p><p id="u25d41b65" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的底层实现依赖于 Java 内存模型（JMM），</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">通过内存屏障来确保变量的可见性和禁止指令重排序。</span></strong></p><p id="ub28c5082" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">volatile关键字可以保证可见性，但不能保证原子性，因此</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不能完全保证线程安全</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p></details>
### <font style="color:rgb(51, 51, 51);">synchronized</font>
<details class="lake-collapse"><summary id="u2d05ffdf"><span class="ne-text">synchronized 是什么，有什么用法</span></summary><p id="u35f34973" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 中最基本的线程同步机制，用于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">保证多线程环境下对共享资源的互斥访问</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。它可以修饰方法或代码块，达到加锁的效果，从而避免线程安全问题。</span></p><p id="u4d53fa04" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 主要有三种</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">用法</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></p><ol class="ne-ol"><li id="ud95bf568" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">修饰实例方法：锁的是当前对象（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">this</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">），保证同一实例的同步。</span></li><li id="ueaf9088f" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">修饰静态方法：锁的是类对象（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Class</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">），适用于类级别的同步。</span></li><li id="u3760de7a" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">修饰代码块：可以指定任意对象作为锁，更加灵活，适合控制粒度。</span></li></ol><div class="ne-quote"><p id="u82d26fe3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">构造方法不能使用 synchronized 关键字修饰。不过，可以在构造方法内部使用 synchronized 代码块。</span></p><p id="u20639878" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">另外，构造方法本身是线程安全的，但如果在构造方法中涉及到共享资源的操作，就需要采取适当的同步措施来保证整个构造过程的线程安全。</span></p></div></details>
<details class="lake-collapse"><summary id="ud6f94d5c"><span class="ne-text">synchronized 的原理是什么</span></summary><p id="u16174f4d" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 提供的内置锁机制，它的底层原理主要依赖于 JVM 的实现，特别是在 HotSpot 虚拟机中，锁是通过</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">对象头中的 Monitor（监视器）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">来实现的。</span></p><p id="u61dc6f23" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，从编译层面来看，当我们使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 修饰代码块或方法时，Java 编译器会在字节码中生成两条指令：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">monitorenter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">monitorexit</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，分别对应加锁和释放锁的操作。JVM 在运行时会通过这两个指令来管理锁的获取和释放。</span></p><p id="u2a0f77b7" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从运行时角度来看，每个对象在内存中都有一个对象头，其中包含了一块叫做 Mark Word 的区域，它记录了对象的哈希码、GC信息以及锁标志位。当线程尝试进入同步代码块时，会先查看这个对象头的锁状态，并尝试通过 CAS 操作去获取锁。如果获取失败，根据当前锁的状态，可能会进入自旋或者阻塞等待。</span></p><p id="u9fb5ef5c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">为了提升锁的性能，HotSpot JVM 在 JDK 1.6 开始引入了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">锁优化机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，将锁分为四种状态：</span></p><ol class="ne-ol"><li id="u6b3b395e" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">无锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：初始状态，无任何线程竞争；</span></li><li id="ucf72eb27" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">偏向锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当只有一个线程访问同步块时，会将锁偏向该线程，之后这个线程进入同步块时不再进行 CAS 操作；</span></li><li id="ufc50a22d" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">轻量级锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当多个线程尝试竞争偏向锁时，偏向锁会升级为轻量级锁，线程通过自旋方式尝试获取锁，避免了线程挂起和恢复的开销；</span></li><li id="ue3d71009" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">重量级锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当自旋失败，竞争激烈时，锁会升级为重量级锁，其他线程会被挂起，等待唤醒。</span></li></ol><p id="ucadd85b2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这些锁的状态是根据竞争情况</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自动升级</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的，从偏向锁到轻量级锁再到重量级锁，但不会降级。这种策略是为了提高获得锁和释放锁的效率。</span></p><p id="ua131ecbb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最后，在内存语义方面，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 也保证了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可见性和有序性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。进入同步代码块之前，线程会将工作内存中的共享变量值清空，从主内存中重新读取；退出同步块时会将修改后的值刷新回主内存，从而保证了线程之间数据的可见性。</span></p></details>
<details class="lake-collapse"><summary id="u916e9484"><span class="ne-text">synchronized 的锁升级</span></summary><p id="u886ff5ed" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的底层锁是依靠 JVM 对象头中的 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Mark Word</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现的。为了提升性能，它使用了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">偏向锁 → 轻量级锁 → 重量级锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的锁升级机制，按需逐步升级，避免一开始就进入重量级操作。</span></p><p id="ubf120f3a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">锁升级过程如下：</span></p><ol class="ne-ol"><li id="u3b2692b6" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">偏向锁（Biased Lock）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当一个线程第一次获取锁时，会在对象头记录线程 ID，以后这个线程再次进入同步块时，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不需要加锁或 CAS 操作</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，直接通过对象头判断是不是自己，性能最好。适用于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">无竞争的场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li><li id="u6b7b1e6e" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">轻量级锁（Lightweight Lock）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当有另一个线程尝试获取偏向锁时，偏向锁会</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">撤销并升级为轻量级锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，此时 JVM 通过 CAS 尝试将锁记录放入线程栈，如果成功，表示仍无锁竞争；如果失败，说明有多个线程争用，进入下一阶段。</span></li><li id="ubb48c2e7" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">重量级锁（Heavyweight Lock）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当多个线程竞争加锁且 CAS 失败，就会将锁升级为重量级锁，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程进入阻塞状态，依赖操作系统的互斥量实现线程挂起和唤醒</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，性能开销最大。</span></li></ol><p id="u9c3ab6c1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">整个过程是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不可逆的升级</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，一旦进入重量级锁就不会退回偏向锁或轻量级锁。</span></p></details>
<details class="lake-collapse"><summary id="u6c011d59"><span class="ne-text" style="font-size: 16px">和 </span><span class="ne-text" style="color: rgb(51, 51, 51)">volatile 有什么区别</span></summary><p id="u27977664" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字是两个互补的存在，而不是对立的存在</span></p><ul class="ne-ul"><li id="ufc77791a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字是线程同步的轻量级实现，所以 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">性能肯定比</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">关键字要好 。但是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字只能用于变量而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字可以修饰方法以及代码块 。</span></li><li id="u1b494dec" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字能保证数据的可见性，但不能保证数据的原子性。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字两者都能保证。</span></li><li id="u1dcf1444" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">关键字主要用于解决变量在多个线程之间的可见性，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字解决的是多个线程之间访问资源的同步性</span></li></ul></details>
<details class="lake-collapse"><summary id="u81bfdfcf"><span class="ne-text" style="color: rgb(51, 51, 51)">和 ReentrantLock 有什么区别</span></summary><p id="u0eae9701" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，从实现层面来说，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 的一个关键字，由 JVM 层面直接支持。它的加锁和释放锁操作是由编译器和虚拟机自动控制的，使用起来比较简单。我们只需要加在方法或者代码块上，就能实现互斥访问。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是一个显示锁，属于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.util.concurrent.locks</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 包，它是基于 AQS（AbstractQueuedSynchronizer）框架实现的，锁的获取和释放都需要我们手动操作。</span></p><p id="ub8b11680" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次，在功能方面，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 提供了比 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 更丰富的控制能力。例如，它支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可中断锁获取</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也就是说线程在等待锁的过程中可以响应中断；还支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">限时尝试加锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">tryLock()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法可以设置超时时间，这在一些高并发场景中非常有用。此外，它还支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">公平锁机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，我们可以通过构造函数指定锁是公平的还是非公平的。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是非公平的，线程获取锁的顺序无法控制。</span></p><p id="u1f019c04" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">再者，在等待通知机制上，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 提供了一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Condition</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类，可以创建多个条件变量，用于更细粒度的线程控制。而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 只能依赖对象的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">wait()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">notify()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，且每个对象只能有一个条件队列，控制能力比较弱。</span></p><p id="u0d95f1b4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最后，从性能角度看，早期的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 性能较差，但自从 JDK 1.6 引入了偏向锁、轻量级锁等优化后，它的性能已经大幅提升。在低竞争或短时间加锁的场景下，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的性能和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是相当的。而在复杂并发场景中，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 通常更有优势，因为它支持非阻塞的锁获取方式，可以减少线程切换和上下文开销。</span></p><p id="uaf406c8d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">总结来说，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 更适合结构简单、对性能要求不高的场景，使用方便、易于维护；而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 则适用于并发更复杂、需要更强控制力的场合，比如可中断、限时、公平锁或多个等待条件等需求。</span></p></details>
### <font style="color:rgb(51, 51, 51);">ReentrantLock</font>
<details class="lake-collapse"><summary id="u5890d57b"><span class="ne-text" style="color: rgb(51, 51, 51)">ReentrantLock 是什么</span></summary><p id="u18312a45" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 中 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.util.concurrent.locks</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 包下的一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可重入独占锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，它提供了比 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 更加灵活和强大的线程同步机制。</span></p><p id="u14781cf4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的核心功能类似，都是用来实现</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程间的互斥访问</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，但它提供了更多高级特性，包括：</span></p><ol class="ne-ol"><li id="u9f3d62f2" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可重入性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：同一个线程可以重复获取同一把锁，不会死锁。</span></li><li id="u268200e1" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可中断锁获取</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：可以调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">lockInterruptibly()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来实现响应中断，避免死等。</span></li><li id="u72cf347e" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">限时尝试加锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">tryLock()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 设置超时时间，控制等待时间。</span></li><li id="u621e9e6a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">公平锁与非公平锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：构造函数可以传入 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">true</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 创建公平锁，先来先得，默认是非公平锁，性能更好。</span></li><li id="ua2df6059" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">结合 Condition 使用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：可以创建多个条件队列（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">newCondition()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">），实现类似 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Object.wait/notify</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的机制，但更灵活。</span></li></ol><p id="u2ae07411" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从底层实现来看，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 基于 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">AQS（AbstractQueuedSynchronizer）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，通过一个</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">FIFO 等待队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">管理线程的排队和唤醒，内部依赖 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">CAS + 自旋 + 阻塞机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现高效的线程调度。</span></p><p id="u68c79197" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">相比 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">synchronized</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 更适合高并发或复杂线程控制场景，例如需要超时控制、公平策略或多个条件队列的情况。但要注意，它</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">必须手动释放锁</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，一般建议用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">try-finally</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 块包裹，防止死锁。</span></p></details>
### ThreadLocal
<details class="lake-collapse"><summary id="u9deca2ae"><strong><span class="ne-text">ThreadLocal 是什么，有什么用</span></strong></summary><p id="u3ffe43e4" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 提供的一种线程本地变量工具，它的作用是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为每个线程提供一份独立的变量副本</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，从而避免多线程访问共享变量时产生的线程安全问题。</span></p><p id="u13ca993f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">简单来说，通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，每个线程访问的变量都是它自己私有的，互不干扰。它非常适合用于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程范围内共享但线程之间隔离的场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，比如用户会话信息、数据库连接、事务管理等。</span></p><hr id="aenSn" class="ne-hr"><p id="u2ceebb0a" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程隔离</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：ThreadLocal为每个线程提供了独立的变量副本，这意味着线程之间不会相互影响，可以安全地在多线程环境中使用这些变量而不必担心数据竞争或同步问题。</span></p><p id="u1cf9bdd3" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">降低耦合度</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：在同一个线程内的多个函数或组件之间，使用ThreadLocal可以减少参数的传递，降低代码之间的耦合度，使代码更加清晰和模块化。</span></p><p id="u7a0a32e1" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">性能优势</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：由于ThreadLocal避免了线程间的同步开销，所以在大量线程并发执行时，相比传统的锁机制，它可以提供更好的性能。</span></p></details>
<details class="lake-collapse"><summary id="u2a9400f5"><strong><span class="ne-text">ThreadLocal 的实现原理</span></strong></summary><p id="ua9153042" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它的底层原理并不是把数据放在 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象里，而是将数据</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">存储在线程内部</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。具体来说，每个线程内部都有一个专门的结构，叫做 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocalMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，这是一个专门用于存储当前线程的本地变量副本的特殊哈希表。这个表的键是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实例本身，值就是线程自己对应的数据。</span></p><p id="ub369eaf2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当我们调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal.set()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法时，其实就是把数据存进了当前线程自己的那张表里；而调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">get()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法时，系统就会从这张表中查找与当前 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实例对应的值。也就是说，虽然所有线程共享同一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象，但它们访问的是自己线程内部的数据，因此互不影响。</span></p><p id="u5027ae61" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这个设计的最大特点是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">隔离性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：每个线程只访问自己的变量副本，没有共享，不需要加锁，从根本上避免了线程安全问题。</span></p><p id="udd5ebc0b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">不过，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocalMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 有一个值得注意的点：它的键是一个弱引用，也就是说，如果某个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象没有被外部强引用持有，那么它的键会被垃圾回收，而它对应的值还会残留在线程内部，导致内存泄漏。这个问题在使用线程池时尤其明显，因为线程会被复用，如果变量没被清理，可能影响后续线程的执行。因此在使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 后，建议手动调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，及时清理变量。</span></p><p id="u6dc14a8a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">此外，Java 还提供了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InheritableThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，它允许子线程继承父线程的变量副本，适合用于线程间传递一些上下文信息，比如用户身份、请求 ID 等。</span></p></details>
<details class="lake-collapse"><summary id="u10e9bb1d"><strong><span class="ne-text">ThreadLocal 的内存泄露问题</span></strong></summary><p id="u11fcc324" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 可能导致</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内存泄露</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，主要是因为它底层使用的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocalMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 中，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">key 是弱引用，value 是强引用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，而且这个 map 是保存在线程对象内部的。</span></p><p id="ua8d4faaa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">具体来说，当我们创建一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 变量并使用后，如果外部代码没有强引用再指向这个变量，那么 JVM 会在下一次垃圾回收时</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">回收掉这个弱引用的 key</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，但是由于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocalMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 中的 value 是强引用，它不会被自动回收，就会变成一个“key 为 null，value 还存在”的残留对象。</span></p><p id="ue243f38b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">更关键的是：这个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocalMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是存在线程对象里的，而</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">线程对象本身不会被回收，尤其在线程池中会被长时间复用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，这就导致那些 key 为 null 的 value 长期留在内存里，形成内存泄露。</span></p><p id="ue9451aa2" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">正确做法：</span></strong></p><p id="ud8708681" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ThreadLocal</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 时，务必在使用完毕后手动调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">remove()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，清除当前线程中的变量，释放引用，防止内存泄漏。</span></p></details>
### AQS
<details class="lake-collapse"><summary id="u0bb18de8"><span class="ne-text" style="font-size: 16px">AQS 是什么，原理是什么</span></summary><p id="u50d53c30" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">AQS，全称是 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">AbstractQueuedSynchronizer</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，是 Java 并发包 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.util.concurrent.locks</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 下的一个抽象类。它是构建</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">锁和同步器的核心基础框架</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，底层支撑了 ReentrantLock、Semaphore、CountDownLatch、ReadWriteLock 等多种并发工具。</span></p><p id="u106b59be" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">AQS 的核心思想是：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">将同步状态的管理与线程排队逻辑分离</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，并通过一个 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">FIFO 双向队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">来管理获取锁失败的线程。</span></p><p id="uc29f6a8e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它内部维护了一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类型的变量，叫做</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">同步状态（state）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，用于表示资源的占用情况。比如：独占锁会将 state 为 0 表示未被占用，1 表示占用；共享锁可能用大于 0 的值来表示剩余许可。</span></p><p id="u977c2779" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">线程在尝试获取锁时，如果资源可用，AQS 会通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CAS</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 操作尝试修改 state 值；如果失败，则会将当前线程封装成一个节点加入</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">等待队列（CLH 队列）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，然后阻塞挂起。</span></p><p id="u1c535429" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">一旦资源释放，AQS 会从队列中唤醒下一个等待线程，重新尝试获取锁，从而实现公平或非公平的线程调度。</span></p><p id="u142e5649" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">AQS 提供了两种模式：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">独占模式（Exclusive）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">共享模式（Shared）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。独占模式下，同一时刻只能有一个线程持有资源，比如 ReentrantLock；共享模式下，允许多个线程共享资源，比如 Semaphore 和 ReadWriteLock 的读锁。</span></p><h3 id="b6724cff"><span class="ne-text" style="color: rgb(51, 51, 51)">原理</span></h3><p id="ua0db9f06" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">AQS 的核心原理可以总结为三点：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">同步状态管理、CLH 队列维护、线程阻塞与唤醒机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="ufa4e8b2d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，AQS 通过一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">volatile int state</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 变量来表示共享资源的状态。线程要想获取锁，必须先尝试修改这个 state。修改通常是通过 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">CAS（Compare-And-Swap）原子操作</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">完成的，确保在并发场景下能安全地竞争资源。</span></p><p id="u83f96f6d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">如果线程获取 state 成功，就说明资源可用，它可以继续执行；如果失败，说明资源当前不可用，线程就会被封装成一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Node</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 节点，加入到 AQS 内部维护的一个 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">双向 FIFO 队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">中，这个队列本质上是一个变种的 CLH 队列（即链式等待队列）。</span></p><p id="ua9106909" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">排队的线程并不会自旋消耗 CPU，而是通过调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LockSupport.park()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法被</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">挂起阻塞</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，直到前驱节点释放资源并显式调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">unpark()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 唤醒它。</span></p><p id="u38642e2d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当锁释放时，线程会调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">release()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，AQS 会将 state 设置为可用状态，并从等待队列中唤醒下一个节点所代表的线程。唤醒后，它再重新尝试获取锁，直到成功为止。</span></p><p id="u34888b76" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">AQS 支持两种资源获取模式：</span></p><ul class="ne-ul"><li id="ue96f8c55" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">独占模式（Exclusive）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：同一时刻只有一个线程能获取资源，典型代表是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ReentrantLock</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li><li id="u42af24e1" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">共享模式（Shared）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：多个线程可以同时获取资源，如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Semaphore</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和读写锁中的读锁。</span></li></ul><p id="u1d569d64" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这两种模式下，AQS 会调用不同的模板方法来处理，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">tryAcquire</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">/</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">tryRelease</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 用于独占模式，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">tryAcquireShared</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">/</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">tryReleaseShared</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 用于共享模式。开发者只需要继承 AQS，并实现这些关键方法，就能构建出各种自定义同步工具。</span></p><p id="u6944f3a3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">总结一下，AQS 的原理是： 通过一个原子变量控制同步状态，失败则排队等待；队列基于 CLH 实现，线程通过 park 阻塞、unpark 唤醒；并提供独占与共享两种访问控制模式，支撑了大多数 JUC 锁与同步器的实现。</span></p></details>
### 并发容器
<details class="lake-collapse"><summary id="u6f9bc6ce"><span class="ne-text" style="font-size: 16px">并发容器有哪些</span></summary><ol class="ne-ol"><li id="uf67b774a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(44, 62, 80)">ConcurrentHashMap</span></strong><span class="ne-text" style="color: rgb(44, 62, 80)">：线程安全的哈希表，支持高并发读写操作。</span></li><li id="u0f598d96" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(44, 62, 80)">CopyOnWriteArrayList</span></strong><span class="ne-text" style="color: rgb(44, 62, 80)">：写时复制的 ArrayList，适用于读多写少的场景。</span></li><li id="ue8a9092c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(44, 62, 80)">BlockingQueue</span></strong><span class="ne-text" style="color: rgb(44, 62, 80)">：阻塞队列，常用实现有 ArrayBlockingQueue 和 LinkedBlockingQueue，适用于生产者-消费者场景。</span></li><li id="u82c185ed" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(44, 62, 80)">ConcurrentLinkedQueue</span></strong><span class="ne-text" style="color: rgb(44, 62, 80)">：非阻塞的线程安全队列。</span></li><li id="uc82ade82" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(44, 62, 80)">ConcurrentSkipListMap</span></strong><span class="ne-text" style="color: rgb(44, 62, 80)">：基于跳表实现的线程安全有序 Map。</span></li></ol></details>
---

