- [x] Java 基础
- [x] 数据类型
- [x] 面向对象编程
- [x] Java 机制
- [ ] Java IO
- [ ] 新特性
- [ ] 其他

## Java 基础
### Java 语言
<details class="lake-collapse"><summary id="ua177dcc0"><span class="ne-text" style="font-size: 16px">Java 的优点 和 缺点</span></summary><p id="u41e25c23" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">平台无关性强</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。Java 程序编译后生成字节码，可以在任何安装了 Java 虚拟机（JVM）的平台上运行，实现了“</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">一次编写，处处运行</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">”的跨平台能力。</span></p><p id="u2231ff1c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次，Java 是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">面向对象的语言</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，支持封装、继承、多态，有利于代码复用和模块化管理，提升系统的可维护性。</span></p><p id="u3673f5b4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三，Java 拥有</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">丰富的类库和强大的生态系统</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，涵盖网络编程、多线程、数据库访问、分布式开发等各个领域，适合构建各类企业级应用。</span></p><p id="uf3718b3c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">此外，Java 具备</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自动内存管理和垃圾回收机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，降低了内存泄漏和指针错误的风险，提升了程序的稳定性和安全性。</span></p><p id="udbd7c911" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最后，Java 支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">多线程编程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，并发能力强，特别适用于高并发、高可靠性的服务端开发。</span></p><hr id="rjGUG" class="ne-hr"><p id="u5e60a894" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">首先，Java的内存占用较高，JVM启动时间较长</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。由于JVM的运行时开销和对象模型设计，Java程序通常消耗更多内存；并且由于类加载和JIT预热过程，JVM的启动时间较长，这使得Java不太适合短生命周期的任务。（因资源限制，Java不适合嵌入式系统）</span></p><p id="u87babaf4" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">其次，Java的语法设计存在一定的局限性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。例如需要手动编写Getter/Setter、匿名内部类等样板代码。同时，Java对函数式编程的支持较弱，模式匹配、值类型等特性直到较新版本才逐步引入，导致在某些场景下开发效率不如其他语言。</span></p><p id="u6bbe593d" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">第三，Java在实时性和底层控制方面存在不足。</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> Java 的 GC（垃圾回收）会在系统运行时自动触发，会暂停所有线程，这就可能导致关键任务延迟执行。另外Java无法直接操作内存，能直接操作硬件寄存器、中断等底层资源，这使得它不适合开发操作系统、驱动程序等需要精细内存管理的底层软件。</span></p></details>
<details class="lake-collapse"><summary id="u3372abb4"><strong><span class="ne-text" style="font-size: 16px">跨平台</span></strong></summary><p id="uef6ff12e" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Java的跨平台能力主要基于JVM（Java虚拟机）和&quot;一次编写，到处运行&quot;的设计理念</span></strong></p><p id="u855c57bd" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，Java编译器把程序编译成.class</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">字节码</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">文件，这种字节码是平台无关的中间表示，相当于在源代码和机器指令之间增加了一个抽象层。</span></p><p id="u2ee87b62" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">每个操作系统平台都有对应的JVM实现</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。JVM负责将统一的字节码JIT编译或解释执行为当前系统的本地机器指令。</span></p><p id="u433685ca" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，Java通过严格规范确保</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">所有JVM实现遵循相同的行为标准</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，包括统一的内存模型、一致的类加载机制、标准的核心类库。</span></p></details>
<details class="lake-collapse"><summary id="u61b7726d"><span class="ne-text" style="font-size: 16px">编译与运行并存</span></summary><p id="u730a9ada" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java 程序</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">先编译成字节码（编译）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，运行时再由 JVM </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">解释执行或 JIT 编译执行（解释+编译）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，同时具备解释型语言和编译型语言的特性。</span></p><p id="u69f6b4bc" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">设计</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上讲：</span></p><p id="ubef52494" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">字节码</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">使得 Java 程序能跨平台，不同平台只需要实现自己的 JVM，就可以运行相同的字节码。</span></p><p id="uae37a8ad" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">解释执行</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">让程序可以快速启动，不需要等待全部编译完。</span></p><p id="uc821a024" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JIT 编译</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">让热点代码运行时能更高效，避免纯解释执行的性能瓶颈。</span></p></details>
<details class="lake-collapse"><summary id="u81c5c27b"><span class="ne-text" style="color: rgb(51, 51, 51)">JVM、JDK、JRE</span></summary><p id="uda0be722" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1、</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JVM</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Java虚拟机</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</span></p><p id="ubdf612f4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2、</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JDK</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Java开发工具包</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</span></strong></p><p id="u28bd6b78" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3、</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JRE</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JRE不包含开发工具，只提供Java程序运行所需的运行环境。</span></strong></p></details>
### Java 关键字
<details class="lake-collapse"><summary id="u22b586c4"><strong><span class="ne-text" style="font-size: 16px">static</span></strong></summary><p id="u57d276b8" class="ne-p"><span class="ne-text">表示“静态的”，意思就是这个东西不依赖于对象，而是属于类本身。可以修饰静态变量，静态方法，静态代码块，静态内部类，接口的static方法（8+），接口中的变量默认都是static final的。</span></p><p id="u74125f8c" class="ne-p"><span class="ne-text">在类中</span><span class="ne-text">，</span><code class="ne-code"><span class="ne-text">static</span></code><span class="ne-text"> 方法是属于类的，可以通过类名直接调用，不需要实例化对象，也</span><span class="ne-text">不能被重写</span><span class="ne-text">，因为它不属于实例，不参与多态。</span></p><p id="u88f06aad" class="ne-p"><span class="ne-text">在接口中（Java 8+），允许定义 </span><code class="ne-code"><span class="ne-text">static</span></code><span class="ne-text"> 方法，只能通过接口名调用，不能被实现类继承或重写，这主要是为了给接口提供一些工具方法。</span></p></details>
<details class="lake-collapse"><summary id="u91bc6041"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">final</span></strong></summary><p id="u288c45b6" class="ne-p"><code class="ne-code"><span class="ne-text">final</span></code><span class="ne-text"> 这个关键字在 Java 里主要是用来限制“修改”的，可以修饰变量、方法和类</span></p><p id="u4ebc9191" class="ne-p"><span class="ne-text">如果修饰变量，基本数据类型就表示值不能再变了，引用数据类型表示这个引用不能再指向别的对象，但对象本身的内容是可以改变的。</span></p><p id="u32504677" class="ne-p"><span class="ne-text">如果修饰方法，表示它不能被子类重写。比如，</span><code class="ne-code"><span class="ne-text">lang.Object</span></code><span class="ne-text">类的</span><code class="ne-code"><span class="ne-text">getClass</span></code><span class="ne-text">方法。因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。</span></p><p id="u70bca304" class="ne-p"><span class="ne-text">如果修饰类，表示不能被继承。比如，</span><code class="ne-code"><span class="ne-text">String</span></code><span class="ne-text">类是</span><code class="ne-code"><span class="ne-text">final</span></code><span class="ne-text">修饰的。</span></p></details>
<details class="lake-collapse"><summary id="u1eb749c1"><span class="ne-text" style="color: rgb(51, 51, 51)">transient</span></summary><p id="u27785646" class="ne-p"><code class="ne-code"><span class="ne-text">transient</span></code><span class="ne-text"> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 </span><code class="ne-code"><span class="ne-text">transient</span></code><span class="ne-text"> 修饰的变量值不会被持久化和恢复。</span></p><p id="u7fb7b614" class="ne-p"><span class="ne-text">关于 </span><code class="ne-code"><span class="ne-text">transient</span></code><span class="ne-text"> 还有几点注意：</span></p><ul class="ne-ul"><li id="u45119e42" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">transient</span></code><span class="ne-text"> 只能修饰变量，不能修饰类和方法。</span></li><li id="u1e09d625" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">transient</span></code><span class="ne-text"> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 </span><code class="ne-code"><span class="ne-text">int</span></code><span class="ne-text"> 类型，那么反序列后结果就是 </span><code class="ne-code"><span class="ne-text">0</span></code><span class="ne-text">。</span></li><li id="uf4721869" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">static</span></code><span class="ne-text"> 变量因为不属于任何对象(Object)，所以无论有没有 </span><code class="ne-code"><span class="ne-text">transient</span></code><span class="ne-text"> 关键字修饰，均不会被序列化。</span></li></ul></details>
### Java 对象
<details class="lake-collapse"><summary id="u62224112"><span class="ne-text" style="font-size: 16px">Java 创建对象的方式</span></summary><p id="u029bed85" class="ne-p"><span class="ne-text">1，使用</span><code class="ne-code"><span class="ne-text">new</span></code><span class="ne-text">关键字：最直接的创建方式，通过调用类构造方法完成内存分配和初始化。</span></p><p id="u50fadb84" class="ne-p"><span class="ne-text">2，</span><span class="ne-text">反射机制</span><span class="ne-text">：分为两种实现路径：</span></p><ul class="ne-ul"><li id="uf45de77f" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Class.newInstance()</span></code><span class="ne-text">：调用无参构造（JDK9已废弃，推荐Constructor方式）</span></li><li id="ub6c1e2fd" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Constructor.newInstance()</span></code><span class="ne-text">：支持带参构造，更灵活的反射实例化方案</span></li></ul><p id="u60a3579a" class="ne-p"><span class="ne-text">4，</span><span class="ne-text">使用clone()方法</span><span class="ne-text">：如果类实现了Cloneable接口，可以使用clone()方法复制对象。</span></p><p id="u9cbf8777" class="ne-p"><span class="ne-text">5，使用反序列化：通过</span><code class="ne-code"><span class="ne-text">ObjectInputStream</span></code><span class="ne-text">读取序列化字节流，绕过构造方法直接重建对象。要求类实现</span><code class="ne-code"><span class="ne-text">Serializable</span></code><span class="ne-text">接口，常用于网络传输和持久化场景。</span></p></details>
<details class="lake-collapse"><summary id="u78caa8ee"><strong><span class="ne-text" style="font-size: 16px">对象创建过程</span></strong></summary><p id="uc1d51d7b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当new一个对象的时候，JVM首先判断类是否已经加载，如果没有就加载，如果已经加载了，那么就会在 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">堆内存</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 中为这个对象分配内存，分配好内存后，JVM 会先对这块内存做默认初始化，比如 int 是 0，引用是 null 等，接下来会准备好 this 指针，把它绑定到刚才分配的那块内存上，进程初始化，执行父类的非静态变量和代码块、父类构造器、子类的非静态变量和代码块、子类构造器。最后返回这个对象在堆的引用。</span></p></details>
<details class="lake-collapse"><summary id="u5c1e181f"><span class="ne-text" style="color: rgb(51, 51, 51)">如何获取私有对象</span></summary><p id="ufdda121c" class="ne-p"><span class="ne-text">私有对象通常指的是类中被声明为</span><code class="ne-code"><span class="ne-text">private</span></code><span class="ne-text">的成员变量或方法，这些成员只能在其所在的类内部被访问。</span></p><p id="u4d7b16ce" class="ne-p"><span class="ne-text">但也可以通过下面两种方式来间接获取私有对象：</span></p><p id="u2ea7a70d" class="ne-p"><span class="ne-text">1，使用</span><span class="ne-text">公共访问器</span><span class="ne-text">方法（getter 方法）。</span></p><p id="ucd954d67" class="ne-p"><span class="ne-text">2，反射机制：反射机制允许在运行时检查和修改类、方法、字段等信息。</span></p></details>
### Java 类
<details class="lake-collapse"><summary id="u0a8ee2d9"><strong><span class="ne-text" style="font-size: 16px">类加载过程</span></strong></summary><p id="u05722a87" class="ne-p"><span class="ne-text">类加载是指 Java 程序在运行过程中，把 .class 文件加载到 JVM 中，并转化为 Class 对象的过程。</span></p><p id="ubd9b701c" class="ne-p"><span class="ne-text">1. 加载：JVM 通过类的全限定名查找 </span><code class="ne-code"><span class="ne-text">.class</span></code><span class="ne-text"> 文件，把它的字节码读取进内存，并创建一个 </span><code class="ne-code"><span class="ne-text">Class</span></code><span class="ne-text"> 对象。</span></p><p id="uf6b7d649" class="ne-p"><span class="ne-text">2. 验证：这一步是为了安全，检查这个字节码文件是否合法，比如语法结构、常量池是否合法、防止字节码被篡改等。</span></p><p id="ua45f661c" class="ne-p"><span class="ne-text">3. 准备：这个阶段会为类的静态变量分配内存，并设置默认值，比如 </span><code class="ne-code"><span class="ne-text">int</span></code><span class="ne-text"> 是 0，</span><code class="ne-code"><span class="ne-text">boolean</span></code><span class="ne-text"> 是 false。</span></p><p id="u5fe7c921" class="ne-p"><span class="ne-text">4. 解析：把类中的符号引用（就是类似类名、字段名这种字符串）替换为真正的地址引用（也就是指向内存的引用）。</span></p><p id="ub166022a" class="ne-p"><span class="ne-text">5. 初始化：这一步才是真正执行代码，比如执行 </span><code class="ne-code"><span class="ne-text">static</span></code><span class="ne-text"> 代码块，或者静态变量的赋值操作，这些代码只会执行一次。</span></p><p id="uc4c6c8f4" class="ne-p"><span class="ne-text">Java 类加载器采用的是双亲委派模型，意思是：一个类加载器在加载某个类时，先把请求交给它的父加载器，父加载器找不到，才由自己来加载。有两个好处，应该是避免重复加载，另一个是保证核心类的优先级。</span></p></details>
### 其他
<details class="lake-collapse"><summary id="ud5841533"><span class="ne-text" style="font-size: 16px">Java 是值传递，引用传递？</span></summary><p id="ue4e5c495" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java 是值传递</span></p><p id="u0a622ef2" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">方法调用时，传递的是变量中存储的值的副本</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，而不是变量本身。</span></p><p id="ub8729812" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">基本类型：传的是值的拷贝，方法里怎么改都不会影响原来的。</span></p><p id="u4e0f287a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">引用类型：传的是引用地址的拷贝，能通过这个地址修改对象的内容，但不能改原来的引用指向。</span></p></details>
<details class="lake-collapse"><summary id="u3539abb6"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">== vs equals</span></strong></summary><p id="ue2de9db8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">==是一个运算符，对于基本数据类型，表示对比值是否相等，对于引用数据类型，表示对比是否指向同一个对象，也就是在堆内存的内存地址是否相同</span></p><p id="u22be64b1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而equals是</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Obejct</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">类的方法，默认实现就是</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">return this == obj</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，也就是比较引用的地址，但是</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Object</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">作为所有类的直接或间接的父类，有些标准类都是重写了</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">equals</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">方法的，比如</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Integer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，用来比较对象的内容是否相等。</span></p></details>
<details class="lake-collapse"><summary id="u4088bac4"><span class="ne-text" style="color: rgb(51, 51, 51)">JMM vs JVM</span></summary><p id="u6851a9bf" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JVM</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是一个具体的虚拟机，它负责在特定的硬件和操作系统上运行 Java 程序。它包括内存管理、垃圾回收、执行字节码等多个方面。</span></p><p id="u0f009e58" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">JMM</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 语言的内存模型规范，它并不具体描述实现，而是提供了多线程编程中如何访问共享变量的规范，主要目的是确保并发编程中的线程安全。MM 主要定义了 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内存可见性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">原子性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">有序性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 三个方面的规则。</span></p></details>
<details class="lake-collapse"><summary id="u79e35ba7"><strong><span class="ne-text" style="font-size: 16px">深拷贝 浅拷贝</span></strong><span class="ne-text" style="font-size: 16px"> 引用拷贝</span></summary><p id="u7cdd1d38" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">浅拷贝仅复制对象本身及其中基本类型字段，对于引用类型字段则复制引用地址，新旧对象共享同一子对象。</span></p><p id="u7f77c69c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">深拷贝会递归复制对象及其所有引用字段指向的整个对象图，生成完全独立的副本。</span></p><p id="ua76a01b2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">引用拷贝是最基础的对象地址复制，仅产生指向原对象的新引用变量</span></p><hr id="C2Xwu" class="ne-hr"><p id="u9d6ed878" class="ne-p"><strong><span class="ne-text" style="font-size: 16px">深拷贝 vs 浅拷贝</span></strong></p><p id="uf8ace46c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">浅拷贝仅复制对象本身及其中基本类型字段，对于引用类型字段则复制引用地址，新旧对象共享同一子对象。深拷贝会递归复制对象及其所有引用字段指向的整个对象图，生成完全独立的副本。</span></p><p id="u78687f1a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">浅拷贝后新旧对象的引用类型字段指向同一个实例，修改任一对象的List都会影响另一个。深拷贝会创建全新的List实例及其所有元素副本，新旧对象完全隔离。</span></p></details>
<details class="lake-collapse"><summary id="u30a9a23a"><strong><span class="ne-text" style="font-size: 16px">序列化</span></strong><span class="ne-text" style="font-size: 16px">  Java 自带的序列化方式  序列化如何实现</span></summary><p id="u3b16ba8e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">序列化就是把 Java 对象转换成字节流的过程，方便把对象保存到磁盘、或者通过网络传输。反序列化就是把字节流恢复成原来的 Java 对象。</span></p><p id="uc8f35856" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">常见应用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：网络传输；存储到文件；存储到数据库；存储到内存；</span></p><p id="u4405bad9" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">OSI 七层协议模型中表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流，所以序列化协议对应于 TCP/IP 4 层模型的TCP/IP 协议应用层。</span></strong></p><p id="u24c2cfe1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">对于不想进行序列化的变量，使用 </span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">transient</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字修饰</span></p><p id="u5c02386e" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">常见的序列化协议</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</span></p><p id="u860b3bb6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</span></p><hr id="MVT8w" class="ne-hr"><h3 id="xiS2u"><span class="ne-text">Java 自带的序列化方式</span></h3><p id="u4fd5f644" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。</span></p><p id="ude882f59" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么不推荐使用 JDK 自带的序列化？</span></strong></p><ul class="ne-ul"><li id="uf2ec06e9" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">无法跨语言</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。</span></li><li id="uf16b123a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">容易被攻击</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：Java 序列化是不安全的，我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。</span></li><li id="u175c164b" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">序列化后的流太大</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。</span></li></ul><p id="u178b9334" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">我会考虑用主流序列化框架，比如FastJson、Protobuf来替代Java 序列化。</span></p><hr id="dlpFL" class="ne-hr"><h3 id="MqgNA"><span class="ne-text" style="color: rgb(51, 51, 51)">序列化如何实现</span></h3><p id="ud2962d56" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java 中，将对象转换为二进制字节流的过程叫做</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">序列化</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，主要是为了实现对象的持久化存储或跨网络传输。</span></p><p id="uc3d53dd2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">具体实现方式是：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">对象必须实现 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.io.Serializable</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，这只是一个标记接口，用来告诉 JVM 这个类的对象是可以被序列化的。然后，使用 Java 提供的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ObjectOutputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 将对象写出为字节流。</span></p><p id="uaeadf375" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">序列化的本质，是将对象的状态（即成员变量的值）转换为一组可以保存或传输的字节信息，写入文件或通过网络发送。接收端则通过反序列化将字节流还原为对象。</span></p><p id="ub41af59b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">需要注意的是，序列化不会保存 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">static</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">transient</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 修饰的字段，它们在反序列化时会被忽略。</span></p></details>
<details class="lake-collapse"><summary id="ud142e766"><span class="ne-text" style="color: rgb(51, 51, 51)">如何将对象从一个JVM转移到另一个JVM</span></summary><p id="u3686697b" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">对象跨JVM转移的核心方法</span></strong></p><ol class="ne-ol"><li id="u1d49862c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">对象序列化与反序列化</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">这是最常用的跨JVM对象传输方案。通过实现Serializable接口，可以将对象转换为字节序列，然后通过任意传输机制（如网络、文件）发送到另一个JVM后重建。Java原生序列化虽然简单，但存在性能较低、安全性等问题。实际开发中更推荐使用JSON、Protocol Buffers等跨语言序列化方案。</span></li><li id="uc1f376e4" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">RPC框架调用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">在分布式系统中，通过Dubbo、gRPC等RPC框架可以实现透明的对象传输。框架内部会处理序列化和网络通信细节，开发者只需像调用本地方法一样使用远程对象。这种方式适合生产环境，但需要引入额外依赖。</span></li><li id="u3584b7fd" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">分布式缓存/消息队列</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">使用Redis、Memcached等分布式缓存作为中转，或通过Kafka、RabbitMQ等消息队列传递序列化后的对象。这种方案具有松耦合特性，适合异步场景。</span></li><li id="u6fa920ce" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Java远程方法调用(RMI)</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">Java原生提供的RMI技术允许直接跨JVM调用方法，底层自动处理对象序列化和网络传输。但由于其强耦合性和防火墙穿透问题，现代项目中已较少使用。</span></li></ol></details>
<details class="lake-collapse"><summary id="ufaa538a5"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">equals() 和 hashCode()</span></strong></summary><p id="u9dc8b3d3" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">hashCode()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的作用是获取哈希码（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</span></p><p id="u26a4e935" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">hashCode()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 定义在 JDK 的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Object</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类中，这就意味着 Java 中的任何类都包含有 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">hashCode()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 函数。另外需要注意的是：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Object</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">hashCode()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</span></p><p id="u0e95f354" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么重写 equals() 时必须重写 hashCode() 方法？</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">Java 为了保证集合类在处理对象时能够正常工作，规定的一对规则：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">equals()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 判断对象相等时，两个相等的对象必须返回相同的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">hashCode()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 值。</span></p><hr id="sKzBm" class="ne-hr"><p id="u4c7775fc" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题?</span></strong></p><p id="u2f61e040" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1, </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">相同的键无法正确查找</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">:get失败，查不到值。你往 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 里放了一个对象当 key，然后你用另一个“内容一样”的对象去查，发现返回了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，查不到。</span></p><p id="u47769204" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">无法正确覆盖旧的键值对</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：put 不会覆盖，存重复 key。你往 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">HashMap</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 里放了一个 key，然后又放了一个“内容一模一样”的 key，理论上应该覆盖旧值，结果没覆盖，变成了两个 key 各自存在。</span></p></details>
<details class="lake-collapse"><summary id="u8198fd29"><span class="ne-text" style="color: rgb(51, 51, 51)">语法糖</span></summary><p id="u016e9fd1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">语法糖就是 Java 提供的一些语法层面的简化写法，让代码更简洁、更好读，但最终编译出来还是普通的底层代码。语法糖的存在主要是方便开发人员使用。但其实， Java 虚拟机并不支持这些语法糖，在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</span></p><p id="u5224419c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java 中最常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。</span></p><ul class="ne-ul"><li id="u9d6c6788" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">switch 支持 String 与枚举</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：本质上 String 会被转成 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">hashCode + equals</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，枚举会被转成 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ordinal()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 索引，编译器自动完成了这些逻辑。</span></li><li id="u80e2d93c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">泛型</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：编译器在编译期做类型检查、自动补上强转，运行期泛型信息被擦除，底层是原始类型操作（如 Object）。</span></li><li id="u57694fda" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自动装拆箱</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：编译器在编译时会自动把基本类型和包装类互相转换，底层调用的是如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Integer.valueOf()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">intValue()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 这些方法。</span></li><li id="u85a6ff9f" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可变长参数</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：方法传任意多个参数，编译器会把它转换成一个数组参数来处理。</span></li><li id="ua30f2c78" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">枚举</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：编译器会将 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">enum</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类转化为一个普通的类，并生成所有的常量、构造方法以及辅助方法（</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">values()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">valueOf()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 等），这让我们可以方便地使用枚举而不需要手动编写大量的常量和方法。</span></li><li id="uf7b312fc" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内部类</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：内部类、局部内部类、匿名内部类 都是语法糖。编译器会把它们拆成独立的类文件，并加上必要的外部类引用或构造函数参数。比如成员内部类会持有外部类的引用，匿名类会生成自动命名的类，局部变量也会被处理为 final 拷贝传入。</span></li><li id="uea7c8aaa" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">增强 for 循环</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：编译器会把它转成普通的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Iterator</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 遍历（如果是集合）或下标访问（如果是数组）。</span></li><li id="udd270517" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">try-with-resources</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：用来自动关闭资源，编译器会自动帮你加上 finally 和 close() 调用。</span></li><li id="u7b463dd2" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">lambda 表达式</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：用来简化函数式接口的写法。底层要么编译成匿名内部类，要么使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">invokedynamic</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">LambdaMetafactory</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 在运行时动态生成函数对象，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">本质仍然是函数式接口的实现类实例</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li></ul></details>
<details class="lake-collapse"><summary id="u9e0f592a"><span class="ne-text" style="color: rgb(51, 51, 51)">移位运算符</span></summary><h3 id="52b8c184"><span class="ne-text" style="color: rgb(51, 51, 51)">优点</span></h3><p id="u2d797c3a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1.高效：移位运算符直接对应于处理器的移位指令。现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。</span></p><p id="u4aab3d9b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2.节省内存：通过移位操作，可以使用一个整数（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">long</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）来存储多个布尔值或标志位，从而节省内存。</span></p><h3 id="fc2f2451"><span class="ne-text" style="color: rgb(51, 51, 51)">常用场景</span></h3><p id="u2d3c5050" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1.</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">快速乘以或除以 2 的幂次方</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：a &lt;&lt; n 即 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">a * 2ⁿ</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">；a &gt;&gt; n 即 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">a / 2ⁿ</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">（向下取整）；</span><span class="ne-text" style="color: rgb(51, 51, 51)">&gt;</span><span class="ne-text" style="color: rgb(51, 51, 51)">&gt;&gt; 即 无符号右移，忽略符号位，空位都以 0 补齐。</span></p><p id="uda57057f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2.</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">位字段管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：例如存储和操作多个布尔值。</span></p><p id="u4478d57c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3.</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">哈希算法和加密解密</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过移位和与、或等操作来混淆数据</span></p><p id="u9495ff60" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">4.</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">数据压缩</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：例如霍夫曼编码通过移位运算符可以快速处理和操作二进制数据，以生成紧凑的压缩格式。</span></p><p id="u8bf012e1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">5.</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">数据校验</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：例如 CRC（循环冗余校验）通过移位和多项式除法生成和校验数据完整性。</span></p><p id="u9376d527" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">6.</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内存对齐</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过移位操作，可以轻松计算和调整数据的对齐地址。</span></p><p id="u7a1b011f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">由于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">double</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">float</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 在二进制中的表现比较特殊，因此不能来进行移位操作。移位操作符实际上支持的类型只有</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">和</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">long</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，编译器在对</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">short</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">byte</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">char</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">类型进行移位前，都会将其转换为</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">类型再操作。</span></p><p id="u848cb426" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">如果移位的位数超过数值所占有的位数会怎样？</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。实际执行的是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">位数 % 数据类型位宽</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p></details>
## <font style="color:rgb(51, 51, 51);">数据类型</font>
### 基本数据类型
| **<font style="color:rgb(51, 51, 51);">类型</font>** | **<font style="color:rgb(51, 51, 51);">占用内存</font>** | **<font style="color:rgb(51, 51, 51);">默认值</font>** | **<font style="color:rgb(51, 51, 51);">范围/说明</font>** | **<font style="color:rgb(51, 51, 51);">使用场景</font>** |
| :--- | :--- | :--- | :--- | :--- |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">byte</font>` | <font style="color:rgb(51, 51, 51);">1 字节</font> | <font style="color:rgb(51, 51, 51);">0</font> | <font style="color:rgb(51, 51, 51);">-128 ~ 127</font> | <font style="color:rgb(51, 51, 51);">适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据。</font> |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">short</font>` | <font style="color:rgb(51, 51, 51);">2 字节</font> | <font style="color:rgb(51, 51, 51);">0</font> | <font style="color:rgb(51, 51, 51);">-2¹⁵ ~ 2¹⁵ - 1</font> | <font style="color:rgb(51, 51, 51);">通常用于在需要节省内存且数值范围在该区间的场景。</font> |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">int</font>` | <font style="color:rgb(51, 51, 51);">4 字节</font> | <font style="color:rgb(51, 51, 51);">0</font> | <font style="color:rgb(51, 51, 51);">-2³¹ ~ 2³¹-1</font> | <font style="color:rgb(51, 51, 51);">最常用，可满足大多数日常编程中整数计算的需求。</font> |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">long</font>` | <font style="color:rgb(51, 51, 51);">8 字节</font> | <font style="color:rgb(51, 51, 51);">0L</font> | <font style="color:rgb(51, 51, 51);">-2⁶³ ~ 2⁶³-1</font> | <font style="color:rgb(51, 51, 51);">用于表示非常大的整数，定义时数值后需加 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">L</font>`<font style="color:rgb(51, 51, 51);">或 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">l</font>` |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">float</font>` | <font style="color:rgb(51, 51, 51);">4 字节</font> | <font style="color:rgb(51, 51, 51);">0.0f</font> | <font style="color:rgb(51, 51, 51);">约 ±3.4e38，7 位精度</font> | <font style="color:rgb(51, 51, 51);">单精度浮点数，定义时数值后需加 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">F</font>`<font style="color:rgb(51, 51, 51);">或 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">f</font>` |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">double</font>` | <font style="color:rgb(51, 51, 51);">8 字节</font> | <font style="color:rgb(51, 51, 51);">0.0d</font> | <font style="color:rgb(51, 51, 51);">约 ±1.8e308，15 位精度</font> | <font style="color:rgb(51, 51, 51);">双精度浮点数，是 Java 中表示小数的默认类型。</font> |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">char</font>` | <font style="color:rgb(51, 51, 51);">2 字节</font> | <font style="color:rgb(51, 51, 51);">'\u0000'</font> | <font style="color:rgb(51, 51, 51);">单个 Unicode 字符</font> | <font style="color:rgb(51, 51, 51);">用于表示单个字符，采用 Unicode 编码。</font> |
| `<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">boolean</font>` | <font style="color:rgb(51, 51, 51);">1 位*</font> | <font style="color:rgb(51, 51, 51);">false</font> | <font style="color:rgb(51, 51, 51);">true / false</font> | <font style="color:rgb(51, 51, 51);">用于逻辑判断</font> |


<details class="lake-collapse"><summary id="u6febd5eb"><span class="ne-text" style="color: rgb(51, 51, 51)">数据类型转换方式</span></summary><p id="ua1d31fcc" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，自动类型转换：例如，将</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">转换为</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">long</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、将</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">float</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">转换为</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">double</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">等。</span></p><p id="uab4d0ffa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，强制类型转换：例如，将</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">long</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">转换为</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、将</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">double</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">转换为</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">等，可能导致数据丢失或溢出。</span></p><p id="u16366118" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，字符串转换：例如，将字符串转换为整型</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，可以使用</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Integer.parseInt()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">方法。</span></p><p id="ub7a4bf13" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">4，数值之间转换：例如，将整型转换为字符型、将字符型转换为整型等。通过类型的包装类来实现提供的相应的转换方法。</span></p></details>
### String
<details class="lake-collapse"><summary id="u2d92b679"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">String、StringBuilder、StringBuffer</span></strong></summary><p id="u33b659f7" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是不可变的。</span></p><p id="u6ecb1edb" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuilder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 与 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuffer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 都继承自 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AbstractStringBuilder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类，在 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AbstractStringBuilder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 中也是使用字符数组保存字符串，不过没有使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">final</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">private</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 关键字修饰，最关键的是这个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">AbstractStringBuilder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类还提供了很多修改字符串的方法比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">append</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法。</span></p><p id="u1c8624ee" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 中的对象是不可变的，也就可以理解为常量，线程安全。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuffer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuilder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 并没有对方法进行加同步锁，所以是非线程安全的。</span></p><p id="u7d6563e3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">每次对 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类型进行改变的时候，都会生成一个新的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象，然后将指针指向新的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuilder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">和</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuffer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 每次都会对对象本身进行操作，但是</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuffer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 有线程安全的开销。</span></p></details>
<details class="lake-collapse"><summary id="u8d0f2e8d"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">String为什么不可变？实现上？设计上？</span></strong></summary><p id="u5757489f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">存储结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">来看，String内部使用final修饰的字符数组（JDK9后改为byte[]）存储数据，这个数组不仅被final限定不可重新赋值，还被private修饰彻底封装，外部无法直接操作底层数据。</span></p><p id="uc3d3b1ed" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">类设计</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">层面，String类本身被final修饰形成终极防线，任何继承行为都被禁止，从根本上杜绝了通过子类覆写方法破坏不可变性的可能。</span></p><p id="u82e2e80f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最后从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">方法设计</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">角度，String没有提供任何会修改内部状态的方法，而StringBuilder和StringBuffer通过继承AbstractStringBuilder获得了修改能力，这种鲜明的对比恰恰凸显了String的不可变特性。</span></p><hr id="BSsUp" class="ne-hr"><p id="u2e49b992" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么设计成不可变的？</span></strong></p><p id="ue67d51d3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">安全性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上讲，当 String 对象作为参数传递或在多线程间共享时，由于其内容不可更改，完全避免了并发修改导致的数据竞争问题。这种特性在网络通信、安全认证等关键场景中尤为重要。</span></p><p id="u55702d2b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次在</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">性能优化</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">方面，JVM 可以基于此特性实现字符串常量池。同时 String 的 hashCode 可以被缓存，因为内容不变意味着哈希值永远有效，这极大提升了 HashMap 等集合类的操作效率。</span></p><p id="ud36c10b5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">设计哲学</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">层面，不可变 String 建立了明确的行为契约：任何字符串操作都保证返回新对象而非修改原对象。这种设计使 String 作为方法参数时，调用方无需担心内容被意外修改，大大提高了代码的可预测性。</span></p></details>
<details class="lake-collapse"><summary id="u4a4fe282"><span class="ne-text" style="font-size: 16px">字符串常量池</span></summary><p id="uaf08ba87" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。 </span></p><p id="u9d3ffe4d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">当你使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">new String(&quot;abc&quot;)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 时，实际上会发生两个步骤：</span></p><ol class="ne-ol"><li id="uada2c7d4" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">首先，字符串字面量 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">&quot;abc&quot;</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 会被检查是否在字符串常量池中</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。如果 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">&quot;abc&quot;</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 不在常量池中，它会被添加进去；如果已经在常量池中，直接复用常量池中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">&quot;abc&quot;</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></li><li id="ufd2d60fb" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">然后，</span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">new String(&quot;abc&quot;)</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 会创建一个新的 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></strong></code><strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，这个新的对象会指向常量池中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">&quot;abc&quot;</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 字符串。虽然它和常量池中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">&quot;abc&quot;</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 内容一样，但它是 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">一个新的对象</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">（存储在堆内存中）。</span></li></ol><p id="u15f61f73" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">所以，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">new String(&quot;abc&quot;)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实际上会</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">创建两个 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">&quot;abc&quot;</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：一个是存储在字符串常量池中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">&quot;abc&quot;</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">（如果之前没有的话）。另一个是存储在堆内存中的新 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象。</span></p><hr id="s1u98" class="ne-hr"><pre data-language="java" id="A3GmU" class="ne-codeblock language-java"><code>//字符串常量池
String s1 = &quot;hello&quot;; // &quot;hello&quot; 被加入常量池
String s2 = &quot;hello&quot;; // s1 和 s2 引用的是同一个对象
String s3 = new String(&quot;hello&quot;); // 通过 new 创建，指向堆内存，不在常量池中
String s4 = s1.intern(); // s4 仍然指向常量池中的 &quot;hello&quot;
String s5 = s1;// s5 仍然指向常量池中的 &quot;hello&quot;
//intern() 方法的作用是让你获得常量池中的字符串
//如果该字符串已经存在于常量池中，直接返回该对象；如果不存在，则将它添加到常量池。</code></pre></details>
<details class="lake-collapse"><summary id="ub7d42593"><span class="ne-text" style="font-size: 16px">String 的“+”和“equals”</span></summary><p id="u74722b73" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">String的 “ + ” </span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：字符串对象通过“+”的字符串拼接方式，实际上是通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringBuilder</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">append()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法实现的，拼接完成之后调用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">toString()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 得到一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">String</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 对象 。</span></p><p id="ue3281373" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">String的 “ equals ” </span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：检查是否是同一个对象; 检查传入的对象是否是 String 类型; 检查长度是否相等; for循环逐个字符比较。</span></p></details>
### <font style="color:rgb(51, 51, 51);">BigDecimal</font>
**<font style="color:rgb(51, 51, 51);">浮点数运算精度丢失</font>**<font style="color:rgb(51, 51, 51);">是因为计算机二进制存储数字，但是有些小数不能在有限位数里转化成二进制。所以就需要截断，导致精度丢失。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">BigDecimal </font><font style="color:rgb(51, 51, 51);">用字符串的形式存储小数位，以十进制方式精确表示每一位，适合做高精度运算，比如金额计算。</font>

### <font style="color:rgb(51, 51, 51);">BigInteger</font>
`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">BigInteger</font>`<font style="color:rgb(51, 51, 51);"> 内部使用 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">int[]</font>`<font style="color:rgb(51, 51, 51);"> 数组来存储任意大小的整形数据。可以用来存储超过long整型的数据。</font>

<font style="color:rgb(51, 51, 51);">相对于常规整数类型的运算来说，</font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">BigInteger</font>`<font style="color:rgb(51, 51, 51);"> 运算的效率会相对较低。</font>

### 包装类型
<details class="lake-collapse"><summary id="ue1bcaecf"><strong><span class="ne-text">包装类型 vs 基本数据类型</span></strong></summary><p id="u49bc5515" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">本质</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上讲，包装类是对象而基本类型是原始数据。包装类继承自Object，可以调用方法，而int等基本类型直接存储数值，没有面向对象特性。</span></p><p id="uf0b31c19" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">存储位置</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，基本数据类型作为方法局部变量时直接存储在虚拟机栈的栈帧中，访问速度最快；作为对象成员变量时则随对象实例存储在堆内存中；而静态的基本类型变量会被分配到方法区（元空间）；包装类对象则始终存储在堆内存中，Java对部分包装类实现了缓存优化，缓存在堆内存的特殊区域。</span></p><p id="u9a4ee543" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">默认值</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，基本类型有明确默认值（int为0），包装类默认值为null。</span></p><p id="uc8f30bc0" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">4，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">应用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，高频计算场景推荐使用基本类型（性能更好），而需要对象特性的场景（如集合存储、泛型使用）必须使用包装类。</span></p></details>
<details class="lake-collapse"><summary id="ub6d7baca"><strong><span class="ne-text">包装类的 缓存机制</span></strong></summary><p id="ueefb4eb5" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">JVM</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">会将常见的重复使用的对象进行复用，避免每次都创建新的对象，提高性能，减少内存使用。</span></p><p id="u3602017a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">比如Integer，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">JVM</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">会缓存</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">-128到127</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">的整数。调用</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Integer.valueOf(int)</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">的时候，如果传入的整数在这个范围，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">JVM</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">就返回一个已经创建好的共享对象，而不是在创建一个新的Integer对象。Boolean类型</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">JVM</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">只会缓存true和false两个值。</span></p><pre data-language="java" id="Bj1YM" class="ne-codeblock language-java"><code>//包装类的缓存机制
Integer i1 = 100; // 会从缓存池获取
Integer i2 = 100; // 同样会从缓存池获取，i1 和 i2 指向同一个对象
Integer i3 = 200; // 不会从缓存池获取，而是新建对象
Integer i4 = 200; // i3 和 i4 不是同一个对象</code></pre></details>
<details class="lake-collapse"><summary id="ue184f7b1"><span class="ne-text">包装类的 作用</span></summary><p id="u7f34acd2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">包装类的设计是为了解决</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">基本数据类型无法满足对象化操作需求</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">的问题</span></p><p id="ue680f7d6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，包装类使基本数据类型具备</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">面向对象特性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，使其可以调用方法、实现接口、参与多态等。</span></p><p id="ua7a0316f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，包装类使得基本数据类型能够以对象形式</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">存储在集合中</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，例如</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">List&lt;Integer&gt;</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><p id="u139e9ca2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">提供null值支持</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：基本数据类型不能表示&quot;无值&quot;状态（如数据库中的NULL），而包装类可以通过</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">null</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">来表示这种状态，</span></p><p id="uebfbd04d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">4，包装类</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">提供了许多静态方法</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，如</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Integer.parseInt()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Double.toString()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">等，方便进行数据类型转换和数值处理。</span></p><p id="u645f922d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">5，包装类是对象，可以参与</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">反射操作</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">和序列化/反序列化过程，而基本数据类型无法直接支持这些特性。</span></p><p id="u0670e6dd" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">6，部分包装类（如Integer、Long等）对特定范围内的值进行了</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">缓存优化</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">（如-128到127），提高了性能和内存使用效率。</span></p></details>
<details class="lake-collapse"><summary id="ub822e106"><strong><span class="ne-text">自动装箱与拆箱</span></strong></summary><p id="uad526d2f" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自动装箱</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是将基本数据类型转换为其对应的包装类的过程，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">拆箱</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">则是将包装类转换为基本数据类型的过程。这两个过程是由</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">编译器</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">自动完成的。装箱的时候</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">JVM</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">调用包装类的构造方法或 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">valueOf()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法，拆箱时会通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">xxxValue()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 方法（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Integer.intValue()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）获取基本数据类型的值。另外包装类的缓存机制会避免重复创建对象，提升性能。</span></p><p id="u9af5a118" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">但是频繁的装箱可能会导致性能问题，因为如果你的基本数据类型的大小超过了缓存机制的界限，那么就会不断产生新的对象，增加垃圾回收的压力。</span></p></details>
## 面向对象编程
<details class="lake-collapse"><summary id="u8effe396"><span class="ne-text">面向对象 vs 面向过程</span></summary><p id="u6f48e780" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">POP把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</span></p><p id="u535e8efa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">OOP关注的是对象和它们之间的互动，每个对象负责自己的行为，程序通过“对象”来组织和管理。</span></p><p id="ua4eba4be" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">相比较于 POP，OOP 开发的程序一般具有下面这些优点：</span></p><p id="u09d226fe" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">易维护</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：由于良好的结构和封装性，OOP 程序通常更容易维护。</span></p><p id="uaa9c2c6b" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">易复用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</span></p><p id="u3c637525" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">易扩展</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：模块化设计使得系统扩展变得更加容易和灵活。</span></p></details>
### 特性
<details class="lake-collapse"><summary id="u9c399bcc"><strong><span class="ne-text">三大特性</span></strong></summary><p id="ua15b1057" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先OOP的三大特性分别是封装，继承，多态。</span></p><p id="ua801d285" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">封装</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">就是把数据和方法封装起来，隐藏内部的实现细节，外部只能通过提供的接口访问和修改数据，并且封装还提供了访问修饰符来控制权限，进一步增强了安全性和灵活性。它强调的是安全性和可维护性。</span></p><p id="u4f368a92" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">继承</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">允许我们在已有类的基础上创建类，也就是子类继承父类的属性和方法，避免了代码的重复，提高了代码的复用性，它体现的是一个（is-a）的关系，存在耦合的问题，在实践中我们有”组合（has-a）优于继承“的设计思想。强调的是复用。</span></p><p id="u38e080c9" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">多态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是指”一个接口，多种实现“，分为运行时多态和编译时多态，多态让我们可以用统一的方式处理不同的对象，强调的是扩展性和灵活性。</span></p></details>
<details class="lake-collapse"><summary id="u45e4a638"><strong><span class="ne-text">重写 和 重载</span></strong></summary><p id="u68c6f46f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先在</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">定义</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，重载是指同一个类中存在多个同名方法，通过不同的参数列表进行区分；而重写是子类对父类方法进行重新定义，保持方法签名完全一致。</span></p><p id="uc06b704d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次在</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">作用范围</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，重载发生在同一个类内部，重写则是在父子类之间进行。重载关注的是方法调用的多样性，重写关注的是方法实现的差异性。</span></p><p id="ubdeb4c86" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三在</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">绑定时机</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，重载属于编译时多态，编译器在编译阶段就能确定调用哪个方法；重写属于运行时多态，需要等到程序运行时才能确定具体调用的方法实现。</span></p><p id="ua74e9bd3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第四在</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">方法签名要求</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，重载要求方法名称相同但参数列表必须不同；重写则要求方法名称、参数列表和返回类型都必须与父类方法保持一致。</span></p><p id="u025e7e6b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">最后在</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">访问权限</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，重载对方法的访问修饰符没有特殊要求；重写的方法访问权限不能比父类方法更严格，比如父类方法是protected，子类重写时就不能用private。</span></p></details>
<details class="lake-collapse"><summary id="udb4f47bb"><strong><span class="ne-text">多态体现在哪？解决了什么问题？</span></strong></summary><p id="udc6ff3c3" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">编译时多态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，主要通过方法重载机制实现。当类中存在多个同名方法但参数列表不同时，编译器在编译阶段就能确定具体调用的方法版本。</span></p><p id="u81d2c9aa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">运行时多态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，这是面向对象最核心的多态形式。通过方法重写机制，子类可以重新定义父类方法的实现。当父类引用指向子类对象时，JVM会根据对象实际类型动态绑定方法调用。这个特性依赖于虚方法表机制，每个类都会维护一个包含可调用方法地址的vtable。</span></p><p id="u532b8ac4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">接口多态</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，通过接口与实现类的关系实现。不同于类继承的单继承限制，一个类可以实现多个接口，每个接口方法在不同的实现类中可以有不同的行为表现。例如集合框架中的List接口与ArrayList、LinkedList等实现类的关系。</span></p><hr id="PJgQW" class="ne-hr"><p id="u76ce8bd2" class="ne-p"><span class="ne-text">多态主要解决了代码的“可扩展性”和“可维护性”问题，其核心是允许程序在运行时根据对象的实际类型来调用相应的方法。</span></p><p id="u9bab8ca8" class="ne-p"><span class="ne-text">1，创建子类继承父类---&gt;不需要再修改父类---&gt;开闭原则，可扩展性强</span></p><p id="u0dcd6a60" class="ne-p"><span class="ne-text">2，调用对象方法无需判断类型，</span><span class="ne-text" style="color: rgb(0, 0, 0)">代码逻辑清晰，消除了复杂的条件判断</span></p></details>
<details class="lake-collapse"><summary id="u503d8e03"><strong><span class="ne-text">抽象类 和 接口</span></strong></summary><p id="ud410cbc6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">抽象类是对一类事物的本质抽象，强调&quot;是什么&quot;的层次关系，可以有成员变量、构造方法和具体方法。接口是对行为的抽象，强调&quot;能做什么&quot;的能力约定，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。</span></p><p id="u52cd99fc" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">一个类只能继承一个抽象类，但可以实现多个接口。</span></p><p id="u2a44c4da" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">接口更强调行为标准的统一，而抽象类提供部分实现，强调代码的复用。</span></p></details>
### 变量、方法、内部类
<details class="lake-collapse"><summary id="u51199bcf"><span class="ne-text">静态变量 和 静态方法</span></summary><p id="u1c751927" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">静态变量</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">（也称为类变量）是在类中使用</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">static</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">关键字声明的变量。常用于需要在所有对象间共享的数据，如计数器、常量等。它们属于类而不是任何具体的对象。主要的特点：</span></p><p id="u80399421" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">共享性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</span></p><p id="uac01542b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">初始化</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：静态变量在类被加载时初始化，只会对其进行一次分配内存。</span></p><p id="ud09cd66f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">访问方式</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。</span></p><p id="uf1c3b596" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">静态方法是在类中使用</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">static</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。常用于助手方法、获取类级别的信息或者是没有依赖于实例的数据处理。主要的特点：</span></p><p id="udb5175ab" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">无实例依赖</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。</span></p><p id="u4cbd73f4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">访问静态成员</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</span></p><p id="uc3d184db" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">多态性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：：静态方法不支持重写（Override），但可以被隐藏（Hide）。</span></p></details>
<details class="lake-collapse"><summary id="u16fa9880"><span class="ne-text">非静态内部类 和 静态内部类</span></summary><p id="ubf1019ec" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">内部类是为了更好地组织代码结构，让逻辑上紧密关联的类写在一起，提高封装性和可读性。</span></p><p id="u707d82c6" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">非静态内部类和静态内部类的区别</span></strong></p><p id="u25932bf1" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">本质区别</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：非静态内部类持有外部类的隐式引用，可以直接访问外部类的所有成员；静态内部类不持有外部类引用，只能访问外部类的静态成员。</span></p><p id="u1a0736bc" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">实例化方式</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">上，非静态内部类必须通过外部类实例来创建；静态内部类可以直接实例化。</span></p><p id="u799b8590" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">内存管理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">方面，非静态内部类会导致外部类实例无法被GC回收，这在Android开发中容易引发Activity泄漏；静态内部类则不存在此问题。</span></p><p id="uff024664" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">应用场景上</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，非静态内部类适合紧密耦合的场景，如事件处理器需要访问UI组件状态。静态内部类更适用于工具类、Builder模式等独立功能实现。</span></p><hr id="GYpoG" class="ne-hr"><p id="u5a3af661" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">非静态内部类可以直接访问外部方法是因为</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</span></p><p id="u3ee76a9b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</span></p></details>
<details class="lake-collapse"><summary id="u11bf3823"><span class="ne-text">成员变量 和 局部变量</span></summary><p id="u5e5fb3f6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">成员变量就是你在类里面定义的、但不写在方法里的变量，它是属于对象或者类本身的。只要对象在，它就一直在；对象没了，它才跟着消失。比如你定义了一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int age</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 放在类里面，这就是成员变量。它有默认值，就算你不赋值，它也不是空的。</span></p><p id="ub811a023" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">而局部变量呢，是写在方法、代码块或者参数里的，比如你在一个方法里面写了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int count = 0;</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，这个就是局部变量。它只在方法执行时存在，用完方法就被销毁了。而且它</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">必须</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">赋值后才能用，不然编译都不会通过。</span></p><p id="ufd109943" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">还有一个区别是：成员变量可以加 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">public</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">private</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">static</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 这些修饰符，但局部变量不行，它不能有访问控制符，也不能是 static。</span></p><p id="u75fd80e1" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">为什么成员变量有默认值，局部变量没有？</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">成员变量是跟着对象走的，存在于堆内存里，一旦你创建了对象，JVM 就会自动帮你把这些变量都初始化成默认值，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">int</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 0，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">boolean</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 false，引用类型是 null。这样做的好处是让程序更安全——你用成员变量的时候，不会因为“没初始化”导致程序崩掉或行为异常。局部变量没有，它是跟着方法走的，存在于栈内存里。Java 不给它默认值，目的就是强制你自己先赋值，不然编译器直接报错。</span></p></details>
<details class="lake-collapse"><summary id="u8434b75f"><span class="ne-text" style="color: rgb(51, 51, 51)">静态方法为什么不能调用非静态成员?</span></summary><p id="ucbedb2b9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">静态方法属于类而不是实例，而非静态成员属于对象（实例）。</span></p><p id="u17c1675a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">静态方法在类加载时就可以访问，不依赖于类的具体实例。非静态成员只有在类的实例化对象存在时，才能访问。</span></p><p id="u98f31c6b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">静态方法没有</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">this</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">引用，不能访问与实例关联的成员。</span></p></details>
## Java 机制
### 异常
<details class="lake-collapse"><summary id="u7de5fcd5"><strong><span class="ne-text">Java 的异常机制</span></strong></summary><p id="u8a862318" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java异常处理机制为我们提供了一套完善的错误处理和恢复体系。Java中的异常都是Throwable类的子类，主要分为两大类：Error和Exception。</span></p><p id="ucb8f1b18" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Error</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">表示严重的系统错误，通常与程序逻辑无关，而是JVM运行时出现的问题，比如OutOfMemoryError或StackOverflowError。这类错误一般无法通过程序处理，只能尽量避免。</span></p><p id="uaff15dc8" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Exception</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">则是程序可以处理的异常，它又分为受检异常和非受检异常。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">受检异常</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">如IOException、SQLException等，编译器会强制要求我们处理这些异常，要么用try-catch捕获，要么在方法签名中用throws声明。这种设计确保了程序对可能发生的问题有明确的处理逻辑。</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">非受检异常</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">即RuntimeException及其子类，如NullPointerException、ArrayIndexOutOfBoundsException等，这类异常通常由程序逻辑错误引起，编译器不强制处理。</span></p></details>
<details class="lake-collapse"><summary id="u7438af5b"><span class="ne-text">异常处理机制 和 传播机制</span></summary><p id="ufb3e7a36" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">处理异常有三种机制：</span></p><ul class="ne-ul"><li id="ub3c5116b" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">try-catch-finally</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 块：</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">try</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">块用于捕获并处理异常，其后可接零个或多个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">catch</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 块，如果没有 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">catch</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 块，则必须跟一个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">finally</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 块。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">catch</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">块用于处理 try 捕获到的异常。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">finally</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 块无论是否发生异常都会执行，常用于释放资源；</span></li></ul><p id="uca445ac4" class="ne-p"><strong><span class="ne-text" style="color: rgb(119, 119, 119)">不要在 finally 语句块中使用 return!</span></strong><span class="ne-text" style="color: rgb(119, 119, 119)"> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</span></p><p id="uacae2369" class="ne-p"><strong><span class="ne-text" style="color: rgb(119, 119, 119)">什么情况下finally 中的代码不会被执行？</span></strong><span class="ne-text" style="color: rgb(119, 119, 119)">1，在 finally 之前虚拟机被终止运行；2，程序所在的线程死亡；3，关闭 CPU。</span></p><ul class="ne-ul"><li id="u74c46e35" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">throw</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：用于手动抛出一个异常实例；</span></li><li id="ua99b20b8" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">throws</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：用于在方法签名中声明该方法可能抛出哪些异常，方便调用者进行处理。</span></li></ul><hr id="DUCUc" class="ne-hr"><p id="u7cf93686" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">异常的传播机制</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：如果一个方法抛出了异常而没有处理，就会沿着调用栈一直向上传递，直到被某一层捕获为止，如果始终没有被捕获，最终 JVM 会终止程序并打印异常堆栈。</span></p></details>
<details class="lake-collapse"><summary id="uf971ffe0"><span class="ne-text">最佳实践</span></summary><p id="u9ac354a6" class="ne-p"><span class="ne-text">首先，应该捕获具体的异常类型，而不是简单地捕获Exception。其次，不要吞没异常，至少要记录异常信息。第三，合理使用自定义异常来区分业务异常和系统异常。最后，要注意异常处理的性能开销，特别是在高频执行的代码路径中。</span></p></details>
### 泛型
<details class="lake-collapse"><summary id="u8bfa1c0c"><strong><span class="ne-text">Java 的泛型机制</span></strong></summary><p id="u8b41744a" class="ne-p"><span class="ne-text">泛型就是在定义类、接口或方法时，不指定具体的数据类型，而是用一个“占位符”（比如 </span><code class="ne-code"><span class="ne-text">&lt;T&gt;</span></code><span class="ne-text">）来代替，等真正使用的时候再传入具体的类型。</span></p><p id="ub67a92c2" class="ne-p"><span class="ne-text">泛型本质上是</span><span class="ne-text">编译期的检查机制</span><span class="ne-text">，运行时其实是</span><span class="ne-text">擦除了类型信息</span><span class="ne-text">，所以它是典型的语法糖。</span></p><p id="ucca3db25" class="ne-p"><span class="ne-text">好处呢一个是提高代码的通用性：可以写一次代码，适用于多种类型；增强类型安全：编译阶段就能检查类型，避免运行时出错；减少强制类型转换：不需要手动强转，代码更简洁安全。</span></p></details>
### 反射
<details class="lake-collapse"><summary id="u39f67aa2"><strong><span class="ne-text">Java 的反射机制，优缺点？原理？</span></strong></summary><p id="u29172a3c" class="ne-p"><span class="ne-text">Java 反射是一种在程序运行时，动态地获取类的信息并操作类或对象的能力。</span></p><p id="ub49e2c6b" class="ne-p"><span class="ne-text">优点是：</span></p><p id="uff54ad13" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">灵活性和动态性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：反射允许程序在运行时动态地加载类、创建对象、调用方法和访问字段。这样可以根据实际需求（如配置文件、用户输入、注解等）动态地适应和扩展程序的行为，显著提高了系统的灵活性和适应性。</span></p><p id="u72ce83e9" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">框架开发的基础</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：许多现代 Java 框架（如 Spring、Hibernate、MyBatis）都大量使用反射来实现依赖注入（DI）、面向切面编程（AOP）、对象关系映射（ORM）、注解处理等核心功能。</span></p><p id="u16041236" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">解耦合和通用性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过反射，可以编写更通用、可重用和高度解耦的代码，降低模块之间的依赖。例如，可以通过反射实现通用的对象拷贝、序列化、Bean 工具等。</span></p><hr id="fMCOF" class="ne-hr"><p id="u22d7c634" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">缺点是：</span></p><p id="uc4ee5aa7" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">性能开销</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：反射操作通常比直接代码调用要慢。因为涉及到动态类型解析、方法查找以及 JIT 编译器的优化受限等因素。不过，对于大多数框架场景，这种性能损耗通常是可以接受的，或者框架本身会做一些缓存优化。</span></p><p id="u654b0d3b" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">安全性问题</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：反射可以绕过 Java 语言的访问控制机制（如访问 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">private</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 字段和方法），破坏了封装性，可能导致数据泄露或程序被恶意篡改。此外，还可以绕过泛型检查，带来类型安全隐患。</span></p><p id="u12768efc" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">代码可读性和维护性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：过度使用反射会使代码变得复杂、难以理解和调试。错误通常在运行时才会暴露，不像编译期错误那样容易发现。</span></p><hr id="j2X7U" class="ne-hr"><p id="udec31601" class="ne-p"><span class="ne-text">原理是：</span></p><p id="u20ed743a" class="ne-p"><span class="ne-text">依赖 JVM 的运行时类型信息实现</span></p><p id="u31dec7b3" class="ne-p"><span class="ne-text">Java 类被加载到 JVM 后，会生成一个 </span><code class="ne-code"><span class="ne-text">Class</span></code><span class="ne-text"> 对象 存放在 方法区（元空间） 中。<br /></span><span class="ne-text">这个对象保存了该类的：字段、方法、构造器、父类、接口、注解等信息</span></p><p id="u1049db95" class="ne-p"><span class="ne-text">反射就是通过这个 </span><code class="ne-code"><span class="ne-text">Class</span></code><span class="ne-text"> 对象，来在运行时读取或操作类结构。</span></p></details>
<details class="lake-collapse"><summary id="u98d4a5cc"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">应用场景</span></strong></summary><p id="ua854f9a4" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">依赖注入与控制反转</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：以 Spring/Spring Boot 为代表的 IoC 框架，会在启动时扫描带有特定注解（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">@Component</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">, </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">@Service</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">, </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">@Repository</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">, </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">@Controller</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）的类，利用反射实例化对象（Bean），并通过反射注入依赖（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">@Autowired</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、构造器注入等）</span></p><p id="u42cd0dff" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">注解处理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：框架通过反射检查类、方法、字段上有没有特定的注解，然后根据注解信息执行相应的逻辑。比如，看到 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">@Value</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，就用反射读取注解内容，去配置文件找对应的值，再用反射把值设置给字段。</span></p><p id="u657008ba" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">动态代理与 AOP</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：动态代理是实现 AOP 的常用手段。在运行时创建一个代理对象，这个对象对外看起来跟原对象一样，但它在方法调用的过程中，会先通过反射拿到你要调用的方法，然后可以在调用前后插入一些逻辑，比如打印日志，最后再通过反射去真正调用目标方法。</span></p><p id="u10b725c8" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">对象关系映射（ORM）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：像 MyBatis这种框架通过反射获取 Java 类的属性列表，然后把查询结果按名字或配置对应起来，再用反射调用 setter 或直接修改字段值。反过来，保存对象到数据库时，也是用反射读取属性值来拼 SQL。</span></p></details>
### 注解
<details class="lake-collapse"><summary id="u5daa89cf"><strong><span class="ne-text">Java 的注解机制，原理？</span></strong></summary><p id="u4287a3c9" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Annotation</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> （注解） 是 Java5 开始引入的新特性，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</span></p><hr id="phcrx" class="ne-hr"><p id="u4bec91bb" class="ne-p"><span class="ne-text">Java注解的原理是：</span><strong><span class="ne-text">通过元数据标记代码元素，由编译器或运行时环境解析处理</span></strong><span class="ne-text">。具体分为两种方式：</span></p><ol class="ne-ol"><li id="u98a5e54e" data-lake-index-type="0"><strong><span class="ne-text">编译时处理</span></strong><span class="ne-text">（如Lombok）：注解处理器扫描源码，生成或修改代码。</span></li><li id="ub809c7c7" data-lake-index-type="0"><strong><span class="ne-text">运行时反射</span></strong><span class="ne-text">（如Spring）：通过反射API读取注解信息，动态改变程序行为。</span></li></ol><p id="ud025dedf" class="ne-p"><span class="ne-text">注解是否生效取决于</span><code class="ne-code"><span class="ne-text">@Retention</span></code><span class="ne-text">策略：</span></p><ul class="ne-ul"><li id="u039d1cc1" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">SOURCE</span></code><span class="ne-text">：仅保留在源码（编译后丢弃）</span></li><li id="u673f8403" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">CLASS</span></code><span class="ne-text">：保留到字节码（默认）</span></li><li id="ue94cc13c" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">RUNTIME</span></code><span class="ne-text">：运行时可通过反射读取（最常用）</span></li></ul><p id="ua0f40d73" class="ne-p"><span class="ne-text">本质上，注解是继承</span><code class="ne-code"><span class="ne-text">Annotation</span></code><span class="ne-text">接口的特殊接口，其功能由解析工具（编译器/JVM）实现，本身不包含业务逻辑。</span></p></details>
<details class="lake-collapse"><summary id="ubbbeb659"><span class="ne-text">注解解析</span></summary><p id="ue394eadd" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">注解解析的两种核心机制</span></strong></p><p id="u67bf92f5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">运行时解析</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">依赖Java反射API，JVM在类加载阶段会将注解信息存储在Class对象的AnnotationData结构中，后续通过getAnnotation()等反射方法读取。Spring框架对此进行了深度优化，比如使用ASM字节码技术绕过类加载直接读取注解，并通过缓存机制避免重复解析带来的性能损耗。</span></p><p id="u7ca56cb5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2.</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">编译时解析</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">则遵循JSR 269规范，通过注解处理器在javac编译阶段介入。注解处理器继承AbstractProcessor基类，可以扫描分析源代码中的注解信息并生成新代码或编译错误。Lombok就是典型代表，它通过直接修改AST语法树实现在编译期间自动生成getter/setter等方法。</span></p></details>
<details class="lake-collapse"><summary id="u1d481889"><span class="ne-text">作用域</span></summary><p id="u4fb700a6" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。</span></p><p id="uff66311f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">类级别作用域</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。</span></p><p id="u05204c04" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">方法级别作用域</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。</span></p><p id="udd6b840d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">字段级别作用域</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。</span></p><p id="u4f6d60b8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">4，除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</span></p></details>
### SPI
<font style="color:rgb(51, 51, 51);">是 Java 提供的一种服务发现机制。</font>

<details class="lake-collapse"><summary id="u3358b269"><span class="ne-text">作用？优缺点？</span></summary><p id="u67b89379" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">它的作用是让我们可以只依赖接口，具体的实现类由第三方提供，并且在运行时动态加载，不需要写死。比如 JDBC 加载数据库驱动，底层就是用 SPI 机制实现的，Java 会自动去找配置好的驱动类并加载它们。</span></p><p id="ue5484195" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">通俗讲，SPI 就像是插件机制，我只负责定义接口，谁来实现、怎么实现，运行时系统自己去找，这样就实现了解耦和扩展。</span></p><p id="u1670b1f3" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优缺点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：提高接口设计的灵活性；</span></p><p id="u35aadcf2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">效率低：需要遍历加载所有的实现类，不能做到按需加载</span></p><p id="ud0612dbf" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">并发问题：当多个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ServiceLoader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 同时 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">load</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 时，会有并发问题。</span></p></details>
<details class="lake-collapse"><summary id="u4a9dd029"><span class="ne-text">和 API 的区别</span></summary><p id="u6db1c45e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">API 是“我去用别人”，它是别人定义好一套功能接口，我作为调用者去使用，比如我们常用的 List、HttpClient 这些都是 API。 而 SPI 是“别人来接我”，我定义一套接口，让第三方去实现，然后在运行时由系统动态加载这些实现类，比如 JDBC 加载数据库驱动，就是通过 SPI 实现的。</span></p><div class="ne-quote"><p id="u1e5a546a" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">API是“用户”使用外卖平台给你提供的“点餐功能”、“下单功能”、“付款功能”</span></p><p id="u192d882e" class="ne-p"><span class="ne-text" style="color: rgb(119, 119, 119)">SPI是平台方想让商家来入驻，就告诉商家：“只要你能送外卖，就来报名，遵守我的规则（接口）。”商家来实现你的送外卖接口。</span><strong><span class="ne-text" style="color: rgb(119, 119, 119)">平台在运行时会去找这些商家来派单。</span></strong></p></div></details>
<details class="lake-collapse"><summary id="u8e0aabe0"><span class="ne-text">ServiceLoader</span></summary><p id="u7fe8fbcf" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ServiceLoader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 提供的一个工具类，用来实现 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">SPI 机制的服务发现</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span><span class="ne-text" style="color: rgb(51, 51, 51)"> 它的作用就是在运行时根据接口，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">自动加载并实例化配置好的实现类</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，也就是说我只依赖接口，不需要手动 new 实现类，系统会自动去找“谁实现了这个接口”。</span></p><p id="udf64de17" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">常见的场景比如 JDBC 驱动加载，Java 就是用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ServiceLoader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 去找实现了 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">java.sql.Driver</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的类，从而实现驱动的自动注册。</span></p></details>
## Java IO
### IO 基础
**<font style="color:rgb(51, 51, 51);">Java 中的 I/O（输入输出）</font>**<font style="color:rgb(51, 51, 51);"> 是指程序与外部环境（如文件、网络、控制台等）之间的数据交换。</font>

<details class="lake-collapse"><summary id="ub2123ee5"><strong><span class="ne-text">IO 流分为几种</span></strong></summary><p id="ud76cb627" class="ne-p"><strong><span class="ne-text">按照流向分</span></strong></p><p id="ua6ed77b3" class="ne-p"><span class="ne-text">输入流：</span><span class="ne-text" style="color: rgb(44, 62, 80)">从源（如文件、网络等）读取数据到程序。</span></p><p id="uba25c8b1" class="ne-p"><span class="ne-text">输出流：</span><span class="ne-text" style="color: rgb(44, 62, 80)">将数据从程序写出到目的地（如文件、网络、控制台等）。</span></p><p id="u3ddc8579" class="ne-p"><strong><span class="ne-text">按照传输单位分</span></strong></p><p id="ud621c3e1" class="ne-p"><span class="ne-text">字节流：</span><span class="ne-text" style="color: rgb(44, 62, 80)">以字节为单位读写数据，主要用于处理二进制数据，如音频、图像文件等。</span></p><p id="ub98835b2" class="ne-p"><span class="ne-text" style="color: rgb(44, 62, 80)">字符流：以字符为单位读写数据，主要用于处理文本数据。</span></p><p id="u691fdaf3" class="ne-p"><strong><span class="ne-text" style="color: rgb(44, 62, 80)">按照功能分</span></strong></p><p id="u741c8b1e" class="ne-p"><span class="ne-text" style="color: rgb(44, 62, 80)">节点流：</span><span class="ne-text" style="color: rgb(0, 0, 0)">直接从数据源（如文件、内存）读写数据，功能比较单一。</span></p><p id="u5fd788e6" class="ne-p"><span class="ne-text" style="color: rgb(44, 62, 80)">处理流/包装流：对一个已存在的流进行包装吗，</span><span class="ne-text" style="color: rgb(0, 0, 0)">提供增强功能，如缓冲、转换、按行读写等。</span></p></details>
<details class="lake-collapse"><summary id="u751f9be7"><span class="ne-text">为什么要分字节流和字符流，既然有了字节流,为什么还要有字符流</span></summary><ul class="ne-ul"><li id="u25b4522c" data-lake-index-type="0" style="text-align: left"><strong><span class="ne-text" style="color: rgb(0, 0, 0)">字节流的困境</span></strong><span class="ne-text" style="color: rgb(0, 0, 0)">：它只认识字节。当你用字节流读取一个中文文本时，你得到的是一个冰冷的字节数组。要把它变成可读的字符串，你必须</span><strong><span class="ne-text" style="color: rgb(0, 0, 0)">手动、准确地</span></strong><span class="ne-text" style="color: rgb(0, 0, 0)">知道文件的编码方式，并在转换时指定。一旦指定错误（比如用GBK去解码UTF-8编码的文件），就会出现乱码。</span></li><li id="u2e9ba0de" data-lake-index-type="0" style="text-align: left"><strong><span class="ne-text" style="color: rgb(0, 0, 0)">字符流的解决方案</span></strong><span class="ne-text" style="color: rgb(0, 0, 0)">：字符流（其核心是</span><code class="ne-code"><span class="ne-text" style="color: rgb(0, 0, 0); font-size: 14px">InputStreamReader</span></code><span class="ne-text" style="color: rgb(0, 0, 0)">）在内部帮你完成了这个复杂的解码过程。你只需要在创建流时指定编码（或者使用明智的默认值），它就会自动从底层的字节流中读取字节，并根据编码规则将其解码成正确的字符。这大大简化了代码，并从根本上防止了乱码。</span></li><li id="ue0ef5473" data-lake-index-type="0" style="text-align: left"><strong><span class="ne-text" style="color: rgb(0, 0, 0)">处理非文本文件（如图片、压缩包、视频）时，你必须使用字节流</span></strong><span class="ne-text" style="color: rgb(0, 0, 0)">，因为这些文件的本质就是字节，不存在“字符”的概念。</span></li><li id="u3b58dd62" data-lake-index-type="0" style="text-align: left"><strong><span class="ne-text" style="color: rgb(0, 0, 0)">当处理纯文本文件时，你应该优先使用字符流</span></strong><span class="ne-text" style="color: rgb(0, 0, 0)">，因为它更高效、更安全、更便捷。</span></li></ul></details>
### IO 设计模式
<details class="lake-collapse"><summary id="ud6689e12"><span class="ne-text" style="color: rgb(51, 51, 51)">装饰器模式</span></summary><p id="u8f772932" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">装饰器模式是一种结构型设计模式，用于动态地为一个对象添加额外的职责（功能）。它通过创建一个包装对象，委托原始对象执行基本功能，同时在此基础上添加新的行为。装饰器模式主要有两个关键特点：</span></p><ol class="ne-ol"><li id="u9107a67d" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不改变原对象的结构</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过包装对象而不是继承，来扩展功能。</span></li><li id="u5ee36ea5" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">功能扩展是动态的</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：可以在运行时根据需要动态地为对象添加新功能。</span></li></ol><h3 id="K2Dfh"><span class="ne-text" style="color: rgb(51, 51, 51)">Java I/O 中的装饰器模式</span></h3><p id="u03f54ae0" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java I/O 中，尤其是缓冲流和过滤流的实现中，</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">装饰器模式的应用非常明显</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。例如：</span></p><ul class="ne-ul"><li id="ud341332c" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedInputStream</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedOutputStream</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><span class="ne-text" style="color: rgb(51, 51, 51)">这些类都是对 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">OutputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类的装饰器，它们并没有自己独立的读写功能，而是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">将原始的 I/O 流包装起来</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，通过缓冲机制来提升读写性能。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u5a14d5f7" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会在底层流中创建一个缓冲区，每次读取时，先从缓冲区读取数据，而不是每次都去磁盘或网络读数据，从而减少了 I/O 操作的次数，提高了性能。</span></li><li id="u4d625c5f" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedOutputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 也采用类似的方式，先将数据写入缓冲区，待缓冲区填满后一次性写入磁盘，减少了磁盘的写入操作。</span></li></ul></ul><p id="u75682219" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这两个类的工作原理就是装饰了原始流，使得原有的流功能得到了扩展，但并不改变它们原本的行为。</span></p><ul class="ne-ul"><li id="uec74604d" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedReader</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedWriter</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)">：</span><span class="ne-text" style="color: rgb(51, 51, 51)">类似地，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是对 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Reader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Writer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类的装饰器。它们通过提供缓冲区来提高读取和写入字符数据的效率。原始的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">FileReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">FileWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类是按字符读取和写入的，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 在此基础上增加了缓冲的功能，使得 I/O 操作变得更高效。</span></li></ul><h3 id="oddk1"><span class="ne-text" style="color: rgb(51, 51, 51)">装饰器模式在 I/O 中的作用</span></h3><p id="u3eceb74b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">装饰器模式的引入，使得我们可以在不修改原有类的情况下，灵活地扩展类的功能。通过组合不同的装饰器，我们可以创建具有多种功能的流。例如：</span></p><ul class="ne-ul"><li id="u8490bd32" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来增加缓冲功能，提升读取效率。</span></li><li id="ufe1224eb" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">DataInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来支持读取 Java 原始数据类型。</span></li><li id="ub968528d" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ObjectInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 来支持对象的序列化和反序列化。</span></li></ul><p id="u60fb5f97" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这种设计模式具有很大的灵活性和扩展性，使得我们可以根据需求选择不同的装饰器，组合成适合自己业务的 I/O 流。</span></p></details>
<details class="lake-collapse"><summary id="uef27d8fa"><span class="ne-text" style="color: rgb(51, 51, 51)">适配器模式</span></summary><p id="u14c29fef" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">适配器模式</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是一种结构型设计模式，它允许不兼容的接口之间进行交互。通过创建一个适配器类，将原本不兼容的接口转化为客户需要的接口。适配器模式的主要目的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">解耦</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，使得接口的使用者不需要关心被适配者的具体实现，只需要通过适配器来与其交互。</span></p><h3 id="RsY7A"><span class="ne-text" style="color: rgb(51, 51, 51)">适配器模式在 Java I/O 中的应用</span></h3><p id="ua2712f09" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">在 Java I/O 中，适配器模式常常用来将不同的数据源（如文件、网络、内存等）转换为统一的输入输出流接口，使得它们能够兼容地进行读写操作。Java 的 I/O 系统中有很多类是通过适配器模式进行设计的，最典型的例子是：</span></p><ol class="ne-ol"><li id="ue1ca019a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">InputStream 和 OutputStream 之间的适配</span></strong><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">OutputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是字节流的基类，而它们的子类代表了不同的数据源（如文件、网络等）。这些不同的数据源提供了不同的读取写入方式，但它们都可以通过字节流接口统一处理。具体来说，每个 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 子类都实现了与文件、网络或内存进行交互的细节，而不需要用户去关心这些底层实现细节。比如：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u85d5c711" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">FileInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：用于从文件中读取字节数据。</span></li><li id="ud41d893a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ByteArrayInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：用于从字节数组中读取数据。</span></li><li id="u27af7ad4" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：对其他字节流进行装饰，增加缓冲区提高性能。</span></li></ul></ul><p id="u911053b8" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">每种流类型都是 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的一个适配器，它们适配了不同的数据来源，使得客户端程序可以统一使用 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口来读取数据。</span></p><ol start="2" class="ne-ol"><li id="u98a80812" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Reader 和 Writer 之间的适配</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">类似于字节流，字符流也通过适配器模式进行适配。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Reader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Writer</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是字符流的基类，用于处理字符数据的输入和输出。而实际的数据来源（文件、字符数组、字符串等）通过不同的实现类来适配。例如：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ufb9eba30" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">FileReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：适配从文件中读取字符数据。</span></li><li id="u4a445bf6" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">StringReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：适配从字符串中读取字符数据。</span></li><li id="ubcdb5754" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">CharArrayReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">：适配从字符数组中读取数据。</span></li></ul></ul><p id="u8735c9af" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">BufferedWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 则是对这些流的适配器，提供缓冲区支持，以提高读取和写入效率。</span></p><ol start="3" class="ne-ol"><li id="ueabb97a3" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">InputStreamReader 和 OutputStreamWriter</span></strong><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStreamReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">OutputStreamWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是经典的适配器模式应用。它们允许我们将字节流转换为字符流，或者将字符流转换为字节流。由于字符流是按字符（16 位）处理的，而字节流是按字节（8 位）处理的，字符流和字节流需要通过适配器来进行相互转换：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u4f74f44a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStreamReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 将字节流（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">FileInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）适配为字符流。</span></li><li id="u0c212138" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">OutputStreamWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 将字符流（如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">FileWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">）适配为字节流。</span></li></ul></ul><p id="uede17990" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这种方式使得我们可以在不同的字符编码和字节编码之间进行转换，而不需要手动处理编码问题。</span></p><h3 id="mCYC9"><span class="ne-text" style="color: rgb(51, 51, 51)">适配器模式的优点</span></h3><ol class="ne-ol"><li id="u508db17b" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">解耦</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：适配器模式让客户端代码与具体的流实现解耦，可以灵活地替换不同的数据源，而不影响客户端的业务逻辑。</span></li><li id="u727e15c7" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">增强灵活性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：通过适配器，Java I/O 允许我们组合不同的流，实现更多样化的功能，比如缓冲、压缩、加密等，而无需修改底层的流实现。</span></li><li id="ua9f94965" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">便于扩展</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：当需要增加新的 I/O 功能时，只需要实现新的适配器类，客户端不需要做任何修改。</span></li></ol></details>
<details class="lake-collapse"><summary id="ua436f168"><span class="ne-text" style="color: rgb(51, 51, 51)">工厂模式</span></summary><p id="u1cd41eeb" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1. </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStreamReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">OutputStreamWriter</span></code></p><p id="u09d4d3b4" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这两个类通过工厂模式的方式实现了字节流和字符流之间的转换。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">InputStreamReader</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 将字节流转换为字符流，而 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">OutputStreamWriter</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 则是将字符流转换为字节流。通过这些类，开发者只需要提供输入输出流和编码类型，工厂方法会根据提供的参数创建适合的流对象。</span></p><p id="u1b25c69b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2. </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Files</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类的流创建方法</span></p><p id="ud67a8e2c" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java 8 中的 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Files</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 类提供了一系列的工厂方法，比如 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">newBufferedReader()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">newBufferedWriter()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">、</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">newInputStream()</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 等。这些方法负责根据不同的需求（如文件路径、编码等）返回不同类型的流对象。</span></p><p id="u8869ca9f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3. </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ObjectInputStream</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">ObjectOutputStream</span></code></p><p id="u1bdad165" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这两个类封装了对象的序列化和反序列化过程，从而通过工厂方式提供创建对象流的方法，简化了对象的读取和写入。</span></p><p id="u47dd0818" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">总结来说，Java I/O 通过工厂模式为流的创建提供了灵活和简洁的机制，使得开发者无需关心流对象的具体实现，提升了代码的可扩展性和可维护性。</span></p></details>
<details class="lake-collapse"><summary id="u0f292451"><span class="ne-text" style="color: rgb(51, 51, 51)">观察者模式</span></summary><p id="u02ef0f89" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 中的文件目录监听服务使用到了观察者模式。</span></p><p id="u924b419a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 中的文件目录监听服务基于 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">WatchService</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Watchable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 接口。</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">WatchService</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 属于观察者，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Watchable</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 属于被观察者。</span></p></details>
### IO 模型
<details class="lake-collapse"><summary id="u96493e94"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO（非阻塞 I/O）</span></summary><p id="u46c3f006" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">NIO（New I/O）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 在 JDK 1.4 引入的一套新的 I/O 模型，用于处理大规模、高并发的 I/O 操作。它的目标是提高 I/O 操作的效率，特别是在需要处理大量并发连接的应用中，如网络服务器、数据库等。</span></p><h3 id="a770870c"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO是怎么实现的？</span></h3><p id="ub3358466" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java NIO（New IO）是基于</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">事件驱动和非阻塞 IO 模型</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">实现的，它不同于传统 BIO 的一线程一连接，而是通过</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">多路复用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">机制实现高效并发通信。</span></p><p id="u63987a0e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 的核心在于三个部分：</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Channel、Buffer、Selector</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。</span></p><ul class="ne-ul"><li id="u2fa508f2" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Channel</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 表示一个双向通道，可以读也可以写，对应底层的文件或网络连接；</span></li><li id="ua347ca09" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Buffer</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是数据的容器，所有读写操作都通过 Buffer 进行；</span></li><li id="u17b62f1e" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Selector</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是多路复用器，它可以监听多个通道的事件，比如读、写、连接等，只需要一个线程就能管理多个通道。</span></li></ul><p id="ua93e0243" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">工作流程上，NIO 会把多个 Channel 注册到一个 Selector 上，然后单线程轮询 Selector 上是否有事件准备好（如某个通道可读），一旦就绪就处理对应的事件。这种模型大幅度减少了线程数量和上下文切换的开销。</span></p><hr id="Ngidm" class="ne-hr"><h3 id="3cceb999"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 的核心特性</span></h3><ol class="ne-ol"><li id="u989234a6" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">非阻塞 I/O</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">与传统的阻塞 I/O（BIO）不同，NIO 支持非阻塞 I/O。传统的 BIO 模型中，线程在进行 I/O 操作时会被阻塞，直到操作完成。而在 NIO 中，线程可以发起 I/O 操作后立即返回，继续执行其他任务，直到 I/O 操作完成。这样，线程可以高效地处理多个 I/O 操作，提升了并发性能。</span></li><li id="uc5bea5ec" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">I/O 多路复用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 引入了 </span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Selector</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Channel</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的机制，允许单个线程通过多路复用来管理多个 I/O 通道。通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Selector</span></code><span class="ne-text" style="color: rgb(51, 51, 51)">，一个线程可以同时监听多个通道（如多个网络连接），当某个通道准备好进行 I/O 操作时，线程才会被唤醒并进行处理。这避免了为每个 I/O 操作都创建一个线程，节省了资源，提升了并发处理能力。</span></li><li id="u5dcdcb03" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">缓冲区（Buffer）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 中的数据传输是通过 </span><code class="ne-code"><strong><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Buffer</span></strong></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 实现的。数据从通道读取到缓冲区，再从缓冲区写入到通道。缓冲区是 NIO 的核心组件之一，提供了高效的数据存取方式。通过缓冲区，可以实现直接在内存中进行数据的读写操作，减少了 I/O 操作的开销。</span></li><li id="uc356079c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">选择器（Selector）</span></strong><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Selector</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 NIO 的关键组件，它用于实现 I/O 多路复用。在 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Selector</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 中，多个通道（Channel）可以注册不同的操作（如读、写），并且可以在一个线程中异步地处理多个通道的事件。当某个通道准备好进行 I/O 操作时，</span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Selector</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 会通知相应的线程进行处理，从而大大提高了资源利用率。</span></li></ol><h3 id="aca33f71"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 的优势</span></h3><ol class="ne-ol"><li id="uc0dc21e7" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">高效的资源利用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">由于 NIO 支持非阻塞 I/O 和 I/O 多路复用，线程可以在等待 I/O 操作时继续处理其他任务，从而避免了阻塞，提升了资源的利用效率。这对于需要处理大量并发连接的应用程序非常有用，比如 Web 服务器、聊天室等。</span></li><li id="ufda23b2f" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">减少线程开销</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">在传统的 BIO 模型中，每个连接都需要一个独立的线程进行处理，这在高并发的场景下会产生很大的线程开销。而 NIO 通过 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Selector</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(51, 51, 51); background-color: rgb(243, 244, 244)">Channel</span></code><span class="ne-text" style="color: rgb(51, 51, 51)"> 的组合，允许一个线程处理多个 I/O 通道，大大减少了线程的数量，从而降低了线程的管理开销。</span></li><li id="u4e84cce0" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">可扩展性强</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 的设计使得它在处理大规模并发时能够提供更好的扩展性。它能通过一个线程同时处理成千上万个连接，避免了传统模型中的线程过多问题，特别适用于需要处理大量客户端请求的服务器。</span></li></ol><h3 id="000cf25f"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO 的缺点</span></h3><ol class="ne-ol"><li id="u8be9f9b7" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">编程复杂性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">与传统的阻塞 I/O 模型相比，NIO 的编程模型更为复杂。开发者需要理解非阻塞操作、事件轮询、缓冲区管理等概念。此外，错误处理和资源管理也比 BIO 更加繁琐。</span></li><li id="u970bf154" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不适用于小规模应用</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">如果应用的并发量较低，NIO 的复杂性可能不值得使用。在这种情况下，使用传统的阻塞 I/O（BIO）模型可能更加简单和高效。</span></li></ol><p id="u85ffbed7" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">BIO（Blocking I/O）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 和 </span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">AIO（Asynchronous I/O）</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)"> 是 Java 中两种不同的 I/O 模型，它们分别有着不同的工作原理和适用场景。下面是对这两种 I/O 模型的详细介绍。</span></p></details>
<details class="lake-collapse"><summary id="u201bcb68"><span class="ne-text" style="color: rgb(51, 51, 51)">BIO（阻塞 I/O）</span></summary><p id="u3d6ceccf" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">BIO 是传统的 I/O 模型，每个 I/O 操作都会阻塞当前线程，直到操作完成。这意味着在进行 I/O 操作时，线程无法做其他任何事情，直到数据从输入流中读取或者写入输出流中。</span></p><h4 id="ed83bf84"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">工作原理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></h4><ul class="ne-ul"><li id="u00811c3d" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">阻塞操作</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：每次 I/O 操作（如读、写）都阻塞当前线程。线程会等待数据的准备，直到操作完成。</span></li><li id="u2b7ea98b" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">每个连接一个线程</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：在高并发场景中，每个客户端连接需要分配一个线程，线程会在 I/O 操作完成之前被阻塞，导致线程池资源容易耗尽。</span></li></ul><h4 id="ac97d7f3"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优缺点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></h4><ul class="ne-ul"><li id="u2426ea18" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u2348048c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">实现简单：BIO 模型相对简单易懂，适合小规模、低并发的应用。</span></li><li id="u112b1648" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">开发成本低：由于使用同步阻塞，开发者无需管理复杂的线程调度或回调。</span></li></ul></ul><ul class="ne-ul"><li id="u3e7df416" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">缺点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ue77413c7" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">低效</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：在高并发的情况下，每个连接都需要一个线程，而线程创建和上下文切换会带来额外的开销。</span></li><li id="uc6ff9eff" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">资源浪费</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：线程在等待 I/O 操作完成时会被阻塞，导致 CPU 资源被浪费，不能高效利用。</span></li><li id="ue14bf16a" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">不可扩展</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：随着连接数的增加，线程数也会线性增加，导致系统无法应对大规模并发。</span></li></ul></ul><h4 id="fa272f67"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">适用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></h4><ul class="ne-ul"><li id="u6a98f009" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">适用于低并发、简单的客户端-服务器模型，如小型应用程序、管理工具等。</span></li></ul></details>
<details class="lake-collapse"><summary id="udbec54e3"><span class="ne-text" style="color: rgb(51, 51, 51)">AIO（异步 I/O）</span></summary><p id="uaef5898d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">AIO 是一种相对较新的 I/O 模型，它采用了异步非阻塞的方式来处理 I/O 操作。与 NIO 类似，AIO 使线程在发起 I/O 操作后不需要等待操作的完成，而是可以继续执行其他任务。当 I/O 操作完成时，系统会通过回调机制通知线程。</span></p><h3 id="sawF4"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">工作原理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></h3><ul class="ne-ul"><li id="u21a6a13c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">完全异步</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：在 AIO 中，线程可以提交 I/O 操作后直接返回，而不必等待 I/O 操作的完成。I/O 操作会在后台完成。</span></li><li id="u82517483" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">回调通知</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：操作系统在 I/O 操作完成后，会通过回调机制通知应用程序，应用程序可以处理数据，而不需要一直轮询或者等待。</span></li></ul><h3 id="KRYTa"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优缺点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></h3><ul class="ne-ul"><li id="u0366610c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uc59115e1" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">高效性</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：由于线程无需阻塞等待 I/O 操作，AIO 模型可以高效利用系统资源，提升并发能力。</span></li><li id="ue1db2ca8" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">性能</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：它可以大大减少线程的数量，并且避免了传统 I/O 模型中的线程阻塞问题，适用于需要处理大量并发请求的场景。</span></li><li id="ue3b59180" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">低延迟</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：异步操作和回调机制确保线程在执行其他任务时不被阻塞，可以实现更快的响应。</span></li></ul></ul><ul class="ne-ul"><li id="u7a4f548b" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">缺点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u5943d8e0" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">实现复杂</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：AIO 模型的编程复杂度较高，需要使用回调机制来处理 I/O 完成后的通知，增加了代码的复杂性。</span></li><li id="u20512be2" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">回调地狱</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：处理大量异步回调可能导致代码难以维护，尤其是在复杂的业务场景中。</span></li></ul></ul><h3 id="axyGY"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">适用场景</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></h3><ul class="ne-ul"><li id="ub0efade8" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">高并发、大规模系统，如分布式系统、数据库、文件服务器等。</span></li></ul></details>
<details class="lake-collapse"><summary id="u1f3003fa"><span class="ne-text" style="color: rgb(51, 51, 51)">BIO vs NIO vs AIO</span></summary><p id="ub48db7bf" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</span></p><p id="ufd73b887" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</span></p><p id="u72fa7e1d" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</span></p></details>
## 新特性
### Java 8
<details class="lake-collapse"><summary id="u01c78aa6"><span class="ne-text">Java 8 新特性</span></summary><p id="u4ad259d5" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">首先最重要的是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Lambda表达式和函数式编程的支持</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。Lambda表达式提供了一种简洁的语法来表示匿名函数，使得我们可以用更少的代码实现同样的功能。配合函数式接口（@FunctionalInterface），我们可以写出更优雅的代码。比如用()-&gt;{}替代匿名内部类，大大简化了代码。</span></p><p id="u7f96f83b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">其次是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">Stream API的引入</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">。Stream提供了一种高效且易于并行化的数据处理方式。通过filter、map、reduce等操作，我们可以用声明式的方式处理集合数据。比如处理一个订单列表时，可以轻松实现过滤、排序、分组等操作，而且还能自动利用多核处理器进行并行计算。</span></p><p id="u2aa0bef1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">第三是</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">新的日期时间API</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">（java.time包）。这个全新的API解决了旧Date/Calendar类的各种问题，提供了线程安全、不可变且更直观的日期时间操作类，如LocalDate、LocalDateTime等。</span></p><p id="u37dcf865" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">另外还有几个重要特性：</span></p><ol class="ne-ol"><li id="uc46534c0" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">默认方法（default method），允许接口包含方法实现</span></li><li id="ue14f9538" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">方法引用（Method Reference），进一步简化Lambda表达式</span></li><li id="u00dfe231" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">Optional类，提供了更好的null值处理方式</span></li></ol></details>
<details class="lake-collapse"><summary id="uc366b335"><span class="ne-text">Lamda 表达式</span></summary><p id="u39d16413" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">本质上是一个匿名函数，允许我们将函数作为方法参数传递，或者将代码作为数据处理。它的核心思想来自于函数式编程。</span></p><p id="u2e366a5e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">从语法上看，Lambda表达式由三部分组成：</span></p><ol class="ne-ol"><li id="ue3207e0c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">参数列表：可以省略参数类型（类型推断）</span></li><li id="u2d31f47e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">箭头符号：-&gt;</span></li><li id="u253497f9" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51)">方法体：可以是表达式或代码块</span></li></ol><p id="u5792aa9d" class="ne-p"><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">：</span></p><p id="u6b2baef2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">1，简洁性：Lambda表达式大幅减少了样板代码。相比传统的匿名内部类，它消除了冗余的类定义和方法声明，使代码更加紧凑。</span></p><p id="u06e6c358" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">2，可读性：通过将关注点集中在业务逻辑本身，过滤掉了非核心的语法结构。链式调用配合方法引用，使数据处理流程可以像自然语言一样线性表达。</span></p><p id="u7696c7aa" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">3，允许将函数作为方法参数传递，实现了策略模式的轻量化应用。比如集合的sort方法，现在可以直接传入比较逻辑，而不需要创建完整的Comparator实现类。</span></p><p id="ua6eec199" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">虽然 Lambda 表达式优点蛮多的，不过也有一些</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">缺点</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，比如会增加调试困难，因为 Lambda 表达式是匿名的，在调试时很难定位具体是哪个 Lambda 表达式出现了问题。尤其是当 Lambda 表达式嵌套使用或者比较复杂时，调试难度会进一步增加。</span></p></details>
<details class="lake-collapse"><summary id="u01828066"><span class="ne-text" style="color: rgb(51, 51, 51)">Stream API</span></summary><p id="u8bd56fee" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Java Stream API是Java 8引入的声明式数据处理框架，它通过函数式编程范式重新定义了集合操作方式。Stream的本质是对数据源的元素序列进行函数式流水线操作。</span></p><p id="u18a0c3b9" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">这个API最大的</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">优势</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">是让数据处理代码更加简洁明了，特别是在需要对集合进行复杂操作时，可以避免编写多层嵌套的循环语句。同时，它的函数式风格也使得代码更容易理解和维护。</span></p><p id="u006d7e9b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">Stream API还支持</span><strong><span class="ne-text" style="color: rgb(51, 51, 51)">并行处理</span></strong><span class="ne-text" style="color: rgb(51, 51, 51)">，通过parallelStream()方法可以自动将任务分配到多个线程执行。在使用时需要注意，Stream是单向的，一旦被消费就不能重复使用。</span></p></details>

.









