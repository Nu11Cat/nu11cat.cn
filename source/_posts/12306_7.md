---
title: 分布式和微服务相关
topic: fang12306
---

如何管理用户登录状态	服务拆分	分布式事务	API幂等性设计

### 如何管理用户登录状态

你的项目管理用户登录状态的方式是 **基于 JWT 的无状态认证**，具体流程如下：

1. **用户登录生成 Token**
   - 用户登录成功后，系统通过 `JwtUtil.createToken` 生成 JWT Token，内容包括用户 ID、手机号、签发时间、过期时间等，并用项目密钥签名。
2. **请求拦截与校验**
   - **网关层**（`LoginMemberFilter`）检查请求的 `token`，验证签名和有效期，不合法则返回 `401`。
   - **后端服务拦截器**（`MemberInterceptor`）解析 Token，将用户信息存入 `LoginMemberContext`（`ThreadLocal`），便于业务层获取当前用户。
3. **用户信息存储与访问**
   - Token 本身自包含用户信息，无需在服务端存储会话数据（无状态）。
   - 每次请求通过 `ThreadLocal` 获取当前用户信息，保证请求隔离。
4. **特点**
   - 无状态，易于水平扩展。
   - 签名防篡改，过期控制保证安全性。
   - 网关+后端双重验证，提高安全和性能。

总结：你的系统通过 JWT Token + ThreadLocal 上下文，实现了**无状态、高并发可扩展的用户登录管理**。

### 服务拆分

1. **拆分原则**
   - 按照**业务边界（领域驱动设计 DDD）**进行拆分，而不是简单按功能分层。
   - 每个服务**职责单一、边界清晰**，尽量减少耦合。
2. **服务模块说明**
    可以写出你目前的几个主要服务：
   - **gateway 网关服务**：统一入口，负责路由、鉴权、限流。
   - **common 公共模块**：提供工具类、通用拦截器、通用响应结构等。
   - **member 会员服务**：用户注册、登录、验证码发送、会员信息管理。
   - **business 购票业务服务**：余票查询、购票下单、订单确认、座位分配。
   - **batch 定时调度服务（如果有 Quartz）**：定时任务，如票务数据初始化、过期订单清理。
   - **后续可能的扩展服务**：支付服务、通知服务（短信/邮件）、报表服务。
3. **拆分带来的好处**
   - **可扩展性**：不同模块可以独立扩容，比如购票业务流量大时，只扩容 business 服务即可。
   - **高内聚低耦合**：服务之间通过 API（OpenFeign）调用，避免了大而全的单体系统。
   - **独立部署和升级**：某个服务修改后只需重新部署该服务，不影响其他服务。
   - **容错性**：一个服务挂掉不会影响整个系统（比如短信服务挂了，购票流程还能走下去）。
4. **服务拆分的不足/挑战**
   - **分布式复杂性**：要考虑分布式事务（Seata）、服务注册发现（Nacos）、配置中心、链路追踪。
   - **部署和运维成本增加**：多个服务需要更复杂的 CI/CD 和监控体系。
   - **跨服务调用性能开销**：调用链变长，需要缓存、异步化、消息队列来优化。

### 分布式事务

系统采用 Seata 来解决跨服务、跨库的分布式事务问题。在购票流程中，涉及余票扣减、订单状态更新、会员车票生成等操作，均通过 `@GlobalTransactional` 进行全局事务管理。这样保证了任意一步失败时，其余操作都会回滚，确保最终一致性。
 但 Seata 的 AT 模式在高并发场景下性能有限，后续可结合 **本地事务 + MQ 补偿** 来优化事务方案。

写 **分布式事务** 部分时，其实不用写得很复杂，即使就用了 Seata，也能写出体系化的东西。重点是：

1. **为什么需要分布式事务**
   - 你的系统是 **微服务架构**，订单确认场景就涉及：
     - business 服务扣减余票
     - member 服务增加会员车票
     - order 服务更新订单状态
   - 这些操作分布在不同的数据库、不同的服务里，必须保证 **一致性**（不能出现扣了票但没生成订单的情况）。
2. **选型：Seata**
   - Seata 是 **Spring Cloud Alibaba 官方推荐** 的分布式事务框架。
   - 你用的是 **AT 模式**（自动代理数据源，二阶段提交），用 `@GlobalTransactional` 管理整个购票流程。
   - 事务提交时：所有分支服务都成功 → 全局提交。
   - 事务异常时：自动回滚，保证数据一致。
3. **你现在的实现**
   - 在 `afterDoConfirm` 方法里加了 `@GlobalTransactional`。
   - 涉及的数据库更新：
     - 更新余票表 `daily_train_ticket`
     - 更新座位表 `daily_train_seat`
     - 更新订单表 `confirm_order`
     - 调用会员服务生成会员车票（跨服务调用）
   - 如果任何一步失败，Seata 会回滚整个流程。
4. **这样写的好处**
   - 避免了人工编写复杂的回滚逻辑。
   - 保证了跨库、跨服务的一致性。
5. **需要补充的不足/挑战**（可以在总结里写）
   - Seata 的 AT 模式性能不如本地事务，秒杀高并发下会成为瓶颈。
   - 依赖 undo log，表设计和 SQL 复杂度会影响性能。
   - 一般最佳实践：**核心扣减用数据库本地事务 + 补偿机制（MQ + 状态校正）**，而不是全靠全局事务。

### API幂等性设计

在购票下单接口中引入 **令牌机制**，每个请求都必须携带唯一 token，防止用户或网络重试造成的重复提交。

在订单消息处理环节，结合 RocketMQ 消息 ID 与数据库唯一约束，确保重复消息不会被多次消费。

在数据库层面，通过 **唯一索引** 防止重复数据写入。
