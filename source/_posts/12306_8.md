---
title: 待办
topic: fang12306
---



1，mybatis-plus重写crud

2，redis击穿等防范.

3，删除测试体验等代码

4，添加redis预扣减库存和数据库层面的锁，确保不超卖

5，

### 1.0 版本总结：

好的，我们系统梳理一下你的项目现状、问题和下一步优化方案：

------

#### 1️⃣ 当前项目实现了什么

**业务功能层面**

- 完整的车票预订流程：余票查询、选座、下单、订单状态更新、会员票记录。
- JWT 登录管理，网关和服务层拦截器保证请求身份。
- 秒杀/高并发场景初步处理：
  - **令牌桶削峰**控制请求压力。
  - **Redis 分布式锁**防止并发修改同一条余票数据。
  - **消息队列（MQ）异步处理订单**，削峰和解耦前端请求与后端库存操作。
- 数据一致性保证：
  - 基于 **数据库事务**和 Seata 全局事务控制订单、座位售票和库存修改。
  - **座位售票状态二进制表示**，避免重复售票。
  - **数据库唯一索引**限制同车次同区间重复插入。

**基本一致性和不超卖**

- 库存在数据库层做判断与扣减，保证基本不超卖（单点更新+事务）。
- 座位售票状态二进制处理，保证同一区间不会重复售票。
- 消息异步化保证高并发下订单请求不会直接阻塞数据库。

------

#### 2️⃣ 当前项目的不足

**库存和订单一致性**

- **没有 Redis 预扣减库存**，仍然依赖数据库实时扣减，无法充分削峰。
- **数据库没有行级/乐观锁机制**，可能在高并发下出现超卖或死锁问题。
- **Redis/Redisson 粗粒度锁**，锁粒度大，性能瓶颈明显。
- **Seata 全局事务**在秒杀高并发场景可能拖慢性能，增加系统耦合。
- **缺少异常回退/补偿机制**，一旦部分操作失败，可能导致库存与订单不一致。

**消息与异步处理**

- MQ 消息发送未使用事务消息，本地数据库修改与 MQ 消息可能不一致。
- 消费端处理是分页拉取 + 并行处理，无法保证严格顺序，可能造成库存错乱。
- **缺少死信队列和重试机制**，消费失败时可能丢失消息。

**系统设计与优化**

- 依赖数据库事务和回滚实现一致性，未充分利用缓存削峰。
- 秒杀场景下，性能未优化到极限。
- 缺少库存预扣减、幂等性设计和高并发优化措施。

------

#### 3️⃣ 接下来需要做什么

**库存与不超卖**

- 增加 **Redis 预扣减库存**，在入库前先在缓存中判断库存。
- 数据库层增加 **行级锁或乐观锁**，确保并发扣减正确。
- 优化 Redis 锁粒度（按车次+座位粒度，而不是整车）。

**事务与一致性**

- **事务消息**结合 MQ，确保库存扣减与消息发送原子性。
- **异常补偿机制**：失败回滚库存/订单，保证一致性。
- Seata 全局事务仅在必要时使用，秒杀路径尽量使用本地事务 + 异步消息。

**高并发优化**

- 消费端严格顺序消费或者使用分区+顺序消费策略。
- 增加 **死信队列**和重试机制，确保消息不丢失。
- 使用 **令牌桶 + Redis 预扣减**，结合本地事务处理库存，提高并发吞吐量。

**其他优化**

- 增加 **幂等性设计**，确保重复请求不会导致重复扣减。
- 考虑 **读写分离 + 缓存预热**，减轻数据库压力。

------

如果你需要，我可以帮你画一个**“当前实现 vs 最佳实践 vs 待优化方案”对比表格**，把秒杀、库存、一致性、消息可靠性都列出来，非常直观。

你希望我画吗？
