---
title: 高并发和性能优化
topic: fang12306
---

### 如何保证不超卖

现在只有令牌削峰，用户订单消息入 MQ，和redis分布式锁，我需要设计添加redis预扣减库存和数据库层面的锁

| 功能/策略                  | 最佳实践                                                     | 你现在的实现情况                                             | 分析 / 建议                                                  |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **削峰 & 排队**            | 令牌桶/限流 + MQ 排队，控制请求速率                          | ✅ 已实现：令牌控制前端请求量，订单消息入 MQ 排队             | 完成，削峰和异步排队机制有效                                 |
| **Redis 预扣减库存**       | 请求到达时先在 Redis 中扣减库存，快速响应，防止高并发下库存超卖 | ❌ 当前没有 Redis 预扣减库存                                  | 建议添加 Redis 预扣减，保证高并发下快速判断库存并减少 DB 锁竞争 |
| **数据库库存操作**         | 乐观锁（version、where ydz>0）或行级锁，保证并发下不会超卖   | ⚠️ 目前只是 `updateByPrimaryKeySelective` + 区间更新，没有乐观锁或行级锁机制 | 建议加乐观锁或行级锁，保证高并发下库存正确更新               |
| **分布式锁**               | Redisson/Redis 锁，控制同一车次或座位区间的并发修改          | ✅ 已有 Redis 分布式锁                                        | 已有锁，但锁粒度可能稍粗，可能成为性能瓶颈                   |
| **座位二进制区间库存处理** | 精细化座位区间扣减，保证区间库存正确                         | ✅ 已实现二进制 `sell` 处理逻辑，更新影响区间余票             | 完成，逻辑复杂但合理                                         |
| **异常回退 / 补偿机制**    | MQ 消费失败或订单异常时，回退 Redis 和数据库库存，保证最终一致性 | ⚠️ 当前没有完整回退机制                                       | 建议实现库存回退和订单补偿机制，保证最终一致性               |

### 余票数据的特殊处理

 系统将每个座位的售卖情况编码为二进制字符串，0 表示未售，1 表示已售。购票时根据选定区间计算最小和最大影响区间，更新座位售卖状态。每种座位类型独立维护余票数量，并在影响区间内更新数据库库存，保证不会出现超卖或少卖。该设计可以支持高并发、多区间购票，且余票计算和库存更新逻辑清晰。

1，每个座位用一个二进制字符串表示整个车次的售卖状态，`0` 表示该区间未售，`1` 表示该区间已售。可以快速判断某个座位在任意区间是否可售，支持区间查询。

2，向前查找最近已售区间，确定 `minStartIndex`，向后查找最近已售区间，确定 `maxEndIndex`，更新区间内的座位状态，保证座位在每个区间只能售一次。可以在多区间售票情况下准确计算余票。

3，每种座位类型单独维护余票。避免不同座位类型互相影响，更新逻辑独立。





### 如何保证数据一致性

| 功能/策略                 | 最佳实践                                          | 你现在的实现情况                                             | 分析 / 建议                                                  |
| ------------------------- | ------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **削峰 & 排队**           | 令牌桶/限流 + MQ 排队                             | ✅ 已实现：令牌控制前端请求量，订单消息入 MQ 排队             | 完成，削峰和异步排队机制有效                                 |
| **Redis 预扣减库存**      | Redis 预扣减库存，快速响应，削峰                  | ❌ 当前没有 Redis 预扣减库存，只在 DB 扣减库存                | 建议添加 Redis 预扣减，减少 DB 压力，防止高并发下锁竞争      |
| **数据库库存操作**        | 乐观锁或行级锁，保证不会超卖                      | ⚠️ DB 扣减库存使用 `updateByPrimaryKeySelective` + 区间计算，但没有明确行级锁或乐观锁机制 | 建议加乐观锁（version 或 `where ydz>0` 类似）或者行级锁，防止并发超卖 |
| **分布式锁**              | Redisson / Redis 锁，保证同一车次区间库存串行操作 | ✅ 已有 Redis 分布式锁                                        | 完成，但锁粒度可能稍粗，可能成为瓶颈                         |
| **跨服务事务**            | Seata 或 TCC，保证订单 + 座位 + 会员服务一致      | ✅ 已用 `@GlobalTransactional` + Seata AT 模式                | 完成，保证跨服务一致性                                       |
| **最终一致性 & 异常回退** | MQ + 异常回退（库存回退、订单状态回退）           | ⚠️ MQ 异常没有完整回退，Redis 预扣减也没用，所以回退机制不完善 | 建议实现库存回退和订单补偿机制，保证最终一致性               |
| **座位二进制区间售票**    | 精细化座位区间扣减，保证区间库存正确              | ✅ 已实现二进制 `sell` 处理逻辑，更新影响区间余票             | 完成，逻辑复杂但合理                                         |



### 如何应对秒杀

| 方面                 | 你现在的实现                       | 秒杀最佳实践                                 | 差距/不足                                                    |
| -------------------- | ---------------------------------- | -------------------------------------------- | ------------------------------------------------------------ |
| **削峰限流**         | 令牌桶/前端限流                    | ✅                                            | 基本达标                                                     |
| **异步排队**         | RocketMQ 消费订单                  | ✅                                            | 基本达标                                                     |
| **库存预扣减**       | ❌ 只在数据库判断 `reduceTickets()` | ✅ 在 Redis 先预扣减库存，减少 DB 压力        | 高并发下数据库压力大，可能成为瓶颈                           |
| **分布式锁**         | Redis/Redisson 粗粒度锁            | ✅ 锁粒度细、短时持有                         | 高并发下锁竞争严重，吞吐量受限                               |
| **座位区间库存处理** | 二进制标记售卖状态                 | ✅ 保留，最好结合 Redis                       | 已有，但 Redis 预扣减会更高效                                |
| **全局事务**         | Seata 全局事务                     | ⚠️ 最佳实践减少强事务依赖，使用最终一致性方案 | 全局事务在秒杀场景可能拖慢性能                               |
| **异常处理/回退**    | 依赖 DB/事务回滚                   | ✅ Redis 预扣 + MQ 异常回退                   | 当前实现 MQ 消费失败或异常回退机制不完善，可能漏票或库存不准 |
| **高并发性能优化**   | —                                  | ✅ 多级缓存、分段扣减、秒杀号段等             | 你当前实现未优化到极限，可能遇到秒杀高峰瓶颈                 |



### 如何保证消息不丢失

| 方面             | 你现在的实现                                                | 最佳实践                                       | 差距/不足                                                  |
| ---------------- | ----------------------------------------------------------- | ---------------------------------------------- | ---------------------------------------------------------- |
| **消息发送**     | 发送订单消息到 RocketMQ                                     | ✅                                              | 基本达标                                                   |
| **消息持久化**   | RocketMQ 默认持久化（commit log）                           | ✅                                              | 满足可靠投递                                               |
| **消息消费**     | 消费端处理订单 `doConfirm()`                                | ✅                                              | 满足消费需求                                               |
| **消费幂等**     | ✅ 确认订单状态有 `INIT/PENDING/SUCCESS/EMPTY`，避免重复处理 | ✅                                              | 你实现了幂等                                               |
| **消息确认机制** | RocketMQ 默认同步 ACK                                       | ✅                                              | 已保证至少一次投递                                         |
| **异常重试**     | ❌ 消费异常只会抛异常，缺少明确的重试/死信队列机制           | ✅ 最佳实践：设置消费重试次数 + 死信队列处理    | 当前实现可能存在消息被反复处理或丢失（未持久化异常信息）   |
| **事务消息**     | ❌ 发送 MQ 消息和本地数据库操作未使用事务消息                | ✅ 最佳实践：使用事务消息保证 MQ 与 DB 最终一致 | 如果发送 MQ 成功但本地 DB 异常，可能出现消息/订单不一致    |
| **顺序保证**     | ❌ 消费端分页拉取 + 并行处理，无法保证严格顺序               | ⚠️ 最佳实践可使用顺序队列，保证同车次订单顺序   | 对大部分业务影响不大，但理论上可能造成库存异常处理顺序问题 |

你的系统在可靠性上已经做得不错（幂等、基本重试），**但事务消息、死信队列和顺序保证等是差距**，如果高并发或异常多，这些缺失可能导致订单或库存数据不一致。
