---
title: 基础功能实现
topic: fang12306
---

### 余票查询和扣减

查询余票、购票、扣减余票是本系统的核心业务功能。

**余票查询实现**：

一般分布式场景针对余票查询的瞬时高并发请求，通常：分布式缓存 + 限流和削峰。

最佳实践：Redis 缓存，缓存预热 + TTL + 空对象处理，限流，Redis 集群/哨兵 + 数据库只读副本。本地缓存可选，但 TTL 很短，避免分布式不一致。

1，配置/连接Redis，序列化返回对象，启动类添加@EnableCaching，方法添加@Cacheable(value = "DailyTrainTicketService.queryList")。



**购票和扣减余票实现**：

1，beforeDoConfirm 生成确认订单，发送MQ排队购票，同时通过 Sentinel 做限流/降级。

2，doConfirm RocketMQ异步消费出票(校验余票/座位分配)，Redis 分布式锁串行化余票扣减防止超卖，更新订单状态并预扣减余票数量，同时通过 Sentinel 做限流/降级。

3，afterDoConfirm 选中座位后全局事务处理：修改座位售卖情况、更新余票详情表、为会员增加购票记录、修改订单状态为成功；通过 Seata 全局事务保证跨表操作一致性。

4，依靠分布式事务（Seata）、限流降级（Sentinel）、配置中心（Nacos）、消息队列削峰异步排队（RocketMQ）、分布式锁（Redis 分布式锁），保证购票的高并发安全与一致性。另外秒杀令牌的设计也能一定程度削峰控流，还能在高并发下减少库存超卖的风险，和分布式锁是互补机制。

### 防止刷票/机器人

1，秒杀令牌机制防止刷票：每趟列车在每个日期生成固定数量的“购票令牌”，通过 Redis 缓存管理。用户发起购票请求时，需先抢到令牌，令牌不足或未抢到则无法继续购票，从而限制高并发抢票，防止库存超卖，同时能有效阻挡机器人或恶意刷票。

2，通过 Kaptcha 图形验证码防止脚本/机器人：在购票前需输入验证码，系统生成的验证码字符串会存入 Redis（带过期时间），用户提交时进行校验。结合令牌机制，可以增加操作门槛，防止脚本或机器人自动批量请求。

### JWT单点登录

**单点登录**指用户在一个系统登录后可以获得访问其他多个互信任系统的权限，而无需重新登录。

**主要的实现方式**：

1，共享 Session (父域 Cookie)：所有子系统使用相同的顶级域名，将 Session ID 保存在父域下。用户登录一个系统后，该 Cookie 对所有子系统可见。但是域名必须同源，不适合分布式系统。

2，CAS 模型 (中央认证服务)：用户登录操作被重定向到中央认证服务。登录成功后，中心发放一个全局票证，用户再凭此票证访问各子系统。

3，Token 模型 (如 JWT)：用户登陆后认证中心返回一个签名的 Token，用户访问时携带Token来确认用户身份。无状态，扩展性强，适合现代微服务和 API 场景。

**为什么选择JWT**：因为JWT无状态，不需要服务存储并管理“票证”的签发和状态，因为JWT本身包含所有信息，不需要服务端储存；另外不需要认证中心（涉及Token吊销或黑名单可能需要），依赖性弱，不然认证中心下线服务就都g了。

**JWT带来的问题**：Token难以主动失效，需要借助黑名单等额外的机制；另外JWT的过期时间也需要慎重，因为Token内容一旦签发无法轻易撤回。

**具体实现**：

使用Hutool提供的零依赖JWT实现(5.7.0+)；HS256（HMAC SHA-256）算法加密。

添加JwtUtil工具类，设置盐值防解密，设置token签发/过期/生效时间和内容。用户登录后resq返回token字段。

### 网关层拦截器

基于 Spring Cloud Gateway 的 `GlobalFilter`，在请求进入微服务之前统一做 登录校验（token验证、放行/拦截），作用范围是整个网关层。

**登录校验的常见方式**:

1，应用拦截器：基于MVC框架，作为业务代码的一部分，但是每个业务服务挨个加上繁琐，维护性差。

2，过滤器：更底层，功能强大但繁琐，常用于需要处理更底层逻辑时。

3，AOP：更灵活，常作为更细颗粒度的方法级权限控制的补充。

4，网关：统一认证治理，解耦，易维护。

**为什么选择网关拦截器**：网关校验是微服务架构下的最佳实践，架构解耦，性能好，方便运维。

**具体实现**：添加依赖。添加拦截器，设置不需要拦截的请求和拦截器优先级。添加@Component并实现GlobalFilter接口就会自动启动，无需配置和额外注解。

### 服务层拦截器

与网关层拦截器不同，于 Spring MVC 的 `HandlerInterceptor`，在请求已经到达具体服务后，主要做 用户上下文解析（从 token 提取用户信息并保存），方便后续业务代码使用。

**具体实现**：服务层拦截器只需要 实现 `HandlerInterceptor` 接口，再加上 `@Component`，Spring Boot 就会自动生效。

另外在各个服务添加拦截器配置类，实现WebMvcConfigurer接口，加上@Configuration，自动生效，可以为该服务配置选择拦截器。

**设计亮点**：拦截器抽取到公共模块 + 各业务模块按需配置使用 的模块化可插拔设计提高了代码复用，并且拦截器和业务模块解耦，按需启用可维护性强。

### AOP方法级日志

**为什么选择AOP实现方法级日志**：主流方式，与业务解耦无侵入，可统一管理日志策略，方便扩展。

**其他各种日志的常见实现方式**：

HTTP请求/响应日志：拦截器，过滤器 (AOP无法获取完整的HTTP请求对象)

业务流水日志：硬编码 (高度定制化，AOP难以抽象)

跨服务的调用链追踪日志：APM工具 (无侵入，在字节码层面实现，提供全局视角，性能损耗极低)

**具体实现**：添加依赖：hutool，fastjson。添加LogAspect，添加@Aspect，@Component，定义切面，设置拦截规则，排除敏感字段。

### 异常处理

统一异常处理 + 自定义异常

**统一异常处理的具体实现**：通过 `@ControllerAdvice`+ `@ExceptionHandler`集中处理所有Controller层异常，返回统一的错误响应体。包含所有异常统一处理，业务异常统一处理，校验异常统一处理。

**自定义异常处理的具体实现**：通过 自定义异常（`BusinessException`） 和 异常枚举（`BusinessExceptionEnum`），实现业务异常的标准化管理。

**优化点**：重写`fillInStackTrace()`禁用堆栈跟踪，提升性能（适用于高频业务场景）

### 线程本地变量存储会员信息

**具体实现**：创建工具类用 ThreadLocal 保存会员信息，服务层拦截器在请求进入的时候解析 token存入ThreadLocal，业务层使用工具类方法获取当前线程的会员信息。

工具类完全 依赖静态方法和静态变量 来存储和获取数据，不需要 Spring 容器管理，也不需要被注入。Spring 完全不参与这个类的生命周期。

### 异常与边界场景处理

指的是在程序中 处理可能发生错误的情况（异常）和 特殊输入或极端条件（边界场景），确保系统不会崩溃或出现不可预期行为。

**具体实现**：

1，全局异常处理：见：异常处理-统一异常处理。

2，局部异常捕获：如LoginMemberContext获取用户信息异常的捕获，JobController创建/暂停/重启/更新/删除/查看定时任务调度的异常捕获等。

3，边界场景：Validation对输入数据的边界、格式、合法性进行的检查等。

4，服务调用和外部依赖：DbUtil-getConnection的异常捕获，KaptchaController验证码生成异常的捕获等。

5，日志记录：`LOG.error` 或 `LOG.warn` 等。

...





























