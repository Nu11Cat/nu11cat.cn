<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.23" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.88" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script data-goatcounter="https://nu11cat.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script><title>6.JVM 内存模型与垃圾回收 | Nu11CatJava</title><meta name="description" content="一个Java学习者记录学习过程、积累知识、分享经验、陪伴同行者一起成长的网站">
    <link rel="preload" href="/assets/style-ClTTZfAw.css" as="style"><link rel="stylesheet" href="/assets/style-ClTTZfAw.css">
    <link rel="modulepreload" href="/assets/app-2aldPGZG.js"><link rel="modulepreload" href="/assets/6.JVM 内存模型与垃圾回收.html-DEaSmeC_.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-BjTnTCcu.js" as="script"><link rel="prefetch" href="/assets/index.html-DmhUJj5b.js" as="script"><link rel="prefetch" href="/assets/index.html-BAyIH-i_.js" as="script"><link rel="prefetch" href="/assets/index.html-Cetqw4SD.js" as="script"><link rel="prefetch" href="/assets/1.算法学习路线 _ 刷题攻略.html-BkG4jAtP.js" as="script"><link rel="prefetch" href="/assets/2.数据结构专题.html-D343jWm7.js" as="script"><link rel="prefetch" href="/assets/3.算法思想与模板.html-CK93pOIy.js" as="script"><link rel="prefetch" href="/assets/4.高频题分类整理.html-ndKnnxIA.js" as="script"><link rel="prefetch" href="/assets/5.我的刷题记录.html-CIERosCA.js" as="script"><link rel="prefetch" href="/assets/index.html-DXBvy1Vs.js" as="script"><link rel="prefetch" href="/assets/1.官方资源.html-FuC_8Pna.js" as="script"><link rel="prefetch" href="/assets/2.在线工具 _ 开发资源.html-ChxpZWi9.js" as="script"><link rel="prefetch" href="/assets/3.优质开源项目推荐.html-N1-sd2Q5.js" as="script"><link rel="prefetch" href="/assets/4.学习资料与路线.html-BooJJmFX.js" as="script"><link rel="prefetch" href="/assets/5.面试 _ 八股文资料.html-R7bgdXW_.js" as="script"><link rel="prefetch" href="/assets/6.刷题 _ 算法练习.html-BauO9kmO.js" as="script"><link rel="prefetch" href="/assets/7.技术社区 _ 博客.html-wXELhKPE.js" as="script"><link rel="prefetch" href="/assets/index.html-PZyXRZVO.js" as="script"><link rel="prefetch" href="/assets/关于作者.html-3I3q1uU0.js" as="script"><link rel="prefetch" href="/assets/杂记-碎碎念.html-B1ldQ9dS.js" as="script"><link rel="prefetch" href="/assets/竞赛心得.html-BKEtL7H6.js" as="script"><link rel="prefetch" href="/assets/1.面向对象编程.html-CMkmt7Yz.js" as="script"><link rel="prefetch" href="/assets/10.ArrayList 核心源码.html-BgB9zaNt.js" as="script"><link rel="prefetch" href="/assets/2.集合框架.html-CeRyeitu.js" as="script"><link rel="prefetch" href="/assets/3.异常处理.html-FTRdpU6H.js" as="script"><link rel="prefetch" href="/assets/4.Java8特性.html-BWVrmukj.js" as="script"><link rel="prefetch" href="/assets/5.并发与多线程.html-DtsQF4Hl.js" as="script"><link rel="prefetch" href="/assets/7.Java 性能优化.html-BRvOJA5V.js" as="script"><link rel="prefetch" href="/assets/8.Java基础-机制.html-CFBKEXhC.js" as="script"><link rel="prefetch" href="/assets/9.Java基础-编译解释.html-vdwQct4-.js" as="script"><link rel="prefetch" href="/assets/1.Spring Core.html-B29liK4i.js" as="script"><link rel="prefetch" href="/assets/2.Spring Boot.html-C_09VlE4.js" as="script"><link rel="prefetch" href="/assets/3.Spring MVC.html-HmWXnknk.js" as="script"><link rel="prefetch" href="/assets/4.Spring Data.html-DViFN1JJ.js" as="script"><link rel="prefetch" href="/assets/5.Spring Security.html-BHhQG0Fe.js" as="script"><link rel="prefetch" href="/assets/6.Spring Cloud.html-lKg3E0hJ.js" as="script"><link rel="prefetch" href="/assets/7.Spring Batch.html-DoxIWs_7.js" as="script"><link rel="prefetch" href="/assets/1.关系型数据库.html-DuUrfQnL.js" as="script"><link rel="prefetch" href="/assets/2.JDBC.html-CW5QdB3t.js" as="script"><link rel="prefetch" href="/assets/3.ORM 框架.html-HfpGyY_4.js" as="script"><link rel="prefetch" href="/assets/4.数据库优化.html-CLoPyCzV.js" as="script"><link rel="prefetch" href="/assets/5.NoSQL 数据库.html-DBRLfKq_.js" as="script"><link rel="prefetch" href="/assets/6.分布式数据库与分库分表.html-Bn8B-KP1.js" as="script"><link rel="prefetch" href="/assets/1.微服务拆分与通信模式.html-DBTuVmhi.js" as="script"><link rel="prefetch" href="/assets/2.Spring Cloud Alibaba生态.html-B4xNCxDC.js" as="script"><link rel="prefetch" href="/assets/3.分布式事务.html-dSXKZerb.js" as="script"><link rel="prefetch" href="/assets/4.云原生与服务网格.html-BpZIG3Sy.js" as="script"><link rel="prefetch" href="/assets/1.HTTP协议与RESTful设计.html-DJ5TnCjx.js" as="script"><link rel="prefetch" href="/assets/2.Spring MVC与WebFlux响应式编程.html-jwFOpSC_.js" as="script"><link rel="prefetch" href="/assets/3.异步非阻塞与网络优化.html-CSHWsEu3.js" as="script"><link rel="prefetch" href="/assets/4.Web安全防御.html-DEXTMUkq.js" as="script"><link rel="prefetch" href="/assets/1.多级缓存架构.html-CbWjgfLD.js" as="script"><link rel="prefetch" href="/assets/2.Redis高阶实战.html-DIAM3hVt.js" as="script"><link rel="prefetch" href="/assets/3.JVM调优与内存管理.html-DhHhG7rW.js" as="script"><link rel="prefetch" href="/assets/4.高并发设计.html-CalnND7C.js" as="script"><link rel="prefetch" href="/assets/1.认证与授权.html-CpxSkTHv.js" as="script"><link rel="prefetch" href="/assets/2.安全防御.html-BwoNlUne.js" as="script"><link rel="prefetch" href="/assets/3.隐私合规.html-D-6FiJCc.js" as="script"><link rel="prefetch" href="/assets/1.Kubernetes进阶.html-eWk_r12B.js" as="script"><link rel="prefetch" href="/assets/2.CICD自动化.html-DALmBfTa.js" as="script"><link rel="prefetch" href="/assets/3.监控与日志体系.html-C26CTB3t.js" as="script"><link rel="prefetch" href="/assets/1.领域驱动设计.html-CrrorUIf.js" as="script"><link rel="prefetch" href="/assets/2.高并发系统.html-CKj_AgFB.js" as="script"><link rel="prefetch" href="/assets/3.云原生架构模式.html-BToCjV75.js" as="script"><link rel="prefetch" href="/assets/1.数据类型与OOP核心.html-bEEMcmUj.js" as="script"><link rel="prefetch" href="/assets/2.集合框架底层原理.html-BIYBegvP.js" as="script"><link rel="prefetch" href="/assets/3.异常处理机制.html-Cn0ryx9K.js" as="script"><link rel="prefetch" href="/assets/1.结构化回答模板.html-B0uNHOdL.js" as="script"><link rel="prefetch" href="/assets/2.场景题拆解方法.html-DiwfHJ6J.js" as="script"><link rel="prefetch" href="/assets/1.内存模型与垃圾回收.html-CMvakUH5.js" as="script"><link rel="prefetch" href="/assets/2.类加载机制.html-CNyBYvgK.js" as="script"><link rel="prefetch" href="/assets/1.线程同步与锁机制.html-BAtxgzux.js" as="script"><link rel="prefetch" href="/assets/2.线程池核心问题.html-Bir4Cw3r.js" as="script"><link rel="prefetch" href="/assets/3.JMM与并发工具.html-BJjPj8e0.js" as="script"><link rel="prefetch" href="/assets/1.IoC与AOP原理.html-BehCDuWF.js" as="script"><link rel="prefetch" href="/assets/2.Spring Boot核心机制.html-C6uG7irb.js" as="script"><link rel="prefetch" href="/assets/1.MySQL索引与事务.html-BUuWWQsV.js" as="script"><link rel="prefetch" href="/assets/2.ORM框架对比.html-DItlL_l7.js" as="script"><link rel="prefetch" href="/assets/1.分布式场景解决方案.html-NMvpVrt5.js" as="script"><link rel="prefetch" href="/assets/2.高并发设计题.html-BkG5fLgt.js" as="script"><link rel="prefetch" href="/assets/1.消息队列核心问题.html-DRM9oViQ.js" as="script"><link rel="prefetch" href="/assets/2.RPC框架原理.html-BunNxDjU.js" as="script"><link rel="prefetch" href="/assets/1.TCP协议与IO模型.html-DXMWU5ws.js" as="script"><link rel="prefetch" href="/assets/1.技术选型与优化.html-BBzWsH0v.js" as="script"><link rel="prefetch" href="/assets/2.故障排查实战.html-DeyN7zcP.js" as="script"><link rel="prefetch" href="/assets/周记模板.html-BcvdL4Zp.js" as="script"><link rel="prefetch" href="/assets/首页.html-CNgsEn49.js" as="script"><link rel="prefetch" href="/assets/404.html-BAssjZVA.js" as="script"><link rel="prefetch" href="/assets/index.html-Ben1WMbt.js" as="script"><link rel="prefetch" href="/assets/index.html-CSmLppC-.js" as="script"><link rel="prefetch" href="/assets/index.html-alI88_S-.js" as="script"><link rel="prefetch" href="/assets/index.html-BNULW7wk.js" as="script"><link rel="prefetch" href="/assets/index.html-DYBVMVlm.js" as="script"><link rel="prefetch" href="/assets/index.html-BKIt7QVw.js" as="script"><link rel="prefetch" href="/assets/index.html-D1sIj3wy.js" as="script"><link rel="prefetch" href="/assets/index.html-B3-N_ABc.js" as="script"><link rel="prefetch" href="/assets/index.html-RNx4AT9j.js" as="script"><link rel="prefetch" href="/assets/index.html-BJxG2jBz.js" as="script"><link rel="prefetch" href="/assets/index.html-DxDu4OF5.js" as="script"><link rel="prefetch" href="/assets/index.html-hE7-4HHn.js" as="script"><link rel="prefetch" href="/assets/index.html-CzchPxkn.js" as="script"><link rel="prefetch" href="/assets/index.html-DdXYScRm.js" as="script"><link rel="prefetch" href="/assets/index.html-B-ETSp-5.js" as="script"><link rel="prefetch" href="/assets/index.html-BuVzNEk1.js" as="script"><link rel="prefetch" href="/assets/index.html-C6bAWqNC.js" as="script"><link rel="prefetch" href="/assets/index.html-DJ8qjXKP.js" as="script"><link rel="prefetch" href="/assets/index.html-C7-0EV2w.js" as="script"><link rel="prefetch" href="/assets/index.html-BcSs5iVV.js" as="script"><link rel="prefetch" href="/assets/index.html-gggIQiIA.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-DXWKOczD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="Take me home"><!----><!----><span class="vp-site-name">Nu11CatJava</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="首页"><!---->首页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/" aria-label="学习篇"><!---->学习篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/2.%E9%9D%A2%E8%AF%95%E7%AF%87/" aria-label="面试篇"><!---->面试篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/3.%E7%AE%97%E6%B3%95%E7%AF%87/" aria-label="算法篇"><!---->算法篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/4.%E9%A1%B9%E7%9B%AE%E7%AF%87/" aria-label="项目篇"><!---->项目篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/5.%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/" aria-label="资源整理"><!---->资源整理<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/6.%E5%85%B3%E4%BA%8E%E6%88%91/" aria-label="关于我"><!---->关于我<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/Nu11Cat/Nu11Cat.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/" aria-label="首页"><!---->首页<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">1.学习篇</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/" aria-label="学习篇｜Java 后端核心知识体系"><!---->学习篇｜Java 后端核心知识体系<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">1. Java基础与核心概念</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html" aria-label="1.面向对象编程"><!---->1.面向对象编程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.html" aria-label="2.集合框架"><!---->2.集合框架<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/3.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" aria-label="3.异常处理"><!---->3.异常处理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/4.Java8%E7%89%B9%E6%80%A7.html" aria-label="4.Java8特性"><!---->4.Java8特性<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/5.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" aria-label="5.并发与多线程"><!---->5.并发与多线程<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/6.JVM%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html" aria-label="6.JVM 内存模型与垃圾回收"><!---->6.JVM 内存模型与垃圾回收<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/7.Java%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" aria-label="7.Java 性能优化"><!---->7.Java 性能优化<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/8.Java%E5%9F%BA%E7%A1%80-%E6%9C%BA%E5%88%B6.html" aria-label="8.Java基础-机制"><!---->8.Java基础-机制<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/9.Java%E5%9F%BA%E7%A1%80-%E7%BC%96%E8%AF%91%E8%A7%A3%E9%87%8A.html" aria-label="9.Java基础-编译解释"><!---->9.Java基础-编译解释<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/10.ArrayList%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81.html" aria-label="10.ArrayList核心源码"><!---->10.ArrayList核心源码<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">2. Spring生态系统</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">3.数据库与持久化</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">4. Web 开发与网络编程</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">5.分布式系统与微服务</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">6.缓存与高并发优化</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">7.系统安全与合规</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">8.云原生与 Dev Ops</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">9.架构设计与大厂实战</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">2.面试篇</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">3.算法篇</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">4.项目篇</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">5.资源整理</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">6.关于我</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->6.JVM 内存模型与垃圾回收</h1><div class="page-info"><!----><!----><!----><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 18 min</span><meta property="timeRequired" content="PT18M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><h1 id="目录-jvm内存模型与垃圾回收" tabindex="-1"><a class="header-anchor" href="#目录-jvm内存模型与垃圾回收"><span><strong>目录：JVM内存模型与垃圾回收</strong></span></a></h1><h2 id="_1-jvm内存模型与垃圾回收" tabindex="-1"><a class="header-anchor" href="#_1-jvm内存模型与垃圾回收"><span><strong>1：JVM内存模型与垃圾回收</strong></span></a></h2><ol><li><strong>JVM内存结构</strong> • 堆内存（Heap） • 栈内存（Stack） • 程序计数器（Program Counter） • 方法区与元空间（Method Area &amp; Metaspace） • 本地方法栈（Native Method Stack） • 内存溢出和StackOverflowError</li><li><strong>JVM内存管理</strong> • 内存分配与回收机制 • 内存泄漏与内存溢出 • 内存调优和配置（JVM参数） • JVM内存溢出的常见原因及解决方法</li></ol><hr><h2 id="_2-垃圾回收-gc-概述" tabindex="-1"><a class="header-anchor" href="#_2-垃圾回收-gc-概述"><span><strong>2：垃圾回收（GC）概述</strong></span></a></h2><ol><li><strong>GC的目标与原理</strong> • 什么是垃圾回收 • GC的主要目标与原则 • 垃圾回收的工作流程（标记、清除、整理）</li><li><strong>垃圾回收算法</strong> • 标记-清除算法（Mark-Sweep） • 复制算法（Copying） • 标记-整理算法（Mark-Compact） • 分代收集算法（Generational Collection） • G1垃圾回收器（Garbage-First Collector） • ZGC与Shenandoah</li><li><strong>JVM垃圾回收器</strong> • 串行垃圾回收器（Serial GC） • 并行垃圾回收器（Parallel GC） • 并发标记清除（CMS）垃圾回收器 • G1垃圾回收器 • ZGC与Shenandoah垃圾回收器的特点和应用场景</li><li><strong>垃圾回收的调优与配置</strong> • 如何选择垃圾回收器 • 垃圾回收器参数配置与优化 • JVM调优工具（jvisualvm, jconsole等） • GC日志分析与优化</li><li><strong>垃圾回收与内存泄漏</strong> • 如何识别与防止内存泄漏 • 垃圾回收对性能的影响及优化 • 对象生命周期与内存管理策略</li></ol><hr><h2 id="_3-jvm垃圾回收的性能优化" tabindex="-1"><a class="header-anchor" href="#_3-jvm垃圾回收的性能优化"><span><strong>3：JVM垃圾回收的性能优化</strong></span></a></h2><ol><li><strong>JVM内存模型与GC对性能的影响</strong></li><li><strong>提高垃圾回收效率的策略</strong> • 减少GC频率和暂停时间 • 堆内存大小与GC配置 • 分代收集的优化策略</li><li><strong>内存池和堆外内存管理</strong> • Direct Memory与Native Memory • JVM内存与操作系统之间的关系</li></ol><hr><h2 id="_4-jvm调优与监控" tabindex="-1"><a class="header-anchor" href="#_4-jvm调优与监控"><span><strong>4：JVM调优与监控</strong></span></a></h2><ol><li><strong>JVM性能监控工具</strong> • JVM监控工具概述 • GC日志分析工具（如GCViewer） • jvisualvm与jconsole的使用</li><li><strong>JVM调优案例分析</strong> • JVM调优的常见问题与解决方案 • 通过调优提高Java应用的响应速度和吞吐量 • 高并发环境下的JVM调优技巧</li></ol><hr><h1 id="第一部分-jvm内存模型与垃圾回收" tabindex="-1"><a class="header-anchor" href="#第一部分-jvm内存模型与垃圾回收"><span><strong>第一部分：JVM内存模型与垃圾回收</strong></span></a></h1><h2 id="_1-jvm内存结构" tabindex="-1"><a class="header-anchor" href="#_1-jvm内存结构"><span>1. <strong>JVM内存结构</strong></span></a></h2><h4 id="•-堆内存-heap" tabindex="-1"><a class="header-anchor" href="#•-堆内存-heap"><span>• 堆内存（Heap）</span></a></h4><p>JVM堆内存是存储对象的地方，是垃圾回收的主要区域。根据对象的生命周期，堆内存分为多个区域，主要有年轻代、老年代和永久代/元空间。</p><ul><li><strong>年轻代（Young Generation）</strong>：存放新创建的对象，使用复制算法进行垃圾回收。</li><li><strong>老年代（Old Generation）</strong>：存放生命周期较长的对象，采用标记-清除或标记-整理算法进行回收。</li><li><strong>永久代（PermGen）与元空间（Metaspace）</strong>：JDK 1.8之前为永久代，JDK 1.8及以后替换为元空间，存储类元数据和JVM加载的类。</li></ul><p>示例代码：没有直接的代码示例，但可以通过JVM启动参数设置堆内存大小，例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java -Xms512m -Xmx1024m MyApplication</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="•-栈内存-stack" tabindex="-1"><a class="header-anchor" href="#•-栈内存-stack"><span>• 栈内存（Stack）</span></a></h4><p>每个线程在创建时会有自己的栈内存，用于存储局部变量和方法调用栈帧。栈内存中的数据由操作系统自动管理，栈帧的生命周期与方法调用和返回绑定。</p><ul><li><strong>栈帧（Stack Frame）</strong>：存储局部变量、操作数栈和返回地址。</li><li><strong>线程栈的独立性</strong>：每个线程有独立的栈内存，线程栈在方法调用时动态分配，在方法返回时自动清除。</li></ul><p>示例代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class StackMemoryExample {</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        methodA(); // 调用方法</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    public static void methodA() {</span></span>
<span class="line"><span>        int a = 10; // 局部变量</span></span>
<span class="line"><span>        methodB();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void methodB() {</span></span>
<span class="line"><span>        int b = 20; // 局部变量</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="•-程序计数器-program-counter" tabindex="-1"><a class="header-anchor" href="#•-程序计数器-program-counter"><span>• 程序计数器（Program Counter）</span></a></h4><p>程序计数器用于存储每个线程当前正在执行的字节码指令的地址。每个线程有独立的程序计数器，这个计数器在不同的线程之间是互不干扰的。</p><p>示例：程序计数器的实现通常由JVM自动管理，无法通过代码直接操作。</p><h4 id="•-方法区与元空间-method-area-metaspace" tabindex="-1"><a class="header-anchor" href="#•-方法区与元空间-method-area-metaspace"><span>• 方法区与元空间（Method Area &amp; Metaspace）</span></a></h4><ul><li><strong>方法区</strong>：存储类的结构、常量池、字段、方法等信息。JDK 1.7之前称为永久代，JDK 1.8及以后称为元空间，存储类元数据。</li><li><strong>元空间</strong>：JDK 1.8引入，替代了永久代。元空间存储JVM加载的类和其他元数据。</li></ul><p>示例：通过JVM参数设置元空间大小：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m MyApplication</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="•-本地方法栈-native-method-stack" tabindex="-1"><a class="header-anchor" href="#•-本地方法栈-native-method-stack"><span>• 本地方法栈（Native Method Stack）</span></a></h4><p>本地方法栈支持JVM调用本地方法（如C/C++），它与栈内存类似，每个线程有独立的本地方法栈。它主要用来支持JVM与操作系统之间的接口交互。</p><h4 id="•-内存溢出和stackoverflowerror" tabindex="-1"><a class="header-anchor" href="#•-内存溢出和stackoverflowerror"><span>• 内存溢出和StackOverflowError</span></a></h4><ul><li><strong>内存溢出（OutOfMemoryError）</strong>：堆内存不足导致无法分配更多对象。</li><li><strong>StackOverflowError</strong>：线程的栈深度超出JVM限制时抛出。</li></ul><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class StackOverflowExample {</span></span>
<span class="line"><span>    public static void recursiveMethod() {</span></span>
<span class="line"><span>        recursiveMethod(); // 递归调用，导致StackOverflowError</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        recursiveMethod();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-jvm内存管理" tabindex="-1"><a class="header-anchor" href="#_2-jvm内存管理"><span>2. <strong>JVM内存管理</strong></span></a></h2><h4 id="•-内存分配与回收机制" tabindex="-1"><a class="header-anchor" href="#•-内存分配与回收机制"><span>• 内存分配与回收机制</span></a></h4><p>JVM的内存分配与回收机制主要通过垃圾回收（GC）来管理堆内存。JVM将堆内存划分为年轻代和老年代，不同的区域使用不同的垃圾回收算法。</p><ul><li><strong>年轻代回收（Minor GC）</strong>：主要回收年轻代中的对象，采用复制算法。</li><li><strong>老年代回收（Major GC）</strong>：回收老年代中的对象，使用标记-清除或标记-整理算法。</li></ul><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class GCDemo {</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        // 创建对象触发垃圾回收</span></span>
<span class="line"><span>        String str = new String(&quot;GC Example&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="•-内存泄漏与内存溢出" tabindex="-1"><a class="header-anchor" href="#•-内存泄漏与内存溢出"><span>• 内存泄漏与内存溢出</span></a></h4><ul><li><strong>内存泄漏</strong>：由于对象没有被及时回收，导致内存无法释放。</li><li><strong>内存溢出</strong>：由于堆内存不足，无法分配新的对象。</li></ul><p>常见的内存泄漏原因：</p><ul><li>长生命周期的对象持有对短生命周期对象的引用。</li><li>被过度使用的缓存没有及时清理。</li></ul><p>解决方法：</p><ul><li>使用工具如<code>VisualVM</code>、<code>JProfiler</code>进行内存分析。</li></ul><h4 id="•-内存调优和配置-jvm参数" tabindex="-1"><a class="header-anchor" href="#•-内存调优和配置-jvm参数"><span>• 内存调优和配置（JVM参数）</span></a></h4><p>通过调优JVM内存参数，可以提高应用的性能，避免内存溢出等问题。</p><ul><li><strong><code>-Xms</code></strong>：初始堆大小</li><li><strong><code>-Xmx</code></strong>：最大堆大小</li><li><strong><code>-Xss</code></strong>：每个线程的栈大小</li><li><strong><code>-XX:NewRatio</code></strong>：年轻代与老年代的比例</li></ul><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>-Xms512m -Xmx2048m -Xss1m MyApplication</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="•-jvm内存溢出的常见原因及解决方法" tabindex="-1"><a class="header-anchor" href="#•-jvm内存溢出的常见原因及解决方法"><span>• JVM内存溢出的常见原因及解决方法</span></a></h4><ul><li><strong>常见原因</strong>： <ul><li><strong>堆内存不足</strong>：应用程序创建了大量对象，堆内存不足。</li><li><strong>内存泄漏</strong>：未及时释放不再使用的对象，导致内存持续增长。</li><li><strong>StackOverflowError</strong>：线程栈溢出，通常由于递归调用过深。</li></ul></li><li><strong>解决方法</strong>： <ul><li><strong>增加堆内存大小</strong>：通过<code>-Xms</code>和<code>-Xmx</code>调节。</li><li><strong>优化对象创建与销毁</strong>：避免不必要的对象创建，使用对象池等技术复用对象。</li><li><strong>使用内存泄漏检测工具</strong>：例如<code>VisualVM</code>，进行实时分析与优化。</li></ul></li></ul><hr><h1 id="第二部分-垃圾回收-gc-概述" tabindex="-1"><a class="header-anchor" href="#第二部分-垃圾回收-gc-概述"><span><strong>第二部分：垃圾回收（GC）概述</strong></span></a></h1><h2 id="_2-1-gc的目标与原理" tabindex="-1"><a class="header-anchor" href="#_2-1-gc的目标与原理"><span>2.1 <strong>GC的目标与原理</strong></span></a></h2><h4 id="•-什么是垃圾回收" tabindex="-1"><a class="header-anchor" href="#•-什么是垃圾回收"><span>• <strong>什么是垃圾回收</strong></span></a></h4><p>垃圾回收（Garbage Collection，GC）是指自动化地回收不再使用的对象占用的内存资源。在Java中，JVM负责管理堆内存，并自动执行垃圾回收。垃圾回收机制解放了开发者手动管理内存的压力，提高了开发效率。</p><h4 id="•-gc的主要目标与原则" tabindex="-1"><a class="header-anchor" href="#•-gc的主要目标与原则"><span>• <strong>GC的主要目标与原则</strong></span></a></h4><ul><li><strong>回收无用对象</strong>：GC的主要目标是回收不再使用的对象，即那些没有任何活动引用的对象。</li><li><strong>内存管理</strong>：GC保证JVM能够及时回收无用的对象，避免内存泄漏或溢出。</li><li><strong>性能优化</strong>：GC的设计旨在最小化对程序性能的影响，确保垃圾回收不会频繁地占用过多的资源。</li></ul><h4 id="•-垃圾回收的工作流程-标记、清除、整理" tabindex="-1"><a class="header-anchor" href="#•-垃圾回收的工作流程-标记、清除、整理"><span>• <strong>垃圾回收的工作流程（标记、清除、整理）</strong></span></a></h4><ol><li><strong>标记</strong>：垃圾回收首先通过标记算法识别所有活跃的对象。</li><li><strong>清除</strong>：标记完成后，GC会清除没有被标记的对象，释放它们占用的内存。</li><li><strong>整理</strong>：为了防止内存碎片，GC会对存活的对象进行整理，将它们集中在内存的一端，提高内存的利用效率。</li></ol><hr><h2 id="_2-2-垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_2-2-垃圾回收算法"><span>2.2 <strong>垃圾回收算法</strong></span></a></h2><h4 id="•-标记-清除算法-mark-sweep" tabindex="-1"><a class="header-anchor" href="#•-标记-清除算法-mark-sweep"><span>• <strong>标记-清除算法（Mark-Sweep）</strong></span></a></h4><ul><li><strong>标记阶段</strong>：从根节点开始，递归标记所有可达的对象。</li><li><strong>清除阶段</strong>：清除所有未被标记的对象。</li></ul><p>此算法容易产生内存碎片，因此一般与其他算法配合使用。</p><h4 id="•-复制算法-copying" tabindex="-1"><a class="header-anchor" href="#•-复制算法-copying"><span>• <strong>复制算法（Copying）</strong></span></a></h4><ul><li>将内存分为两部分，每次只使用其中一部分。回收时将活跃对象复制到另一部分，回收未使用的部分。</li><li>优点是没有碎片，缺点是内存使用效率较低。</li></ul><h4 id="•-标记-整理算法-mark-compact" tabindex="-1"><a class="header-anchor" href="#•-标记-整理算法-mark-compact"><span>• <strong>标记-整理算法（Mark-Compact）</strong></span></a></h4><ul><li>标记阶段与标记-清除算法相同，区别在于清除阶段不是直接回收未标记的对象，而是将存活对象向一端移动，然后清理空余部分。</li><li>避免了内存碎片的问题。</li></ul><h4 id="•-分代收集算法-generational-collection" tabindex="-1"><a class="header-anchor" href="#•-分代收集算法-generational-collection"><span>• <strong>分代收集算法（Generational Collection）</strong></span></a></h4><ul><li>基于对象的生命周期划分堆内存，将内存分为年轻代、老年代和永久代。年轻代采用复制算法，老年代采用标记-清除或标记-整理算法。</li><li>这种方法有效提高了垃圾回收的效率，因为大部分对象都很快变为垃圾。</li></ul><h4 id="•-g1垃圾回收器-garbage-first-collector" tabindex="-1"><a class="header-anchor" href="#•-g1垃圾回收器-garbage-first-collector"><span>• <strong>G1垃圾回收器（Garbage-First Collector）</strong></span></a></h4><ul><li>G1垃圾回收器是一种低延迟、高吞吐量的垃圾回收器，设计上优先考虑可预测的停顿时间。</li><li>适用于大内存、高并发的应用场景。</li></ul><h4 id="•-zgc与shenandoah" tabindex="-1"><a class="header-anchor" href="#•-zgc与shenandoah"><span>• <strong>ZGC与Shenandoah</strong></span></a></h4><ul><li><strong>ZGC</strong>：ZGC是一个低延迟的垃圾回收器，具有可扩展性，支持大规模内存。</li><li><strong>Shenandoah</strong>：与ZGC类似，也是一个低延迟的垃圾回收器，特别优化了暂停时间。</li></ul><hr><h2 id="_2-3-jvm垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-3-jvm垃圾回收器"><span>2.3 <strong>JVM垃圾回收器</strong></span></a></h2><h4 id="•-串行垃圾回收器-serial-gc" tabindex="-1"><a class="header-anchor" href="#•-串行垃圾回收器-serial-gc"><span>• <strong>串行垃圾回收器（Serial GC）</strong></span></a></h4><ul><li>适用于单核处理器，所有垃圾回收都在单线程中完成，适用于资源有限的场景。</li><li>优点：实现简单，性能稳定。</li><li>缺点：对于多核处理器的性能发挥不足。</li></ul><h4 id="•-并行垃圾回收器-parallel-gc" tabindex="-1"><a class="header-anchor" href="#•-并行垃圾回收器-parallel-gc"><span>• <strong>并行垃圾回收器（Parallel GC）</strong></span></a></h4><ul><li>通过多线程并行处理垃圾回收任务，提高性能，适合在多核处理器上运行的应用。</li><li>优点：高吞吐量。</li><li>缺点：可能导致较长的停顿时间。</li></ul><h4 id="•-并发标记清除-cms-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#•-并发标记清除-cms-垃圾回收器"><span>• <strong>并发标记清除（CMS）垃圾回收器</strong></span></a></h4><ul><li>CMS是一个低延迟垃圾回收器，通过并发的方式标记和清除对象，减少停顿时间。</li><li>优点：适用于需要低延迟的应用。</li><li>缺点：较高的内存使用量，可能会导致Full GC。</li></ul><h4 id="•-g1垃圾回收器" tabindex="-1"><a class="header-anchor" href="#•-g1垃圾回收器"><span>• <strong>G1垃圾回收器</strong></span></a></h4><ul><li>G1垃圾回收器的目标是最大化应用的吞吐量并尽可能减少GC停顿时间。</li><li>优点：适合大内存应用，支持可预测的停顿时间。</li><li>缺点：实现复杂，调优难度较大。</li></ul><h4 id="•-zgc与shenandoah垃圾回收器的特点和应用场景" tabindex="-1"><a class="header-anchor" href="#•-zgc与shenandoah垃圾回收器的特点和应用场景"><span>• <strong>ZGC与Shenandoah垃圾回收器的特点和应用场景</strong></span></a></h4><ul><li><strong>ZGC</strong>和<strong>Shenandoah</strong>垃圾回收器都是为了提供低延迟的垃圾回收而设计，特别适用于对停顿时间有严格要求的高性能应用场景。</li></ul><hr><h2 id="_2-4-垃圾回收的调优与配置" tabindex="-1"><a class="header-anchor" href="#_2-4-垃圾回收的调优与配置"><span>2.4 <strong>垃圾回收的调优与配置</strong></span></a></h2><h4 id="•-如何选择垃圾回收器" tabindex="-1"><a class="header-anchor" href="#•-如何选择垃圾回收器"><span>• <strong>如何选择垃圾回收器</strong></span></a></h4><p>选择垃圾回收器时，需要根据应用的内存需求、对延迟的敏感度、吞吐量等因素来决定。常见的选择方式：</p><ul><li><strong>低延迟应用</strong>：可以使用CMS、G1、ZGC或Shenandoah。</li><li><strong>高吞吐量应用</strong>：可以选择并行垃圾回收器（Parallel GC）。</li></ul><h4 id="•-垃圾回收器参数配置与优化" tabindex="-1"><a class="header-anchor" href="#•-垃圾回收器参数配置与优化"><span>• <strong>垃圾回收器参数配置与优化</strong></span></a></h4><p>JVM垃圾回收器可以通过多种参数进行配置，以优化回收效率。常见的参数包括：</p><ul><li><code>-XX:+UseG1GC</code>：启用G1垃圾回收器。</li><li><code>-Xms</code>：设置初始堆大小。</li><li><code>-Xmx</code>：设置最大堆大小。</li></ul><h4 id="•-jvm调优工具-jvisualvm-jconsole等" tabindex="-1"><a class="header-anchor" href="#•-jvm调优工具-jvisualvm-jconsole等"><span>• <strong>JVM调优工具（jvisualvm, jconsole等）</strong></span></a></h4><p>JVM提供了一些工具用于实时监控和调优：</p><ul><li><strong>jvisualvm</strong>：用于分析JVM的性能、内存使用和垃圾回收。</li><li><strong>jconsole</strong>：用于监控JVM性能和内存使用。</li></ul><h4 id="•-gc日志分析与优化" tabindex="-1"><a class="header-anchor" href="#•-gc日志分析与优化"><span>• <strong>GC日志分析与优化</strong></span></a></h4><p>GC日志记录了垃圾回收的过程，分析这些日志可以帮助开发者找到性能瓶颈并进行优化。通过如下参数启用GC日志：</p><ul><li><code>-XX:+PrintGCDetails</code></li><li><code>-XX:+PrintGCDateStamps</code></li></ul><hr><h2 id="_2-5-垃圾回收与内存泄漏" tabindex="-1"><a class="header-anchor" href="#_2-5-垃圾回收与内存泄漏"><span>2.5 <strong>垃圾回收与内存泄漏</strong></span></a></h2><h4 id="•-如何识别与防止内存泄漏" tabindex="-1"><a class="header-anchor" href="#•-如何识别与防止内存泄漏"><span>• <strong>如何识别与防止内存泄漏</strong></span></a></h4><p>内存泄漏是指程序无法及时释放不再使用的对象。常见的内存泄漏现象包括：</p><ul><li><strong>静态集合类</strong>：长时间持有对不再使用对象的引用。</li><li><strong>监听器未移除</strong>：事件监听器未正确移除，导致对象无法被回收。</li></ul><p>识别内存泄漏可以使用<strong>VisualVM</strong>、<strong>JProfiler</strong>等工具。</p><h4 id="•-垃圾回收对性能的影响及优化" tabindex="-1"><a class="header-anchor" href="#•-垃圾回收对性能的影响及优化"><span>• <strong>垃圾回收对性能的影响及优化</strong></span></a></h4><p>GC停顿时间是影响应用性能的关键因素。通过合理选择垃圾回收器、调整内存参数和使用GC日志进行优化，可以最小化GC对应用性能的影响。</p><h4 id="•-对象生命周期与内存管理策略" tabindex="-1"><a class="header-anchor" href="#•-对象生命周期与内存管理策略"><span>• <strong>对象生命周期与内存管理策略</strong></span></a></h4><p>合理管理对象的生命周期可以帮助减少垃圾回收的负担。例如，尽量使用对象池复用对象，避免创建过多短生命周期的对象，从而减少垃圾回收的频率。</p><h1 id="第三部分-jvm垃圾回收的性能优化" tabindex="-1"><a class="header-anchor" href="#第三部分-jvm垃圾回收的性能优化"><span><strong>第三部分：JVM垃圾回收的性能优化</strong></span></a></h1><h2 id="_3-1-jvm内存模型与gc对性能的影响" tabindex="-1"><a class="header-anchor" href="#_3-1-jvm内存模型与gc对性能的影响"><span>3.1 <strong>JVM内存模型与GC对性能的影响</strong></span></a></h2><ul><li><strong>内存分配策略与分代理念</strong><ul><li>内存区域划分：年轻代、老年代、元空间/永久代</li><li>分代收集思想：大多数对象短命，年轻代回收较频繁；老年代对象较稳定</li><li>对象在各区间的分配与晋升策略：如对象在Survivor区的交换、晋升阈值的设置</li></ul></li><li><strong>内存区域大小与调优</strong><ul><li>年轻代大小与Minor GC触发频率的关系</li><li>老年代空间与Full GC停顿的权衡</li><li>堆内存总量对GC频率与GC延时的影响（如-Xms、-Xmx的设置）</li></ul></li><li><strong>对象存活率及布局的影响</strong><ul><li>不同对象存活率对复制算法与标记整理算法的影响</li><li>内存碎片问题：存活对象集中与分散对整理效率的关系</li><li>引用关系（强引用、软引用、弱引用、虚引用）对对象回收的影响</li></ul></li><li><strong>GC停顿与应用性能</strong><ul><li>GC过程中应用线程暂停的原因和持续时间</li><li>停顿时间对响应时间和吞吐量的直接影响</li><li>如何使用监控工具（如jvisualvm、jconsole）评估停顿情况</li><li>案例分析：某应用因GC停顿过长导致用户体验下降，调优前后对比</li></ul></li></ul><hr><h2 id="_3-2-提高垃圾回收效率的策略" tabindex="-1"><a class="header-anchor" href="#_3-2-提高垃圾回收效率的策略"><span>3.2 <strong>提高垃圾回收效率的策略</strong></span></a></h2><h3 id="_3-2-1-减少gc频率和暂停时间" tabindex="-1"><a class="header-anchor" href="#_3-2-1-减少gc频率和暂停时间"><span>3.2.1 <strong>减少GC频率和暂停时间</strong></span></a></h3><ul><li><strong>合理配置堆内存</strong><ul><li>动态调整堆内存大小（-Xms与-Xmx的平衡）</li><li>针对应用生命周期不同阶段的内存需求作出适配</li></ul></li><li><strong>优化年轻代空间与Minor GC</strong><ul><li>通过调整-XX:NewRatio、-XX:SurvivorRatio优化年轻代比例</li><li>降低Minor GC的触发频率，确保短命对象能快速复制并清除</li><li>采用复制算法时避免过度复制与内存复制开销</li></ul></li><li><strong>减少无用对象的创建</strong><ul><li>对象重用策略（对象池）在高并发场景中降低GC压力</li><li>避免频繁创建短生命周期临时对象，如字符串拼接、临时集合等</li></ul></li><li><strong>选择低停顿策略的垃圾收集器</strong><ul><li>根据应用特点选择CMS、G1、ZGC或Shenandoah等能减少暂停的GC</li><li>案例对比：不同GC在低延迟应用下的表现差异</li></ul></li></ul><h3 id="_3-2-2-堆内存大小与gc配置" tabindex="-1"><a class="header-anchor" href="#_3-2-2-堆内存大小与gc配置"><span>3.2.2 <strong>堆内存大小与GC配置</strong></span></a></h3><ul><li><strong>精细化堆内存调优</strong><ul><li>设置初始堆与最大堆大小（-Xms, -Xmx），保持内存稳定性</li><li>通过参数调整年轻代、老年代和元空间大小，避免内存不足或浪费</li></ul></li><li><strong>区域比例和晋升阈值配置</strong><ul><li>调整-XX:NewRatio、-XX:SurvivorRatio决定年轻代与老年代的比例</li><li>配置对象在新生代的存活阈值（-XX:MaxTenuringThreshold）</li><li>利用这些参数平衡Minor GC和Full GC之间的负担</li></ul></li><li><strong>GC专用参数优化</strong><ul><li>设置目标GC停顿时间参数（-XX:MaxGCPauseMillis）</li><li>针对特定收集器（如G1）的调参，如-XX:InitiatingHeapOccupancyPercent</li><li>实时通过GC日志反馈调整配置</li></ul></li></ul><h3 id="_3-2-3-分代收集的优化策略" tabindex="-1"><a class="header-anchor" href="#_3-2-3-分代收集的优化策略"><span>3.2.3 <strong>分代收集的优化策略</strong></span></a></h3><ul><li><strong>年轻代收集优化</strong><ul><li>利用复制算法提高Minor GC效率</li><li>分析年轻代中对象存活率，以便针对性调整复制效率</li><li>优化Survivor空间，提高对象从Eden转移到Survivor的存活概率</li></ul></li><li><strong>老年代收集优化</strong><ul><li>针对长生命周期对象，采用标记-整理算法减少碎片</li><li>调整Full GC触发条件，确保老年代GC不频繁影响性能</li><li>案例实践：优化Full GC时如何避免引入大量碎片</li></ul></li><li><strong>动态调优机制</strong><ul><li>基于GC日志与性能指标，实时进行参数调整</li><li>利用JVM监控工具自动化识别内存瓶颈</li><li>预案设计：在负载高峰期进行“预热”以降低GC响应</li></ul></li></ul><hr><h2 id="_3-3-内存池和堆外内存管理" tabindex="-1"><a class="header-anchor" href="#_3-3-内存池和堆外内存管理"><span>3.3 <strong>内存池和堆外内存管理</strong></span></a></h2><h3 id="_3-3-1-direct-memory与native-memory" tabindex="-1"><a class="header-anchor" href="#_3-3-1-direct-memory与native-memory"><span>3.3.1 <strong>Direct Memory与Native Memory</strong></span></a></h3><ul><li><strong>Direct Memory（直接内存）</strong><ul><li>定义：通过NIO接口分配、绕过堆内存的内存区</li><li>优势：减少复制开销，提高I/O性能</li><li>配置：-XX:MaxDirectMemorySize参数设置直接内存上限</li><li>注意事项：如何防止直接内存过度分配导致Native内存不足</li></ul></li><li><strong>Native Memory（堆外内存）</strong><ul><li>定义：由操作系统管理，与JVM堆分离的内存区域（包括元空间、直接内存等）</li><li>管理策略：监控本地内存使用，防止由于JVM外部内存使用导致系统性能问题</li><li>调优建议：结合系统监控工具，评估Native Memory占用与回收情况</li></ul></li></ul><h3 id="_3-3-2-jvm内存与操作系统之间的关系" tabindex="-1"><a class="header-anchor" href="#_3-3-2-jvm内存与操作系统之间的关系"><span>3.3.2 <strong>JVM内存与操作系统之间的关系</strong></span></a></h3><ul><li><strong>操作系统内存管理与JVM调度</strong><ul><li>内存映射文件、交换空间（Swap）的影响</li><li>系统调用成本对堆外内存分配的影响</li><li>使用容器或虚拟化环境时内存资源隔离问题</li></ul></li><li><strong>内存瓶颈定位与协同优化</strong><ul><li>评估JVM与操作系统资源分配的协同策略，避免单方面内存争用</li><li>利用操作系统级监控工具（如top、vmstat等）与JVM监控工具相结合</li><li>案例讨论：实例分析系统内存瓶颈导致应用抖动，如何协同调优</li></ul></li></ul><h1 id="第四部分-jvm调优与监控" tabindex="-1"><a class="header-anchor" href="#第四部分-jvm调优与监控"><span><strong>第四部分：JVM调优与监控</strong></span></a></h1><h2 id="_4-1-jvm性能监控工具" tabindex="-1"><a class="header-anchor" href="#_4-1-jvm性能监控工具"><span>4.1 <strong>JVM性能监控工具</strong></span></a></h2><h4 id="•-jvm监控工具概述" tabindex="-1"><a class="header-anchor" href="#•-jvm监控工具概述"><span>• <strong>JVM监控工具概述</strong></span></a></h4><ul><li><strong>作用与目标</strong> 在应用运行期间实时监控JVM内存、线程、垃圾回收等状态，快速定位性能瓶颈。</li><li><strong>主要监控指标</strong><ul><li>堆内存使用情况与各代内存占比</li><li>GC频率与停顿时间</li><li>线程状态、数量与CPU占用率</li><li>类加载情况与系统资源利用</li></ul></li></ul><h4 id="•-gc日志分析工具-如gcviewer" tabindex="-1"><a class="header-anchor" href="#•-gc日志分析工具-如gcviewer"><span>• <strong>GC日志分析工具（如GCViewer）</strong></span></a></h4><ul><li><p><strong>开启GC日志</strong> 使用如下JVM参数记录GC日志：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>shell</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制编辑</span></span>
<span class="line"><span>java -Xms1024m -Xmx2048m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log MyApplication</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>工具介绍</strong></p><ul><li><strong>GCViewer</strong>：将GC日志可视化，直观呈现各次GC的停顿时长、回收量与触发频率</li><li><strong>其它工具</strong>：GCEasy、HPJMeter等辅助分析GC行为和性能瓶颈</li></ul></li></ul><h4 id="•-jvisualvm与jconsole的使用" tabindex="-1"><a class="header-anchor" href="#•-jvisualvm与jconsole的使用"><span>• <strong>jvisualvm与jconsole的使用</strong></span></a></h4><ul><li><strong>jvisualvm</strong><ul><li>提供图形化界面，监控内存、CPU、线程、堆转储等信息；</li><li>支持插件扩展，可进行更深入的性能分析。</li></ul></li><li><strong>jconsole</strong><ul><li>轻量级工具，通过JMX连接目标JVM，实时查看内存使用、线程状态和类加载情况；</li><li>适合远程监控场景。</li></ul></li><li><strong>使用示例</strong> 启动工具后，选择目标进程，查看实时数据，依据监控结果调整JVM调优参数。</li></ul><hr><h2 id="_4-2-jvm调优案例分析" tabindex="-1"><a class="header-anchor" href="#_4-2-jvm调优案例分析"><span>4.2 <strong>JVM调优案例分析</strong></span></a></h2><h4 id="•-jvm调优的常见问题与解决方案" tabindex="-1"><a class="header-anchor" href="#•-jvm调优的常见问题与解决方案"><span>• <strong>JVM调优的常见问题与解决方案</strong></span></a></h4><ul><li><strong>常见问题</strong><ul><li><strong>内存泄漏</strong>：对象长时间未被释放，导致堆内存持续膨胀；</li><li><strong>GC停顿过长</strong>：堆内存配置不合理或垃圾收集器选择不当；</li><li><strong>频繁Full GC</strong>：由于老年代内存不足或碎片过多引起。</li></ul></li><li><strong>解决方案</strong><ul><li>利用jvisualvm、VisualGC等工具定位内存泄漏区域；</li><li>调整堆内存大小、代际比例，减少Full GC的发生；</li><li>优化代码，减少临时对象创建，并考虑使用合适的GC收集器。</li></ul></li></ul><h4 id="•-通过调优提高java应用的响应速度和吞吐量" tabindex="-1"><a class="header-anchor" href="#•-通过调优提高java应用的响应速度和吞吐量"><span>• <strong>通过调优提高Java应用的响应速度和吞吐量</strong></span></a></h4><ul><li><strong>响应速度提升策略</strong><ul><li>减少GC停顿：设置-XX:MaxGCPauseMillis参数；</li><li>优化内存分配，快速清除短生命周期对象。</li></ul></li><li><strong>提高吞吐量策略</strong><ul><li>合理配置Xms/Xmx参数确保充足内存；</li><li>选用并行GC或混合GC方案发挥多核优势。</li></ul></li><li><strong>案例分析</strong> 对比调优前后，通过GC日志、响应时间数据展示调整效果，提高响应速度和整体吞吐量。</li></ul><h4 id="•-高并发环境下的jvm调优技巧" tabindex="-1"><a class="header-anchor" href="#•-高并发环境下的jvm调优技巧"><span>• <strong>高并发环境下的JVM调优技巧</strong></span></a></h4><ul><li><strong>线程与GC调度优化</strong><ul><li>配置合适的线程栈大小（-Xss）与GC并行线程数（-XX:ParallelGCThreads）；</li></ul></li><li><strong>内存分配与代际调优</strong><ul><li>调整-XX:NewRatio、-XX:MaxTenuringThreshold等参数平衡年轻代和老年代负担；</li></ul></li><li><strong>实例分享</strong><ul><li>结合实际场景展示高并发平台调优案例，总结工具使用、参数选择、调整流程，为同类环境提供借鉴。</li></ul></li></ul></div><!----><!----><!----></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Nu11Cat/Nu11Cat.github.io/edit/main/docs/1.学习篇/1.Java基础与核心概念/6.JVM 内存模型与垃圾回收.md" aria-label="Edit this page" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page<!----></a></div><div class="vp-meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/5.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" aria-label="5.并发与多线程"><div class="hint"><span class="arrow start"></span>Prev</div><div class="link"><!---->5.并发与多线程</div></a><a class="route-link auto-link next" href="/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/7.Java%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" aria-label="7.Java 性能优化"><div class="hint">Next<span class="arrow end"></span></div><div class="link">7.Java 性能优化<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-2aldPGZG.js" defer></script>
  </body>
</html>
