import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-2aldPGZG.js";const l={};function h(t,i){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="目录" tabindex="-1"><a class="header-anchor" href="#目录"><span><strong>目录</strong></span></a></h1><h2 id="一、spring-core-概述" tabindex="-1"><a class="header-anchor" href="#一、spring-core-概述"><span>一、Spring Core 概述</span></a></h2><ul><li>Spring 是什么？为什么需要 Spring Core？</li><li>Spring Core 在整个 Spring 生态中的地位</li><li>核心模块结构简介（Beans、Context、Core、Expression）</li></ul><hr><h2 id="二、控制反转-ioc-核心原理" tabindex="-1"><a class="header-anchor" href="#二、控制反转-ioc-核心原理"><span>二、控制反转（IoC）核心原理</span></a></h2><ul><li>什么是 IoC？与传统开发模式的对比</li><li>IoC 容器的种类：<code>BeanFactory</code> vs <code>ApplicationContext</code></li><li>IoC 的作用与好处：解耦、可测试性、灵活性</li></ul><hr><h2 id="三、依赖注入-di-机制详解" tabindex="-1"><a class="header-anchor" href="#三、依赖注入-di-机制详解"><span>三、依赖注入（DI）机制详解</span></a></h2><ul><li>依赖注入的三种方式 <ul><li>构造器注入</li><li>Setter 方法注入</li><li>接口注入（不推荐，了解即可）</li></ul></li><li>注解方式的依赖注入：<code>@Autowired</code>、<code>@Inject</code>、<code>@Value</code>、<code>@Qualifier</code></li><li>XML 与 Java 配置方式的对比</li><li>集合类型依赖注入</li><li>注入的顺序与优先级控制</li></ul><hr><h2 id="四、bean-的定义与装配方式" tabindex="-1"><a class="header-anchor" href="#四、bean-的定义与装配方式"><span>四、Bean 的定义与装配方式</span></a></h2><ul><li>手动配置 Bean：<code>@Bean</code>、XML、JavaConfig</li><li>自动装配：基于注解的自动装配</li><li>条件化装配：<code>@Conditional</code>、<code>@Profile</code> 的使用场景</li><li>工厂方法与静态工厂装配</li></ul><hr><h2 id="五、bean-生命周期详解" tabindex="-1"><a class="header-anchor" href="#五、bean-生命周期详解"><span>五、Bean 生命周期详解</span></a></h2><ul><li>Bean 生命周期的完整流程图</li><li>实例化、属性赋值、初始化、销毁阶段解析</li><li>生命周期相关接口： <ul><li><code>InitializingBean</code></li><li><code>DisposableBean</code></li><li><code>BeanPostProcessor</code></li><li><code>BeanFactoryPostProcessor</code></li><li><code>SmartInitializingSingleton</code></li></ul></li><li>自定义初始化与销毁方法：<code>@PostConstruct</code> 与 <code>@PreDestroy</code></li><li>生命周期管理实战案例</li></ul><hr><h2 id="六、spring-容器的启动流程" tabindex="-1"><a class="header-anchor" href="#六、spring-容器的启动流程"><span>六、Spring 容器的启动流程</span></a></h2><ul><li>容器创建：从 <code>AnnotationConfigApplicationContext</code> 到 Bean 实例化</li><li>核心类与接口解析：<code>BeanDefinition</code>、<code>BeanDefinitionReader</code>、<code>BeanDefinitionRegistry</code></li><li>注解驱动容器启动的原理（<code>@ComponentScan</code>、<code>@Configuration</code>）</li></ul><hr><h2 id="七、注解驱动机制详解" tabindex="-1"><a class="header-anchor" href="#七、注解驱动机制详解"><span>七、注解驱动机制详解</span></a></h2><ul><li><code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 的区别与应用</li><li>元注解解析：<code>@Target</code>、<code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code></li><li>自定义注解与组合注解实践</li><li><code>@ComponentScan</code> 原理解析与包扫描机制</li></ul><hr><h2 id="八、spring-表达式语言-spel-基础" tabindex="-1"><a class="header-anchor" href="#八、spring-表达式语言-spel-基础"><span>八、Spring 表达式语言（SpEL）基础</span></a></h2><ul><li>SpEL 语法与常用操作：属性访问、方法调用、运算符、集合投影</li><li>SpEL 与 <code>@Value</code>、配置绑定的结合应用</li><li>SpEL 在条件装配、数据校验等场景中的实战</li></ul><hr><h2 id="九、源码视角下的依赖注入" tabindex="-1"><a class="header-anchor" href="#九、源码视角下的依赖注入"><span>九、源码视角下的依赖注入</span></a></h2><ul><li>从 <code>@Autowired</code> 到 <code>AutowiredAnnotationBeanPostProcessor</code></li><li>依赖查找与依赖注入的区别</li><li><code>DefaultListableBeanFactory</code> 的作用与核心方法</li><li>注入顺序与循环依赖的解决机制（三级缓存解析）</li></ul><hr><h2 id="十、常见问题与性能调优建议" tabindex="-1"><a class="header-anchor" href="#十、常见问题与性能调优建议"><span>十、常见问题与性能调优建议</span></a></h2><ul><li>循环依赖的问题与调试技巧</li><li>Bean 覆盖与冲突排查</li><li>启动速度慢？Bean 加载优化建议</li><li>@Lazy 与 Bean 延迟加载</li></ul><hr><h2 id="十一、面试重点与高频问题总结" tabindex="-1"><a class="header-anchor" href="#十一、面试重点与高频问题总结"><span>十一、面试重点与高频问题总结</span></a></h2><ul><li>IoC 与 DI 的区别与联系</li><li><code>@Autowired</code> 的原理与使用细节</li><li>Bean 生命周期回调顺序问题</li><li>如何解决循环依赖？三级缓存机制详解</li></ul><hr><h2 id="十二、最佳实践与经验总结" tabindex="-1"><a class="header-anchor" href="#十二、最佳实践与经验总结"><span>十二、最佳实践与经验总结</span></a></h2><ul><li>配置类推荐写法：可读性、可维护性、可扩展性</li><li>项目中如何合理分层管理 Bean 定义</li><li>测试环境与生产环境下的配置切换策略（结合 <code>@Profile</code>）</li></ul><hr><h1 id="一、spring-core-概述-1" tabindex="-1"><a class="header-anchor" href="#一、spring-core-概述-1"><span><strong>一、Spring Core 概述</strong></span></a></h1><h2 id="_1-spring-是什么-为什么需要-spring-core" tabindex="-1"><a class="header-anchor" href="#_1-spring-是什么-为什么需要-spring-core"><span>1. Spring 是什么？为什么需要 Spring Core？</span></a></h2><ul><li><strong>Spring 框架简介</strong><ul><li>起源：为了解决 Java EE 的繁琐与臃肿</li><li>核心思想：<strong>控制反转（IoC）</strong> + <strong>面向切面编程（AOP）</strong></li><li>特点：轻量级、非侵入性、模块化、支持多种持久化/事务/安全框架整合</li></ul></li><li><strong>开发痛点的解决方案</strong><ul><li>繁琐的对象管理 → Bean 容器统一管理</li><li>对象耦合过高 → IoC 降低耦合</li><li>横切逻辑混杂业务代码 → AOP 解耦</li><li>繁重的配置 → 自动装配 + 注解简化开发</li></ul></li><li><strong>Spring Core 的必要性</strong><ul><li>Spring 的一切能力都源于 <code>Core</code> 模块，<strong>IoC 是 Spring 的灵魂</strong></li><li>所有高级模块（MVC、Security、Cloud 等）都依赖于 Spring Core 的 Bean 容器与上下文机制</li></ul></li></ul><hr><h2 id="_2-spring-core-在整个-spring-生态中的地位" tabindex="-1"><a class="header-anchor" href="#_2-spring-core-在整个-spring-生态中的地位"><span>2. Spring Core 在整个 Spring 生态中的地位</span></a></h2><ul><li><p><strong>生态总览</strong></p><ul><li><code>Spring Core</code>：基础依赖注入与容器机制</li><li><code>Spring AOP</code>：切面编程</li><li><code>Spring Context</code>：应用上下文（ApplicationContext）</li><li><code>Spring Beans</code>：Bean 定义与生命周期控制</li><li><code>Spring Expression</code>：动态表达式语言（SpEL）</li></ul></li><li><p><strong>上下游关系</strong></p><ul><li>Spring Core → 支撑所有模块，如 Boot、MVC、Security、Cloud</li><li>没有 Core，Spring Boot/MVC 只是壳子</li></ul></li><li><p><strong>架构图展示建议</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Spring Boot / Spring MVC / Spring Security / Spring Data</span></span>
<span class="line"><span>       ↓               ↓                ↓              ↓</span></span>
<span class="line"><span>              →→→→ Spring Core ←←←←←</span></span>
<span class="line"><span>               |      |      |       |</span></span>
<span class="line"><span>            Beans  Context  Core   Expression</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h2 id="_3-spring-core-模块结构简介" tabindex="-1"><a class="header-anchor" href="#_3-spring-core-模块结构简介"><span>3. Spring Core 模块结构简介</span></a></h2><ul><li><strong>spring-core</strong> 模块 <ul><li>提供基本工具类（反射、集合、资源加载、类型转换）</li><li>是 <code>spring-context</code>、<code>spring-beans</code> 等模块的基础依赖</li></ul></li><li><strong>spring-beans</strong> 模块 <ul><li>核心职责：Bean 定义、装配、作用域、依赖注入、生命周期管理</li><li>核心接口/类：<code>BeanFactory</code>, <code>BeanDefinition</code>, <code>BeanWrapper</code></li></ul></li><li><strong>spring-context</strong> 模块 <ul><li>构建 <code>ApplicationContext</code> 容器：事件发布、国际化、资源加载</li><li>集成 BeanFactory 并扩展：提供更丰富的应用层支持</li></ul></li><li><strong>spring-expression</strong> 模块（SpEL） <ul><li>支持表达式语法，进行动态值注入、条件判断</li><li>在配置文件、注解中可插入表达式，如 <code>@Value(&quot;#{systemProperties[&#39;user.home&#39;]}&quot;)</code></li></ul></li></ul><h1 id="二、控制反转-ioc-核心原理-1" tabindex="-1"><a class="header-anchor" href="#二、控制反转-ioc-核心原理-1"><span>二、控制反转（IoC）核心原理</span></a></h1><hr><h2 id="什么是-ioc-与传统开发模式的对比" tabindex="-1"><a class="header-anchor" href="#什么是-ioc-与传统开发模式的对比"><span>什么是 IoC？与传统开发模式的对比</span></a></h2><h3 id="控制反转-inversion-of-control-ioc-定义" tabindex="-1"><a class="header-anchor" href="#控制反转-inversion-of-control-ioc-定义"><span>控制反转（Inversion of Control，IoC）定义：</span></a></h3><p>IoC 是一种<strong>思想</strong>，指对象的创建与依赖关系的管理不再由开发者手动控制，而是<strong>交由容器</strong>统一负责。这种“控制权”的反转，正是 IoC 命名的来源。</p><h3 id="传统开发-vs-ioc-开发模式对比" tabindex="-1"><a class="header-anchor" href="#传统开发-vs-ioc-开发模式对比"><span>传统开发 vs IoC 开发模式对比：</span></a></h3><table><thead><tr><th>传统方式</th><th>IoC 方式（由容器控制）</th></tr></thead><tbody><tr><td>开发者手动创建依赖对象</td><td>容器负责创建与装配对象</td></tr><tr><td>对象之间直接 <code>new</code> 引用</td><td>通过配置或注解由容器注入依赖</td></tr><tr><td>对象耦合度高，测试困难</td><td>对象解耦，可轻松 mock 测试</td></tr><tr><td>配置分散或硬编码</td><td>统一由容器管理 Bean 生命周期与依赖</td></tr></tbody></table><h3 id="举例说明" tabindex="-1"><a class="header-anchor" href="#举例说明"><span>举例说明：</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 传统方式</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Service</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> service </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ServiceImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Controller</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> controller </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Controller</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(service)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Spring IoC 方式</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ServiceImpl</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Controller</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Service</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> service</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="ioc-容器的种类-beanfactory-vs-applicationcontext" tabindex="-1"><a class="header-anchor" href="#ioc-容器的种类-beanfactory-vs-applicationcontext"><span>IoC 容器的种类：<code>BeanFactory</code> vs <code>ApplicationContext</code></span></a></h2><h3 id="_1-beanfactory-基本容器接口" tabindex="-1"><a class="header-anchor" href="#_1-beanfactory-基本容器接口"><span>1. <code>BeanFactory</code>（基本容器接口）：</span></a></h3><ul><li><strong>懒加载</strong>：只有在调用 <code>getBean()</code> 时才实例化 Bean</li><li><strong>轻量级</strong>：适合资源受限的环境或简单场景</li><li><strong>接口定义</strong>：最底层的 IoC 容器接口，<code>ApplicationContext</code> 的父接口</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BeanFactory</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> factory </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> XmlBeanFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> FileSystemResource</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;beans.xml&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">))</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MyBean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bean </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> factory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myBean&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-applicationcontext-高级容器" tabindex="-1"><a class="header-anchor" href="#_2-applicationcontext-高级容器"><span>2. <code>ApplicationContext</code>（高级容器）：</span></a></h3><ul><li><strong>预加载</strong>：容器启动时一次性实例化所有单例 Bean</li><li><strong>支持国际化、事件发布、AOP、资源加载等</strong></li><li><strong>常用实现类</strong>： <ul><li><code>ClassPathXmlApplicationContext</code></li><li><code>AnnotationConfigApplicationContext</code></li><li><code>WebApplicationContext</code>（Spring MVC）</li></ul></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ApplicationContext</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> context </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ClassPathXmlApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;beans.xml&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MyBean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bean </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> context</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MyBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结比较" tabindex="-1"><a class="header-anchor" href="#总结比较"><span>总结比较：</span></a></h3><table><thead><tr><th>特性</th><th><code>BeanFactory</code></th><th><code>ApplicationContext</code></th></tr></thead><tbody><tr><td>实例化方式</td><td>懒加载</td><td>预加载</td></tr><tr><td>是否支持国际化</td><td>否</td><td>是</td></tr><tr><td>是否支持事件监听</td><td>否</td><td>是</td></tr><tr><td>是否支持自动装配</td><td>否（需手动管理）</td><td>是</td></tr><tr><td>是否支持 AOP</td><td>否</td><td>是</td></tr></tbody></table><hr><h2 id="ioc-的作用与好处-解耦、可测试性、灵活性" tabindex="-1"><a class="header-anchor" href="#ioc-的作用与好处-解耦、可测试性、灵活性"><span>IoC 的作用与好处：解耦、可测试性、灵活性</span></a></h2><h3 id="_1-解耦架构-decoupling" tabindex="-1"><a class="header-anchor" href="#_1-解耦架构-decoupling"><span>1. 解耦架构（Decoupling）</span></a></h3><ul><li>类与类之间通过接口而非实现耦合</li><li>组件可独立扩展或替换，无需更改调用方代码</li></ul><h3 id="_2-提高可测试性-testability" tabindex="-1"><a class="header-anchor" href="#_2-提高可测试性-testability"><span>2. 提高可测试性（Testability）</span></a></h3><ul><li>单元测试中可轻松替换 Bean（mock/fake）</li><li>依赖注入使得构造器或属性更容易模拟</li></ul><h3 id="_3-灵活配置-flexibility" tabindex="-1"><a class="header-anchor" href="#_3-灵活配置-flexibility"><span>3. 灵活配置（Flexibility）</span></a></h3><ul><li>支持 XML 配置、Java 注解、Java Config 等多种方式注入依赖</li><li>支持条件装配（<code>@Conditional</code>）、Profile 区分环境配置</li></ul><h3 id="_4-统一管理生命周期" tabindex="-1"><a class="header-anchor" href="#_4-统一管理生命周期"><span>4. 统一管理生命周期</span></a></h3><ul><li>容器负责 Bean 的创建、初始化、销毁等生命周期管理</li><li>支持生命周期回调（<code>InitializingBean</code>、<code>DisposableBean</code>、<code>@PostConstruct</code>）</li></ul><hr><h1 id="三、依赖注入-di-机制详解-1" tabindex="-1"><a class="header-anchor" href="#三、依赖注入-di-机制详解-1"><span>三、依赖注入（DI）机制详解</span></a></h1><p>依赖注入（Dependency Injection）是控制反转（IoC）的具体实现方式，它让对象的依赖关系不再由自己创建，而是由 Spring 容器来“注入”，实现高度解耦。</p><hr><h2 id="_1-依赖注入的三种方式" tabindex="-1"><a class="header-anchor" href="#_1-依赖注入的三种方式"><span>1. 依赖注入的三种方式</span></a></h2><p>Spring 支持以下三种基本注入方式（XML 或注解均适用）：</p><h3 id="•-构造器注入-constructor-injection-✅推荐" tabindex="-1"><a class="header-anchor" href="#•-构造器注入-constructor-injection-✅推荐"><span>• 构造器注入（Constructor Injection）✅推荐</span></a></h3><p>适用于强依赖关系 —— 必须有这些依赖对象才能运行。优点是<strong>依赖不可变</strong>、便于单元测试。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserRepository</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> repo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> UserService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">UserRepository</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> repo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">repo</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> repo;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="•-setter-方法注入-setter-injection" tabindex="-1"><a class="header-anchor" href="#•-setter-方法注入-setter-injection"><span>• Setter 方法注入（Setter Injection）</span></a></h3><p>适用于可选依赖或需要延迟初始化的依赖。可读性高，但可能出现部分依赖未注入的问题。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> OrderService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> EmailSender</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">EmailSender</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> sender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">sender</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sender;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="•-接口注入-了解即可" tabindex="-1"><a class="header-anchor" href="#•-接口注入-了解即可"><span>• 接口注入（了解即可）</span></a></h3><p>通过实现特定接口（如<code>Aware</code>接口）来获取容器资源。使用场景非常少，不推荐业务逻辑中使用。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CustomBean</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ApplicationContextAware</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ApplicationContext</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> context</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 获取容器信息</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2-注解方式的依赖注入" tabindex="-1"><a class="header-anchor" href="#_2-注解方式的依赖注入"><span>2. 注解方式的依赖注入</span></a></h2><p>Spring 通过注解简化了配置，大大提高开发效率：</p><ul><li><strong><code>@Autowired</code></strong>：默认按类型注入，支持构造器、方法、字段。</li><li><strong><code>@Qualifier(&quot;beanName&quot;)</code></strong>：与 <code>@Autowired</code> 配合按名称注入，解决同类型多实现问题。</li><li><strong><code>@Inject</code></strong>：JSR-330 标准注解，功能等价于 <code>@Autowired</code>，但不能用于 <code>required = false</code>。</li><li><strong><code>@Value(&quot;\${config.value}&quot;)</code></strong>：注入配置文件中的值或常量。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> EmailService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Qualifier</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;smtpSender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;\${email.timeout}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> timeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-xml-配置-vs-java-配置" tabindex="-1"><a class="header-anchor" href="#_3-xml-配置-vs-java-配置"><span>3. XML 配置 vs Java 配置</span></a></h2><table><thead><tr><th>特性</th><th>XML 配置</th><th>Java 配置（@Configuration）</th></tr></thead><tbody><tr><td>可读性</td><td>清晰但冗长</td><td>简洁直观，配合注解更优</td></tr><tr><td>灵活性</td><td>高，适合条件化配置</td><td>更适合现代自动化配置</td></tr><tr><td>维护成本</td><td>高</td><td>低</td></tr></tbody></table><p>建议：<strong>Spring Boot 项目应优先使用 Java 配置 + 注解注入。</strong></p><hr><h2 id="_4-集合类型的依赖注入" tabindex="-1"><a class="header-anchor" href="#_4-集合类型的依赖注入"><span>4. 集合类型的依赖注入</span></a></h2><p>Spring 可以自动注入集合类型，如 <code>List&lt;Bean&gt;</code>、<code>Map&lt;String, Bean&gt;</code>，可按顺序或名称注入多个实现。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MultiHandlerService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> List</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Handler</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> handlerList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Map</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Handler</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> handlerMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>若需要排序，可使用 <code>@Order</code> 或 <code>@Priority</code> 注解实现。</p></blockquote><hr><h2 id="_5-注入顺序与优先级控制" tabindex="-1"><a class="header-anchor" href="#_5-注入顺序与优先级控制"><span>5. 注入顺序与优先级控制</span></a></h2><ul><li><strong>多候选 Bean 时</strong>： <ul><li><code>@Primary</code>：默认优先注入此 Bean。</li><li><code>@Qualifier</code>：指定注入 Bean 名称。</li></ul></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Primary</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DefaultSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;emailSender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> EmailSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Qualifier</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;emailSender&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 注入指定实现</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>注入时机控制</strong>： <ul><li><code>@Lazy</code>：懒加载 Bean，直到第一次使用才创建。</li><li><code>@DependsOn</code>：指定依赖的 Bean 初始化顺序。</li></ul></li></ul><hr><h1 id="四、bean-的定义与装配方式-1" tabindex="-1"><a class="header-anchor" href="#四、bean-的定义与装配方式-1"><span>四、Bean 的定义与装配方式</span></a></h1><p>Spring IoC 容器的本质就是维护了一张 Bean 的注册表，Bean 的定义（Definition）与装配（Wiring）决定了容器中如何创建、管理和注入这些 Bean。</p><hr><h2 id="_1-手动配置-bean" tabindex="-1"><a class="header-anchor" href="#_1-手动配置-bean"><span>1. 手动配置 Bean</span></a></h2><h3 id="•-bean-注解方式-javaconfig-✅现代主流推荐" tabindex="-1"><a class="header-anchor" href="#•-bean-注解方式-javaconfig-✅现代主流推荐"><span>• <code>@Bean</code> 注解方式（JavaConfig）✅现代主流推荐</span></a></h3><p>结合 <code>@Configuration</code> 类使用，手动定义 Bean 并注册到容器中。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> userService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> UserServiceImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点</strong>：</p><ul><li>类型安全、可重构</li><li>容易与第三方库集成（无法加 <code>@Component</code> 的类）</li></ul><hr><h3 id="•-xml-配置方式-传统-🔧了解即可" tabindex="-1"><a class="header-anchor" href="#•-xml-配置方式-传统-🔧了解即可"><span>• XML 配置方式（传统）🔧了解即可</span></a></h3><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">beans</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;userService&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;com.example.UserServiceImpl&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">beans</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>适用场景</strong>：</p><ul><li>老项目维护</li><li>Bean 的定义动态可扩展（如读取外部配置）</li></ul><hr><h3 id="•-javaconfig-vs-xml-配置对比" tabindex="-1"><a class="header-anchor" href="#•-javaconfig-vs-xml-配置对比"><span>• JavaConfig vs XML 配置对比</span></a></h3><table><thead><tr><th>特性</th><th>JavaConfig</th><th>XML 配置</th></tr></thead><tbody><tr><td>可读性</td><td>更强，IDE 支持好</td><td>冗长，不易重构</td></tr><tr><td>灵活性</td><td>支持条件化、Profile 等注解</td><td>配置灵活，表达力强</td></tr><tr><td>推荐程度</td><td>✅现代项目主流方案</td><td>维护旧系统时使用</td></tr></tbody></table><hr><h2 id="_2-自动装配-基于注解" tabindex="-1"><a class="header-anchor" href="#_2-自动装配-基于注解"><span>2. 自动装配（基于注解）</span></a></h2><p>Spring 通过扫描指定包下的类，自动将加了特定注解的类注册为 Bean：</p><h3 id="常用注解" tabindex="-1"><a class="header-anchor" href="#常用注解"><span>常用注解：</span></a></h3><ul><li><code>@Component</code>：通用组件</li><li><code>@Service</code>：标注业务逻辑层</li><li><code>@Repository</code>：标注持久层（并启用异常翻译机制）</li><li><code>@Controller</code> / <code>@RestController</code>：Web 层控制器</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> EmailSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MessageSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>需要配合 <code>@ComponentScan</code> 或 Spring Boot 自动扫描：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ComponentScan</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;com.example.service&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-条件化装配-conditional-装配" tabindex="-1"><a class="header-anchor" href="#_3-条件化装配-conditional-装配"><span>3. 条件化装配（Conditional 装配）</span></a></h2><p>Spring 提供了条件装配的能力，使得 Bean 是否被注册取决于某些条件。</p><h3 id="•-conditional-按自定义条件注册-bean" tabindex="-1"><a class="header-anchor" href="#•-conditional-按自定义条件注册-bean"><span>• <code>@Conditional</code>：按自定义条件注册 Bean</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Conditional</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">WindowsCondition</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FileSystem</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fileSystem</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> WindowsFileSystem</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以根据环境变量、类路径、系统属性等编写条件类。</p><h3 id="•-profile-根据环境进行装配切换" tabindex="-1"><a class="header-anchor" href="#•-profile-根据环境进行装配切换"><span>• <code>@Profile</code>：根据环境进行装配切换</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Profile</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;dev&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DataSource</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> devDataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> H2DataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可通过 <code>spring.profiles.active=dev</code> 来激活。</p><blockquote><p>适用于开发、测试、生产环境的 Bean 切换，非常常用。</p></blockquote><hr><h2 id="_4-工厂方法与静态工厂装配" tabindex="-1"><a class="header-anchor" href="#_4-工厂方法与静态工厂装配"><span>4. 工厂方法与静态工厂装配</span></a></h2><h3 id="•-静态工厂方法" tabindex="-1"><a class="header-anchor" href="#•-静态工厂方法"><span>• 静态工厂方法：</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> MyServiceFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">createInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="•-实例工厂方法" tabindex="-1"><a class="header-anchor" href="#•-实例工厂方法"><span>• 实例工厂方法：</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MyServiceFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> factory) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> factory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用场景</strong>：</p><ul><li>第三方库对象的构建不受你控制（如 JDBC 驱动、复杂工具类）</li><li>对象创建逻辑复杂，需要自定义构建逻辑</li></ul><hr><p>总结一下：</p><table><thead><tr><th>装配方式</th><th>推荐级别</th><th>适用场景</th></tr></thead><tbody><tr><td>注解自动装配</td><td>✅ 强烈推荐</td><td>常规开发，大多数 Bean</td></tr><tr><td><code>@Bean</code> JavaConfig</td><td>✅ 推荐</td><td>控制精细或第三方类注入</td></tr><tr><td>条件化装配</td><td>✅ 推荐</td><td>环境隔离，插件化架构</td></tr><tr><td>XML</td><td>🔧 不推荐</td><td>老项目迁移，特殊脚本生成</td></tr><tr><td>工厂方法</td><td>⚙️ 可选</td><td>控制对象创建逻辑</td></tr></tbody></table><h1 id="五、bean-的生命周期与容器初始化流程" tabindex="-1"><a class="header-anchor" href="#五、bean-的生命周期与容器初始化流程"><span>五、Bean 的生命周期与容器初始化流程</span></a></h1><p>Spring 中的 Bean 并不是简单的“创建即使用”，它经历了一个完整的生命周期过程，从实例化到销毁，每一步都可被开发者自定义和干预。这一机制使得 Spring 框架高度灵活，也提高了组件的可控性和扩展能力。</p><hr><h2 id="_1-bean-的生命周期阶段-全流程" tabindex="-1"><a class="header-anchor" href="#_1-bean-的生命周期阶段-全流程"><span>1. Bean 的生命周期阶段（全流程）</span></a></h2><ol><li><strong>实例化（Instantiation）</strong> 通过构造器或工厂方法创建 Bean 实例。</li><li><strong>属性填充（Populate Properties）</strong> Spring 将依赖的其他 Bean 注入到当前 Bean 中。</li><li><strong>感知接口回调（Aware 回调）</strong> 如果 Bean 实现了某些 Aware 接口（如 <code>BeanNameAware</code>），容器会回调这些接口。</li><li><strong>初始化前处理（BeanPostProcessor#postProcessBeforeInitialization）</strong> 所有注册的 <code>BeanPostProcessor</code> 会在初始化前调用。</li><li><strong>初始化（InitializingBean 或 @PostConstruct）</strong> 初始化逻辑被执行，可以通过接口或注解实现。</li><li><strong>初始化后处理（BeanPostProcessor#postProcessAfterInitialization）</strong> 再次通过 <code>BeanPostProcessor</code> 进行增强（如 AOP 代理等）。</li><li><strong>就绪使用（Ready）</strong> Bean 准备就绪，可以被业务逻辑使用。</li><li><strong>销毁阶段（DisposableBean 或 @PreDestroy）</strong> 在容器关闭时，执行销毁逻辑。</li></ol><hr><h2 id="_2-生命周期相关接口与注解" tabindex="-1"><a class="header-anchor" href="#_2-生命周期相关接口与注解"><span>2. 生命周期相关接口与注解</span></a></h2><table><thead><tr><th>方式</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>InitializingBean</code></td><td>初始化回调接口</td><td><code>afterPropertiesSet()</code></td></tr><tr><td><code>DisposableBean</code></td><td>销毁回调接口</td><td><code>destroy()</code></td></tr><tr><td><code>@PostConstruct</code></td><td>初始化方法注解</td><td>推荐，优雅可读</td></tr><tr><td><code>@PreDestroy</code></td><td>销毁方法注解</td><td>与 <code>@PostConstruct</code> 配对使用</td></tr><tr><td><code>BeanPostProcessor</code></td><td>对所有 Bean 初始化前后进行增强</td><td>常用于 AOP、日志、代理等</td></tr><tr><td><code>BeanFactoryPostProcessor</code></td><td>修改 BeanDefinition</td><td>用于容器启动阶段</td></tr></tbody></table><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例：</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyBean</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InitializingBean</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DisposableBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">PostConstruct</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> init</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;PostConstruct 初始化方法&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> afterPropertiesSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;InitializingBean 初始化方法&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">PreDestroy</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> destroyMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;PreDestroy 销毁方法&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> destroy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;DisposableBean 销毁方法&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-spring-容器初始化流程简要图解" tabindex="-1"><a class="header-anchor" href="#_3-spring-容器初始化流程简要图解"><span>3. Spring 容器初始化流程简要图解</span></a></h2><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>启动 -&gt; 创建 ApplicationContext -&gt;</span></span>
<span class="line"><span>加载配置/扫描注解 -&gt;</span></span>
<span class="line"><span>注册 BeanDefinition -&gt;</span></span>
<span class="line"><span>创建 Bean（实例化 + 填充属性） -&gt;</span></span>
<span class="line"><span>执行 BeanPostProcessor -&gt;</span></span>
<span class="line"><span>初始化 -&gt; AOP 等增强 -&gt;</span></span>
<span class="line"><span>Bean 准备就绪</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-扩展点-beanpostprocessor-与-beanfactorypostprocessor" tabindex="-1"><a class="header-anchor" href="#_4-扩展点-beanpostprocessor-与-beanfactorypostprocessor"><span>4. 扩展点：BeanPostProcessor 与 BeanFactoryPostProcessor</span></a></h2><h3 id="•-beanpostprocessor-运行时增强-bean" tabindex="-1"><a class="header-anchor" href="#•-beanpostprocessor-运行时增强-bean"><span>• <code>BeanPostProcessor</code>（运行时增强 Bean）</span></a></h3><p>可用于修改 Bean 的逻辑或增强其功能（如实现 AOP）。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CustomBeanPostProcessor</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanPostProcessor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> postProcessBeforeInitialization</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> bean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 逻辑增强</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> bean;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="•-beanfactorypostprocessor-修改配置元信息" tabindex="-1"><a class="header-anchor" href="#•-beanfactorypostprocessor-修改配置元信息"><span>• <code>BeanFactoryPostProcessor</code>（修改配置元信息）</span></a></h3><p>在 Bean 实例化之前对 <code>BeanDefinition</code> 进行修改，常用于框架设计者提供自定义行为。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyFactoryPostProcessor</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanFactoryPostProcessor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> postProcessBeanFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ConfigurableListableBeanFactory</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> factory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 动态修改某些 Bean 的定义</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_5-生命周期的实际应用场景" tabindex="-1"><a class="header-anchor" href="#_5-生命周期的实际应用场景"><span>5. 生命周期的实际应用场景</span></a></h2><ul><li><strong>资源管理</strong>：连接池、线程池在初始化与销毁阶段创建/释放资源。</li><li><strong>动态代理增强</strong>：如 AOP 功能是通过 <code>BeanPostProcessor</code> 实现的。</li><li><strong>配置中心</strong>：容器初始化时读取配置并注入（如 Nacos、Apollo）。</li><li><strong>插件机制</strong>：在容器启动时动态注册、创建、装配插件 Bean。</li></ul><h1 id="六、spring-容器的启动流程-1" tabindex="-1"><a class="header-anchor" href="#六、spring-容器的启动流程-1"><span>六、Spring 容器的启动流程</span></a></h1><p>Spring 容器的启动流程是理解整个依赖注入机制、组件扫描、配置解析和 Bean 初始化的重要基础。这部分涉及到底层核心类的协作过程，是构建对 Spring 框架认知体系的关键环节。</p><hr><h2 id="_1-容器的创建流程-从-annotationconfigapplicationcontext-开始" tabindex="-1"><a class="header-anchor" href="#_1-容器的创建流程-从-annotationconfigapplicationcontext-开始"><span>1. 容器的创建流程：从 AnnotationConfigApplicationContext 开始</span></a></h2><p>在现代 Spring 应用中，最常见的容器初始化方式如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">AnnotationConfigApplicationContext</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> context </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> AnnotationConfigApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个构造过程，实际上包含了如下几个核心阶段：</p><h3 id="✅-步骤一-创建容器实例" tabindex="-1"><a class="header-anchor" href="#✅-步骤一-创建容器实例"><span>✅ 步骤一：创建容器实例</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> AnnotationConfigApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> annotatedClasses</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>初始化 <code>DefaultListableBeanFactory</code>（核心 Bean 注册与管理工厂）</li><li>准备内部的环境变量（Environment）</li><li>初始化读取器 <code>AnnotatedBeanDefinitionReader</code></li><li>初始化扫描器 <code>ClassPathBeanDefinitionScanner</code></li></ul><h3 id="✅-步骤二-注册配置类" tabindex="-1"><a class="header-anchor" href="#✅-步骤二-注册配置类"><span>✅ 步骤二：注册配置类</span></a></h3><p>调用 <code>register(AppConfig.class)</code>，将配置类注册为 <code>BeanDefinition</code>。</p><h3 id="✅-步骤三-刷新容器-refresh" tabindex="-1"><a class="header-anchor" href="#✅-步骤三-刷新容器-refresh"><span>✅ 步骤三：刷新容器 <code>refresh()</code></span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">context</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">refresh</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是整个启动流程的核心方法，内部步骤包括：</p><ol><li><strong>准备阶段</strong>：准备 BeanFactory、环境、监听器</li><li><strong>加载 Bean 定义</strong>：扫描注解并注册为 BeanDefinition</li><li><strong>Bean 创建阶段</strong>： <ul><li>实例化非懒加载的单例 Bean</li><li>依赖注入、生命周期管理</li></ul></li><li><strong>完成阶段</strong>：容器就绪，发出 ContextRefreshedEvent 事件</li></ol><hr><h2 id="_2-spring-启动流程中的关键接口与类" tabindex="-1"><a class="header-anchor" href="#_2-spring-启动流程中的关键接口与类"><span>2. Spring 启动流程中的关键接口与类</span></a></h2><p>理解这些核心接口，是解构 Spring 启动机制的关键：</p><table><thead><tr><th>类/接口</th><th>作用</th></tr></thead><tbody><tr><td><code>BeanDefinition</code></td><td>Bean 的抽象定义，包括类名、作用域、依赖等</td></tr><tr><td><code>BeanDefinitionRegistry</code></td><td>Bean 注册中心，提供 <code>registerBeanDefinition()</code> 方法</td></tr><tr><td><code>BeanDefinitionReader</code></td><td>读取 Bean 定义（注解、XML、Groovy 等）</td></tr><tr><td><code>AnnotationConfigApplicationContext</code></td><td>注解驱动的容器实现类</td></tr><tr><td><code>AnnotatedBeanDefinitionReader</code></td><td>处理 <code>@Component</code>, <code>@Configuration</code> 类</td></tr><tr><td><code>ClassPathBeanDefinitionScanner</code></td><td>实现 <code>@ComponentScan</code> 包扫描并注册 Bean</td></tr></tbody></table><hr><h2 id="_3-注解驱动容器启动的原理" tabindex="-1"><a class="header-anchor" href="#_3-注解驱动容器启动的原理"><span>3. 注解驱动容器启动的原理</span></a></h2><p>现代 Spring 应用中，注解驱动的组件扫描和配置类处理是核心手段。其原理依赖以下两点：</p><h3 id="🔹-configuration-配置类" tabindex="-1"><a class="header-anchor" href="#🔹-configuration-配置类"><span>🔹 @Configuration 配置类</span></a></h3><ul><li>标识该类为配置类，内部定义的是 <code>@Bean</code> 或组件注册逻辑。</li><li>被 <code>AnnotatedBeanDefinitionReader</code> 注册到容器中。</li></ul><h3 id="🔹-componentscan-扫描组件" tabindex="-1"><a class="header-anchor" href="#🔹-componentscan-扫描组件"><span>🔹 @ComponentScan 扫描组件</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ComponentScan</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">basePackages</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;com.example&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>由 <code>ClassPathBeanDefinitionScanner</code> 执行，扫描指定包路径下所有标注了 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等的类。</li><li>每个类都被封装为一个 <code>BeanDefinition</code>，然后注册到容器中。</li></ul><hr><h2 id="_4-容器启动过程时序图-简化版" tabindex="-1"><a class="header-anchor" href="#_4-容器启动过程时序图-简化版"><span>4. 容器启动过程时序图（简化版）</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>new AnnotationConfigApplicationContext(AppConfig.class)</span></span>
<span class="line"><span>          │</span></span>
<span class="line"><span>          ├── 初始化 BeanFactory</span></span>
<span class="line"><span>          ├── 注册配置类为 BeanDefinition</span></span>
<span class="line"><span>          └── refresh()</span></span>
<span class="line"><span>                 ├── prepareRefresh()</span></span>
<span class="line"><span>                 ├── invokeBeanFactoryPostProcessors()</span></span>
<span class="line"><span>                 ├── registerBeanPostProcessors()</span></span>
<span class="line"><span>                 ├── instantiate singleton beans</span></span>
<span class="line"><span>                 └── finishRefresh()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_5-spring-容器启动的实际价值" tabindex="-1"><a class="header-anchor" href="#_5-spring-容器启动的实际价值"><span>5. Spring 容器启动的实际价值</span></a></h2><ul><li>为 AOP、事务、注解注入等功能打下基础</li><li>完善的生命周期控制保证了资源管理的可预测性</li><li>支持大规模系统的模块化与可插拔架构</li></ul><h1 id="七、注解驱动机制详解-1" tabindex="-1"><a class="header-anchor" href="#七、注解驱动机制详解-1"><span>七、注解驱动机制详解</span></a></h1><p>在 Spring 中，注解驱动的配置方式简化了传统的 XML 配置，使得开发更加灵活、易于理解。Spring 通过注解的方式，让开发者能够以声明式的方式定义 Bean 和容器行为。接下来详细介绍一些常用的 Spring 注解，以及如何通过注解实现更高效的配置和扩展。</p><hr><h2 id="_1-component、-service、-repository、-controller-的区别与应用" tabindex="-1"><a class="header-anchor" href="#_1-component、-service、-repository、-controller-的区别与应用"><span>1. <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 的区别与应用</span></a></h2><h4 id="component" tabindex="-1"><a class="header-anchor" href="#component"><span><code>@Component</code></span></a></h4><p><code>@Component</code> 是 Spring 最基础的注解，用于标识一个类是一个 Spring 容器管理的 Bean。这个注解通常用于通用的类，它是 <code>@Repository</code>、<code>@Service</code> 和 <code>@Controller</code> 的父类。实际上，它并没有特定的语义，只是简单地声明该类是一个组件，被 Spring 容器托管。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyComponent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="service" tabindex="-1"><a class="header-anchor" href="#service"><span><code>@Service</code></span></a></h4><p><code>@Service</code> 注解通常用于标记服务层的类，表示该类提供某种业务逻辑处理。在语义上，<code>@Service</code> 用于服务层的类，它继承了 <code>@Component</code>，作用上和 <code>@Component</code> 一样，但是在语义上提供了更多的可读性，便于理解类的职责。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 服务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="repository" tabindex="-1"><a class="header-anchor" href="#repository"><span><code>@Repository</code></span></a></h4><p><code>@Repository</code> 注解用于 DAO（数据访问对象）层，表示该类是用来进行数据持久化操作的。在 <code>@Repository</code> 中，Spring 会提供额外的功能，如数据访问异常的转换，将数据库层的异常转换为 Spring 的 DataAccessException。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Repository</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyRepository</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 数据访问逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="controller" tabindex="-1"><a class="header-anchor" href="#controller"><span><code>@Controller</code></span></a></h4><p><code>@Controller</code> 注解用于标识一个控制器类，该类负责处理用户请求。在 Spring MVC 中，<code>@Controller</code> 标记的类通常用于 Web 层的逻辑处理，负责返回视图或处理请求。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Controller</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 请求处理逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2-元注解解析-target、-retention、-documented、-inherited" tabindex="-1"><a class="header-anchor" href="#_2-元注解解析-target、-retention、-documented、-inherited"><span>2. 元注解解析：<code>@Target</code>、<code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code></span></a></h2><h4 id="target" tabindex="-1"><a class="header-anchor" href="#target"><span><code>@Target</code></span></a></h4><p><code>@Target</code> 注解用于指定该注解可以应用于哪些 Java 元素。例如，<code>@Target(ElementType.METHOD)</code> 表示该注解只能应用于方法上。常见的 <code>ElementType</code> 包括：<code>TYPE</code>（类、接口、枚举）、<code>METHOD</code>（方法）、<code>FIELD</code>（字段）、<code>PARAMETER</code>（方法参数）等。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Target</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ElementType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TYPE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> MyAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 注解定义</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="retention" tabindex="-1"><a class="header-anchor" href="#retention"><span><code>@Retention</code></span></a></h4><p><code>@Retention</code> 注解用于指定该注解的生命周期。常见的 <code>RetentionPolicy</code> 有：</p><ul><li><code>SOURCE</code>：注解仅存在于源码中，编译后被丢弃。</li><li><code>CLASS</code>：注解在类文件中存在，但在运行时不可访问。</li><li><code>RUNTIME</code>：注解在运行时存在，可以通过反射进行访问。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Retention</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RetentionPolicy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RUNTIME</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> MyAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 注解定义</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="documented" tabindex="-1"><a class="header-anchor" href="#documented"><span><code>@Documented</code></span></a></h4><p><code>@Documented</code> 注解表明使用该注解的元素应当被 javadoc 工具包含在生成的文档中。通常，用于那些希望出现在 API 文档中的注解。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Documented</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> MyAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 注解定义</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="inherited" tabindex="-1"><a class="header-anchor" href="#inherited"><span><code>@Inherited</code></span></a></h4><p><code>@Inherited</code> 表示一个注解可以被子类继承。子类如果没有声明该注解，它会自动继承父类的该注解。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Inherited</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> MyAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 注解定义</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-自定义注解与组合注解实践" tabindex="-1"><a class="header-anchor" href="#_3-自定义注解与组合注解实践"><span>3. 自定义注解与组合注解实践</span></a></h2><h4 id="自定义注解" tabindex="-1"><a class="header-anchor" href="#自定义注解"><span>自定义注解</span></a></h4><p>在 Spring 中，可以创建自定义注解，以便更好地封装和复用。自定义注解可以结合元注解使用，定义自己的注解类型。例如，创建一个自定义的 <code>@MyAnnotation</code>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Target</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ElementType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">METHOD</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Retention</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RetentionPolicy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RUNTIME</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> MyAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">default</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;default&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="组合注解" tabindex="-1"><a class="header-anchor" href="#组合注解"><span>组合注解</span></a></h4><p>组合注解是将多个注解合并为一个注解，用于减少代码的冗余。例如，可以将 <code>@Component</code>、<code>@Service</code> 和 <code>@Transactional</code> 组合为一个注解：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Target</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ElementType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TYPE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Retention</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RetentionPolicy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RUNTIME</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-componentscan-原理解析与包扫描机制" tabindex="-1"><a class="header-anchor" href="#_4-componentscan-原理解析与包扫描机制"><span>4. <code>@ComponentScan</code> 原理解析与包扫描机制</span></a></h2><h4 id="componentscan-原理" tabindex="-1"><a class="header-anchor" href="#componentscan-原理"><span><code>@ComponentScan</code> 原理</span></a></h4><p><code>@ComponentScan</code> 注解用于启用 Spring 容器的组件扫描功能，它通过扫描指定包及其子包下的类，自动将标记为 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类注册为 Spring Bean。默认情况下，<code>@ComponentScan</code> 会扫描当前类所在的包，但也可以通过 <code>basePackages</code> 属性指定要扫描的包。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ComponentScan</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">basePackages</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;com.example.myapp&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 配置类</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="包扫描机制" tabindex="-1"><a class="header-anchor" href="#包扫描机制"><span>包扫描机制</span></a></h4><p><code>@ComponentScan</code> 会扫描指定包下的所有类，并识别是否有 <code>@Component</code> 注解的类。如果有，它会将其作为 Spring Bean 注册到容器中。这种机制使得开发者能够以声明的方式，自动地将 Java 类注册为 Spring Bean，从而简化了传统 XML 配置中的 Bean 注册过程。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ComponentScan</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">basePackages</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;com.example.myapp&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 配置 Spring 容器扫描特定包的类</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>在 Spring 中，注解驱动机制让配置变得更为简洁和高效，通过常用注解（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 和 <code>@Controller</code>）可以轻松实现自动装配和 Bean 管理。结合自定义注解和组合注解，开发者可以在不同的应用场景中灵活使用注解，提升开发效率。同时，理解和使用 <code>@ComponentScan</code> 注解可以进一步简化包扫描过程，使得 Spring 容器能够自动管理大量 Bean。</p><h1 id="八、spring-表达式语言-spel-基础-1" tabindex="-1"><a class="header-anchor" href="#八、spring-表达式语言-spel-基础-1"><span>八、Spring 表达式语言（SpEL）基础</span></a></h1><p>Spring 表达式语言（SpEL）是 Spring 框架提供的一种强大的表达式语言，它允许在 Spring 配置中使用类似于 Java 语言的表达式来实现更复杂的逻辑。SpEL 可以用来访问对象属性、调用方法、操作集合等，在 Spring 配置中非常常见，尤其是与 <code>@Value</code> 注解的结合使用。</p><hr><h2 id="_1-spel-语法与常用操作-属性访问、方法调用、运算符、集合投影" tabindex="-1"><a class="header-anchor" href="#_1-spel-语法与常用操作-属性访问、方法调用、运算符、集合投影"><span>1. SpEL 语法与常用操作：属性访问、方法调用、运算符、集合投影</span></a></h2><h3 id="属性访问" tabindex="-1"><a class="header-anchor" href="#属性访问"><span>属性访问</span></a></h3><p>SpEL 允许通过表达式访问 Java 对象的属性。属性的访问使用 <code>.</code> 运算符。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{person.name}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> personName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>假设 <code>person</code> 是一个已有的对象，它有一个 <code>name</code> 属性，上面的 SpEL 表达式会获取 <code>person</code> 对象的 <code>name</code> 属性的值并赋值给 <code>personName</code>。</p><h3 id="方法调用" tabindex="-1"><a class="header-anchor" href="#方法调用"><span>方法调用</span></a></h3><p>SpEL 也允许调用对象的方法。方法调用语法与 Java 类似，使用 <code>()</code> 来调用方法。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{myBean.getName()}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，<code>myBean</code> 是 Spring 容器中一个名为 <code>myBean</code> 的 Bean，<code>getName()</code> 方法会被调用，并返回方法的结果。</p><h3 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符"><span>运算符</span></a></h3><p>SpEL 支持基本的算术运算符、逻辑运算符以及关系运算符。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{2 + 2}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sum</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{5 &gt; 3}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> isGreaterThan</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpEL 还支持更复杂的表达式，如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{T(java.lang.Math).PI}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> piValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的表达式会访问 <code>java.lang.Math</code> 类中的 <code>PI</code> 常量。</p><h3 id="集合投影" tabindex="-1"><a class="header-anchor" href="#集合投影"><span>集合投影</span></a></h3><p>SpEL 还支持对集合类型进行投影操作。投影操作类似于 SQL 中的 SELECT，用来对集合进行筛选或提取元素。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{list[0]}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> firstElement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 <code>list</code> 是一个集合，上面的表达式将提取集合中的第一个元素。</p><hr><h2 id="_2-spel-与-value、配置绑定的结合应用" tabindex="-1"><a class="header-anchor" href="#_2-spel-与-value、配置绑定的结合应用"><span>2. SpEL 与 <code>@Value</code>、配置绑定的结合应用</span></a></h2><h3 id="与-value-注解结合使用" tabindex="-1"><a class="header-anchor" href="#与-value-注解结合使用"><span>与 <code>@Value</code> 注解结合使用</span></a></h3><p><code>@Value</code> 注解可以直接与 SpEL 表达式结合，用来从 Spring 配置文件、环境变量或 Java Bean 中提取值。常见的用法如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{systemProperties[&#39;user.home&#39;]}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> userHome</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的表达式会获取系统属性中的 <code>user.home</code> 属性并将其赋值给 <code>userHome</code> 字段。</p><h3 id="配置绑定与-spel" tabindex="-1"><a class="header-anchor" href="#配置绑定与-spel"><span>配置绑定与 SpEL</span></a></h3><p>在 Spring 配置中，SpEL 还可以用于绑定外部配置文件中的值。例如，结合 <code>application.properties</code> 配置文件：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">myapp.name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">SpringApp</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">myapp.version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">1.0.0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">@Value(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{myProperties[&#39;myapp.name&#39;]}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">private String appName</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>myProperties</code> 是一个配置文件绑定的对象，<code>myapp.name</code> 将从外部属性文件中提取。</p><hr><h2 id="_3-spel-在条件装配、数据校验等场景中的实战" tabindex="-1"><a class="header-anchor" href="#_3-spel-在条件装配、数据校验等场景中的实战"><span>3. SpEL 在条件装配、数据校验等场景中的实战</span></a></h2><h3 id="条件装配" tabindex="-1"><a class="header-anchor" href="#条件装配"><span>条件装配</span></a></h3><p>SpEL 可以用来在 Spring 配置中实现条件装配。通过 SpEL 表达式，可以决定某个 Bean 是否应该被创建。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ConditionalOnExpression</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{systemProperties[&#39;os.name&#39;].contains(&#39;Windows&#39;)}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> windowsService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码通过 SpEL 表达式判断操作系统是否为 Windows，如果是，则注册 <code>windowsService</code> Bean。</p><h3 id="数据校验" tabindex="-1"><a class="header-anchor" href="#数据校验"><span>数据校验</span></a></h3><p>SpEL 还可以用于数据校验。在 Spring 中，可以利用 SpEL 来校验 Bean 属性的值。例如，使用 SpEL 进行简单的校验：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;#{T(java.lang.Integer).parseInt(&#39;123&#39;) &gt; 100}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> isValid</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 SpEL 表达式验证了 <code>123</code> 是否大于 100。如果条件成立，则 <code>isValid</code> 为 <code>true</code>，否则为 <code>false</code>。</p><h3 id="结合自定义注解进行数据校验" tabindex="-1"><a class="header-anchor" href="#结合自定义注解进行数据校验"><span>结合自定义注解进行数据校验</span></a></h3><p>除了内置的校验，SpEL 还可以与自定义注解结合使用，进行更复杂的校验逻辑。例如，可以使用 SpEL 在 Bean 的属性校验中根据某些条件来触发验证：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Target</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">({</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ElementType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">FIELD</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Retention</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RetentionPolicy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RUNTIME</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Constraint</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">validatedBy</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> CustomValidator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> CustomValidation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> message</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">default</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Invalid value&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Class</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">groups</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">default</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Class</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> extends Payload</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">payload</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">default</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> expression</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>CustomValidator</code> 中，您可以使用 SpEL 来解析 <code>expression</code>，并根据条件判断字段是否有效。</p><hr><h2 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h2><p>Spring 表达式语言（SpEL）是一个强大而灵活的工具，它允许开发者在 Spring 配置文件、注解和条件装配中使用表达式逻辑。通过 SpEL，开发者可以简化配置，增加灵活性，并且能够在运行时动态地评估条件、操作集合和对象。与 <code>@Value</code> 注解结合使用时，SpEL 在处理动态配置、属性绑定、条件装配和数据校验方面极为高效，是开发人员进行复杂配置的得力工具。</p><h1 id="九、源码视角下的依赖注入-1" tabindex="-1"><a class="header-anchor" href="#九、源码视角下的依赖注入-1"><span>九、源码视角下的依赖注入</span></a></h1><p>依赖注入（DI）是 Spring 核心特性之一，理解其实现过程对深入掌握 Spring 框架至关重要。从源码视角分析依赖注入机制，不仅有助于理解 Spring 容器的工作原理，还能帮助开发者更好地解决实际应用中的问题。以下从 Spring 源码中对依赖注入的实现进行解析。</p><hr><h2 id="_1-从-autowired-到-autowiredannotationbeanpostprocessor" tabindex="-1"><a class="header-anchor" href="#_1-从-autowired-到-autowiredannotationbeanpostprocessor"><span>1. 从 <code>@Autowired</code> 到 <code>AutowiredAnnotationBeanPostProcessor</code></span></a></h2><p><code>@Autowired</code> 注解是 Spring 用于实现依赖注入的关键注解之一。Spring 容器在启动时会通过一系列的处理器来扫描、解析和注入依赖对象。其中，<code>AutowiredAnnotationBeanPostProcessor</code> 是完成依赖注入的核心类。</p><h3 id="autowired-注解的解析流程" tabindex="-1"><a class="header-anchor" href="#autowired-注解的解析流程"><span><code>@Autowired</code> 注解的解析流程</span></a></h3><ul><li>当 Spring 容器初始化时，会扫描并解析所有的 Bean 定义。</li><li><code>AutowiredAnnotationBeanPostProcessor</code> 会在 Spring 容器初始化后被注册为一个 Bean 后处理器（BeanPostProcessor）。</li><li>每当一个 Bean 实例化时，<code>AutowiredAnnotationBeanPostProcessor</code> 会扫描该 Bean 是否含有 <code>@Autowired</code> 注解。</li><li>如果该 Bean 有 <code>@Autowired</code> 注解，<code>AutowiredAnnotationBeanPostProcessor</code> 会根据 Bean 的类型、名称等信息，执行依赖注入操作。</li></ul><h3 id="核心代码" tabindex="-1"><a class="header-anchor" href="#核心代码"><span>核心代码</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> postProcessAfterInitialization</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> bean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName) throws BeansException {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 扫描所有字段和方法，找到@Autowired注解</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    AutowiredAnnotationBeanPostProcessor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">autowireBeanProperties</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(bean, beanName, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">beanFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> bean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码展示了 <code>AutowiredAnnotationBeanPostProcessor</code> 的主要作用，即在初始化后处理 Bean，进行依赖注入。</p><hr><h2 id="_2-依赖查找与依赖注入的区别" tabindex="-1"><a class="header-anchor" href="#_2-依赖查找与依赖注入的区别"><span>2. 依赖查找与依赖注入的区别</span></a></h2><p>依赖查找和依赖注入是 Spring 中常见的两种方式，但它们有着本质的区别。</p><h3 id="依赖查找-dependency-lookup" tabindex="-1"><a class="header-anchor" href="#依赖查找-dependency-lookup"><span>依赖查找（Dependency Lookup）</span></a></h3><p>依赖查找是指容器通过某些方式查找已经注册到容器中的 Bean。例如，使用 <code>ApplicationContext.getBean()</code> 方法查找 Bean。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> someMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    MyService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myService </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> context</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MyService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依赖查找的方式较为显式，开发者需要主动去查找 Bean。</p><h3 id="依赖注入-dependency-injection" tabindex="-1"><a class="header-anchor" href="#依赖注入-dependency-injection"><span>依赖注入（Dependency Injection）</span></a></h3><p>依赖注入是 Spring 提供的另一种方式，通过注解（如 <code>@Autowired</code>）或 XML 配置，容器会自动注入所需的 Bean。Spring 容器会在对象创建时自动将依赖对象注入其中，开发者不需要显式地查找。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h3><ul><li><strong>依赖查找</strong>：开发者显式查找 Bean，通过 <code>getBean</code> 方法获取。</li><li><strong>依赖注入</strong>：Spring 自动将需要的 Bean 注入到指定的属性中，减少了显式查找和手动配置的复杂度。</li></ul><hr><h2 id="_3-defaultlistablebeanfactory-的作用与核心方法" tabindex="-1"><a class="header-anchor" href="#_3-defaultlistablebeanfactory-的作用与核心方法"><span>3. <code>DefaultListableBeanFactory</code> 的作用与核心方法</span></a></h2><p><code>DefaultListableBeanFactory</code> 是 Spring 框架中最常用的 BeanFactory 实现类，主要负责 Bean 的创建、管理、依赖注入等功能。它实现了 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 接口，具有管理和维护 Bean 的能力。</p><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h3><ul><li>负责注册和管理 Bean 实例。</li><li>存储所有的 Bean 定义（<code>BeanDefinition</code>）。</li><li>管理 Bean 的生命周期、依赖注入以及各种配置。</li></ul><h3 id="核心方法" tabindex="-1"><a class="header-anchor" href="#核心方法"><span>核心方法</span></a></h3><ul><li><p><strong><code>getBeanDefinition()</code></strong>：从容器中获取指定 Bean 的定义。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanDefinition</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getBeanDefinition</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName) throws NoSuchBeanDefinitionException {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    BeanDefinition</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> beanDefinition </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">beanDefinitionMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (beanDefinition </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> NoSuchBeanDefinitionException</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(beanName)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanDefinition</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong><code>registerBeanDefinition()</code></strong>：向容器注册新的 Bean 定义。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> registerBeanDefinition</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanDefinition</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanDefinition) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">beanDefinitionMap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName, beanDefinition);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong><code>createBean()</code></strong>：创建 Bean 实例并执行依赖注入。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createBean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RootBeanDefinition</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> mbd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] args) throws BeanCreationException {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> doCreateBean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> mbd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> args)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h2 id="_4-注入顺序与循环依赖的解决机制-三级缓存解析" tabindex="-1"><a class="header-anchor" href="#_4-注入顺序与循环依赖的解决机制-三级缓存解析"><span>4. 注入顺序与循环依赖的解决机制（三级缓存解析）</span></a></h2><p>在 Spring 中，依赖注入的顺序非常重要，尤其是在涉及到循环依赖的情况下。Spring 通过三级缓存（singletonObjects、earlySingletonObjects、singletonFactories）来解决循环依赖问题。</p><h3 id="注入顺序" tabindex="-1"><a class="header-anchor" href="#注入顺序"><span>注入顺序</span></a></h3><p>Spring 容器在创建 Bean 时，会先通过 <code>getBean()</code> 方法查找所需的 Bean。根据 Bean 的类型和依赖关系，容器会依次执行以下步骤：</p><ol><li><strong>检查容器中是否已有 Bean 实例</strong>。</li><li><strong>如果 Bean 不存在，则创建 Bean 实例</strong>。</li><li><strong>执行依赖注入操作</strong>：容器会自动扫描并注入依赖对象。</li></ol><h3 id="循环依赖的解决机制" tabindex="-1"><a class="header-anchor" href="#循环依赖的解决机制"><span>循环依赖的解决机制</span></a></h3><p>Spring 通过三级缓存机制来解决循环依赖问题。</p><ul><li><strong><code>singletonObjects</code></strong>：用于存储已经实例化并且初始化完成的 Bean。</li><li><strong><code>earlySingletonObjects</code></strong>：用于存储已经实例化但还未完全初始化的 Bean（即还在创建中的 Bean）。</li><li><strong><code>singletonFactories</code></strong>：用于存储尚未实例化的 Bean 的工厂方法。</li></ul><p>Spring 的循环依赖解决方案如下：</p><ol><li><strong>实例化 Bean</strong>：Spring 首先尝试实例化 Bean，但是此时 Bean 还没有完成所有依赖注入操作。</li><li><strong>解决循环依赖</strong>：在实例化过程中，如果遇到依赖关系，Spring 会先将 Bean 放入 <code>earlySingletonObjects</code> 中，然后尝试注入其依赖的 Bean。如果依赖的 Bean 还没有完全初始化，它会从 <code>earlySingletonObjects</code> 中进行查找。</li><li><strong>完成 Bean 初始化</strong>：当所有依赖都注入完成时，Spring 会将 Bean 放入 <code>singletonObjects</code> 中，表示该 Bean 创建完成，依赖注入结束。</li></ol><h3 id="核心代码示例" tabindex="-1"><a class="header-anchor" href="#核心代码示例"><span>核心代码示例</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">protected</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createBean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RootBeanDefinition</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> mbd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] args) throws BeanCreationException {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 三级缓存机制</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bean </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">singletonFactories</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (bean </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        bean </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> doCreateBean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(beanName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> mbd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> args)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">singletonObjects</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(beanName, bean);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> bean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过三级缓存的机制，Spring 能够在实例化 Bean 时解决循环依赖问题，确保依赖注入的顺利进行。</p><hr><h2 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h2><p>通过深入分析源码，我们能够更好地理解 Spring 依赖注入（DI）机制的实现。从 <code>@Autowired</code> 注解的处理到容器的创建，Spring 提供了强大且灵活的 DI 机制。在解决循环依赖等问题时，Spring 通过三级缓存有效避免了潜在的死循环问题。在实际开发中，理解这些底层实现原理能够帮助我们更好地调试、优化和使用 Spring 框架。</p><h1 id="十、常见问题与性能调优建议-1" tabindex="-1"><a class="header-anchor" href="#十、常见问题与性能调优建议-1"><span>十、常见问题与性能调优建议</span></a></h1><p>在使用 Spring 框架进行开发时，常常会遇到一些常见的问题或性能瓶颈。了解这些问题并掌握调试技巧与优化建议，可以帮助开发者在实际项目中提升 Spring 应用的稳定性与性能。本章将围绕循环依赖、Bean 覆盖、启动优化等常见问题进行详细讨论。</p><hr><h2 id="_1-循环依赖的问题与调试技巧" tabindex="-1"><a class="header-anchor" href="#_1-循环依赖的问题与调试技巧"><span>1. 循环依赖的问题与调试技巧</span></a></h2><h3 id="_1-1-什么是循环依赖" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是循环依赖"><span>1.1 什么是循环依赖</span></a></h3><p>循环依赖是指两个或多个 Bean 在依赖注入过程中相互依赖，从而形成一个闭环。这种情况会导致 Spring 无法完成 Bean 的实例化，因为一个 Bean 的创建需要另一个 Bean，而另一个 Bean 又需要第一个 Bean。</p><p>例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> B</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> B</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种情况下，A 和 B 相互依赖，Spring 将无法完成依赖注入。</p><h3 id="_1-2-循环依赖的解决机制" tabindex="-1"><a class="header-anchor" href="#_1-2-循环依赖的解决机制"><span>1.2 循环依赖的解决机制</span></a></h3><p>Spring 通过三级缓存机制（<code>singletonObjects</code>、<code>earlySingletonObjects</code>、<code>singletonFactories</code>）来解决循环依赖问题。当出现循环依赖时，Spring 会将创建中的 Bean 先放入 <code>earlySingletonObjects</code>，然后注入其依赖。当循环依赖的 Bean 最终完成实例化后，Spring 会将其放入 <code>singletonObjects</code> 中。</p><h3 id="_1-3-循环依赖调试技巧" tabindex="-1"><a class="header-anchor" href="#_1-3-循环依赖调试技巧"><span>1.3 循环依赖调试技巧</span></a></h3><ul><li><p><strong>启用日志</strong>：Spring 提供了详细的日志记录，可以通过增加日志级别来查看 Bean 的创建过程。设置日志级别为 <code>DEBUG</code> 或 <code>TRACE</code>，观察 Bean 加载的顺序和创建过程。</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">logging.level.org.springframework.beans.factory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">DEBUG</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">logging.level.org.springframework.context.annotation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">DEBUG</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>检查 Bean 的作用域</strong>：循环依赖问题通常出现在单例 Bean 上，确保在开发过程中避免不必要的循环依赖。检查是否可以通过调整 Bean 的作用域（如使用 <code>@Scope(&quot;prototype&quot;)</code>）来避免循环依赖。</p></li></ul><hr><h2 id="_2-bean-覆盖与冲突排查" tabindex="-1"><a class="header-anchor" href="#_2-bean-覆盖与冲突排查"><span>2. Bean 覆盖与冲突排查</span></a></h2><h3 id="_2-1-bean-覆盖问题" tabindex="-1"><a class="header-anchor" href="#_2-1-bean-覆盖问题"><span>2.1 Bean 覆盖问题</span></a></h3><p>当在 Spring 容器中定义了两个具有相同名称的 Bean 时，Spring 会默认使用最后一个定义的 Bean 覆盖先前的 Bean。如果你没有意识到这一点，可能会导致应用程序出现不一致的行为或不正确的配置。</p><h3 id="_2-2-bean-覆盖的排查技巧" tabindex="-1"><a class="header-anchor" href="#_2-2-bean-覆盖的排查技巧"><span>2.2 Bean 覆盖的排查技巧</span></a></h3><ul><li><p><strong>启用 Bean 覆盖警告</strong>：Spring 默认情况下不会提示 Bean 覆盖的警告。但你可以通过在配置文件中设置 <code>allowBeanDefinitionOverriding</code> 属性为 <code>false</code> 来阻止 Bean 覆盖。</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">spring.main.allow-bean-definition-overriding</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>手动排查 Bean 定义</strong>：通过 <code>@Qualifier</code> 或明确指定 Bean 名称来避免自动覆盖。在注入 Bean 时，使用明确的 Bean 名称来解决冲突。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Qualifier</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;beanName&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>XML 配置时注意冲突</strong>：如果你使用 XML 配置 Bean，确保每个 Bean 的 ID 唯一。可以通过不同的名称来区分不同的 Bean。</p></li></ul><hr><h2 id="_3-启动速度慢-bean-加载优化建议" tabindex="-1"><a class="header-anchor" href="#_3-启动速度慢-bean-加载优化建议"><span>3. 启动速度慢？Bean 加载优化建议</span></a></h2><p>Spring 启动时，需要加载大量的 Bean 和进行依赖注入。如果 Bean 数量很多或存在复杂的依赖关系，可能会导致启动时间过长。以下是一些常见的优化建议：</p><h3 id="_3-1-启动优化策略" tabindex="-1"><a class="header-anchor" href="#_3-1-启动优化策略"><span>3.1 启动优化策略</span></a></h3><ul><li><p><strong>懒加载（<code>@Lazy</code>）</strong>：对于一些不常用的 Bean，可以通过 <code>@Lazy</code> 注解延迟加载，避免在启动时进行不必要的 Bean 实例化。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Lazy</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SomeService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> someService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>组件扫描优化</strong>：通过指定扫描的包路径，减少不必要的类扫描。避免全局扫描所有类，尤其是在大型项目中。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ComponentScan</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">basePackages</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;com.example.services&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>Profile 配置</strong>：使用 Spring Profiles 根据不同环境配置不同的 Bean。通过启用或禁用某些 Bean，减少不必要的 Bean 加载。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Profile</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;dev&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DevService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> devService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DevService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_3-2-使用-spring-boot-的-enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#_3-2-使用-spring-boot-的-enableautoconfiguration"><span>3.2 使用 Spring Boot 的 <code>@EnableAutoConfiguration</code></span></a></h3><p>Spring Boot 提供的自动配置机制能够通过条件化装配来优化 Bean 加载。可以禁用某些不必要的自动配置来减少启动时间。</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">spring.autoconfigure.exclude</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_3-3-其他优化建议" tabindex="-1"><a class="header-anchor" href="#_3-3-其他优化建议"><span>3.3 其他优化建议</span></a></h3><ul><li><strong>Bean 定义懒加载</strong>：将一些不必要的 Bean 配置为懒加载，避免它们在启动时就被加载。</li><li><strong>并行初始化</strong>：通过 Spring 的异步初始化功能，启用并行加载 Bean，提升启动速度。</li></ul><hr><h2 id="_4-lazy-与-bean-延迟加载" tabindex="-1"><a class="header-anchor" href="#_4-lazy-与-bean-延迟加载"><span>4. <code>@Lazy</code> 与 Bean 延迟加载</span></a></h2><h3 id="_4-1-lazy-注解的作用" tabindex="-1"><a class="header-anchor" href="#_4-1-lazy-注解的作用"><span>4.1 <code>@Lazy</code> 注解的作用</span></a></h3><p><code>@Lazy</code> 注解用于标记 Bean 为延迟加载，Spring 容器在启动时不会立即实例化该 Bean，而是等到实际需要时才进行实例化。这在启动速度优化中非常有用，特别是当某些 Bean 不常用时。</p><h3 id="_4-2-使用场景" tabindex="-1"><a class="header-anchor" href="#_4-2-使用场景"><span>4.2 使用场景</span></a></h3><ul><li><p><strong>减少启动时间</strong>：对于启动时不需要立即加载的 Bean，可以使用 <code>@Lazy</code> 注解。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Lazy</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>按需加载依赖</strong>：某些依赖可能在整个应用程序的生命周期中并不总是需要。通过 <code>@Lazy</code> 注解，可以在第一次使用时才加载。</p></li></ul><h3 id="_4-3-与-primary-配合使用" tabindex="-1"><a class="header-anchor" href="#_4-3-与-primary-配合使用"><span>4.3 与 <code>@Primary</code> 配合使用</span></a></h3><p>当一个类有多个 Bean 需要注入时，可以使用 <code>@Primary</code> 和 <code>@Lazy</code> 结合，确保默认的 Bean 会在需要时加载。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Primary</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Lazy</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyServiceImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="总结-3" tabindex="-1"><a class="header-anchor" href="#总结-3"><span>总结</span></a></h2><p>本章讨论了 Spring 中常见的问题与性能调优建议，包括循环依赖的解决、Bean 覆盖与冲突的排查、启动优化以及如何使用 <code>@Lazy</code> 注解实现 Bean 的延迟加载。通过这些优化策略和调试技巧，开发者可以在面对复杂应用时，提升应用的性能和稳定性。理解这些常见问题的根源与解决方法，有助于在实际项目中处理复杂场景，提高开发效率。</p><h1 id="十一、面试重点与高频问题总结-1" tabindex="-1"><a class="header-anchor" href="#十一、面试重点与高频问题总结-1"><span>十一、面试重点与高频问题总结</span></a></h1><p>在面试中，Spring Core 相关的知识点是非常重要的一部分。掌握一些面试中的高频问题，能够帮助你更好地展示你的 Spring 知识水平。以下是常见的面试问题与重点总结，涵盖了 IoC、DI、<code>@Autowired</code> 注解的使用、Bean 生命周期回调、循环依赖等方面。</p><hr><h2 id="_1-ioc-与-di-的区别与联系" tabindex="-1"><a class="header-anchor" href="#_1-ioc-与-di-的区别与联系"><span>1. IoC 与 DI 的区别与联系</span></a></h2><h3 id="_1-1-ioc-控制反转" tabindex="-1"><a class="header-anchor" href="#_1-1-ioc-控制反转"><span>1.1 IoC（控制反转）</span></a></h3><p>IoC 是一种设计原则，通过它，控制权从程序中转移到容器中。在传统的开发模式中，应用程序通过代码直接控制对象的创建和依赖，而 IoC 将这一过程交给了 Spring 容器来管理。Spring 容器根据配置（如 XML 配置、Java 注解等）负责创建、配置和管理 Bean，并负责它们之间的依赖关系。</p><h3 id="_1-2-di-依赖注入" tabindex="-1"><a class="header-anchor" href="#_1-2-di-依赖注入"><span>1.2 DI（依赖注入）</span></a></h3><p>DI 是 IoC 的一种实现方式。DI 允许将一个对象所依赖的其他对象通过注入的方式传递给它，而不是让对象自己创建这些依赖。在 Spring 中，依赖注入主要通过构造器注入、Setter 方法注入以及字段注入来实现。</p><h3 id="_1-3-区别与联系" tabindex="-1"><a class="header-anchor" href="#_1-3-区别与联系"><span>1.3 区别与联系</span></a></h3><ul><li><strong>联系</strong>：IoC 是控制反转的设计思想，DI 是 IoC 的一种实现方式。DI 通过注入依赖对象来实现 IoC。</li><li><strong>区别</strong>：IoC 更注重控制的转移（控制权交给容器），而 DI 关心的是如何把依赖关系注入到对象中。</li></ul><hr><h2 id="_2-autowired-的原理与使用细节" tabindex="-1"><a class="header-anchor" href="#_2-autowired-的原理与使用细节"><span>2. <code>@Autowired</code> 的原理与使用细节</span></a></h2><h3 id="_2-1-autowired-原理" tabindex="-1"><a class="header-anchor" href="#_2-1-autowired-原理"><span>2.1 <code>@Autowired</code> 原理</span></a></h3><p><code>@Autowired</code> 是 Spring 提供的一个注解，用于自动注入依赖对象。当 Spring 容器创建 Bean 时，会根据字段类型、构造器或 Setter 方法来自动装配所需要的依赖。具体过程如下：</p><ul><li>Spring 会查找与 <code>@Autowired</code> 注解标记的字段、构造器或方法所需要的 Bean。</li><li>如果找到唯一的匹配 Bean，则会进行注入。</li><li>如果没有找到匹配的 Bean，则会抛出异常，除非设置 <code>@Autowired</code> 的 <code>required=false</code> 属性，表示允许没有依赖时为空。</li></ul><h3 id="_2-2-使用细节" tabindex="-1"><a class="header-anchor" href="#_2-2-使用细节"><span>2.2 使用细节</span></a></h3><ul><li><p><strong>自动装配策略</strong>：可以通过 <code>@Autowired</code> 标注在字段、构造器和 Setter 方法上。</p></li><li><p><strong><code>@Qualifier</code> 的配合使用</strong>：如果容器中有多个相同类型的 Bean，则需要使用 <code>@Qualifier</code> 来指定注入哪个 Bean。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Qualifier</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myServiceBean&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>注入多个 Bean</strong>：通过使用 <code>@Autowired</code> 和 <code>@Qualifier</code>，可以注入多个相同类型的 Bean。</p></li><li><p><strong><code>@Autowired</code> 在构造器中的使用</strong>：推荐使用构造器注入，因为它是不可变的，且不容易出错。</p></li></ul><hr><h2 id="_3-bean-生命周期回调顺序问题" tabindex="-1"><a class="header-anchor" href="#_3-bean-生命周期回调顺序问题"><span>3. Bean 生命周期回调顺序问题</span></a></h2><h3 id="_3-1-bean-生命周期流程" tabindex="-1"><a class="header-anchor" href="#_3-1-bean-生命周期流程"><span>3.1 Bean 生命周期流程</span></a></h3><p>Spring 管理的 Bean 具有明确的生命周期。以下是 Bean 生命周期的关键步骤：</p><ol><li><strong>实例化</strong>：容器实例化 Bean。</li><li><strong>依赖注入</strong>：Spring 将 Bean 所依赖的其他 Bean 注入到当前 Bean。</li><li><strong>初始化</strong>：Spring 调用 Bean 的初始化方法。可以通过 <code>@PostConstruct</code> 注解或者实现 <code>InitializingBean</code> 接口来定义初始化方法。</li><li><strong>销毁</strong>：在 Bean 被销毁之前，Spring 会调用销毁方法。可以通过 <code>@PreDestroy</code> 注解或者实现 <code>DisposableBean</code> 接口来定义销毁方法。</li></ol><h3 id="_3-2-bean-生命周期回调顺序" tabindex="-1"><a class="header-anchor" href="#_3-2-bean-生命周期回调顺序"><span>3.2 Bean 生命周期回调顺序</span></a></h3><ul><li><code>@PostConstruct</code> 注解的方法会在 Bean 的所有依赖注入完成后调用，初始化之前。</li><li><code>@PreDestroy</code> 注解的方法会在容器销毁 Bean 之前调用。</li><li>通过实现 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet</code> 方法进行初始化，通过 <code>DisposableBean</code> 接口的 <code>destroy</code> 方法进行销毁。</li></ul><p><strong>注意</strong>：<code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解的方法优先级较高，Spring 会在默认生命周期的前后调用这些方法。</p><hr><h2 id="_4-如何解决循环依赖-三级缓存机制详解" tabindex="-1"><a class="header-anchor" href="#_4-如何解决循环依赖-三级缓存机制详解"><span>4. 如何解决循环依赖？三级缓存机制详解</span></a></h2><h3 id="_4-1-循环依赖问题" tabindex="-1"><a class="header-anchor" href="#_4-1-循环依赖问题"><span>4.1 循环依赖问题</span></a></h3><p>循环依赖发生在两个或多个 Bean 互相依赖的情况下，Spring 容器无法完成 Bean 的初始化。例如，Bean A 依赖 Bean B，而 Bean B 又依赖 Bean A，形成了一个循环。</p><h3 id="_4-2-解决机制-三级缓存" tabindex="-1"><a class="header-anchor" href="#_4-2-解决机制-三级缓存"><span>4.2 解决机制：三级缓存</span></a></h3><p>Spring 使用三级缓存机制来解决循环依赖问题。这个机制分为三个步骤：</p><ol><li><strong>一级缓存 (<code>singletonObjects</code>)</strong>：这是标准的 Bean 存储缓存，包含所有已经完全实例化的 Bean。</li><li><strong>二级缓存 (<code>earlySingletonObjects</code>)</strong>：这个缓存用于存储已经实例化但尚未完全依赖注入的 Bean。在 Bean 创建过程中，当 Bean 被初始化时，Spring 会把它放到这个缓存中，避免循环依赖。</li><li><strong>三级缓存 (<code>singletonFactories</code>)</strong>：这个缓存用于存储待创建 Bean 的工厂方法。在 Bean 实例化时，Spring 会先创建 Bean 的工厂方法，并把工厂方法放到三级缓存中，当需要时再调用工厂方法创建 Bean。</li></ol><p>当 Spring 容器发现一个 Bean 的依赖是一个尚未完成实例化的 Bean 时，容器会首先从二级缓存中查找该 Bean。如果找不到，则从三级缓存中获取该 Bean 的工厂方法，并在工厂方法调用后放入二级缓存中。</p><h3 id="_4-3-实例化-bean-与依赖注入的关系" tabindex="-1"><a class="header-anchor" href="#_4-3-实例化-bean-与依赖注入的关系"><span>4.3 实例化 Bean 与依赖注入的关系</span></a></h3><ul><li>Spring 在处理 Bean 的实例化和依赖注入时，采用了递归调用的方式。如果遇到循环依赖，Spring 会在二级缓存中暂存 Bean 实例，并在循环依赖解析完毕后再完成 Bean 的依赖注入。</li><li>在 Singleton 范围的 Bean 中，循环依赖是允许的，但 Spring 会采取适当的措施来解决这个问题，而在 Prototype 范围的 Bean 中，循环依赖将无法处理，Spring 会抛出异常。</li></ul><hr><h2 id="总结-4" tabindex="-1"><a class="header-anchor" href="#总结-4"><span>总结</span></a></h2><p>在面试中，Spring Core 相关的知识是不可忽视的，尤其是 IoC、DI、Bean 生命周期、<code>@Autowired</code> 的原理、循环依赖的解决方案等问题。理解这些知识点的原理与细节，能够帮助你在面试中脱颖而出，展现出扎实的 Spring 技能。同时，掌握面试中常见问题的解答方式和解决方案，能够让你更加自信地应对面试挑战。</p><h1 id="十二、最佳实践与经验总结-1" tabindex="-1"><a class="header-anchor" href="#十二、最佳实践与经验总结-1"><span>十二、最佳实践与经验总结</span></a></h1><p>在实际开发中，Spring 的使用不仅仅停留在基础的框架应用层面，更涉及到如何在项目中正确地组织、配置和管理 Spring Bean，如何提高配置类的可读性和可维护性，以及如何合理地管理不同环境下的配置。以下是一些常见的最佳实践与经验总结，帮助开发者在日常使用 Spring 时提升工作效率和代码质量。</p><hr><h2 id="_1-配置类推荐写法-可读性、可维护性、可扩展性" tabindex="-1"><a class="header-anchor" href="#_1-配置类推荐写法-可读性、可维护性、可扩展性"><span>1. 配置类推荐写法：可读性、可维护性、可扩展性</span></a></h2><h3 id="_1-1-配置类的组织结构" tabindex="-1"><a class="header-anchor" href="#_1-1-配置类的组织结构"><span>1.1 配置类的组织结构</span></a></h3><ul><li><strong>单一职责原则</strong>：配置类应该只负责配置特定的 Bean，而不应该承担其他职责。避免配置类过于庞大，导致可读性差。比如，可以将数据库相关的配置、消息队列相关的配置分开到不同的配置类中。</li><li><strong>模块化配置</strong>：根据业务模块划分配置类，避免配置类过于冗杂。每个配置类对应一个功能模块，例如：数据库配置类、消息队列配置类、安全配置类等。</li></ul><h3 id="_1-2-使用注解提升可读性" tabindex="-1"><a class="header-anchor" href="#_1-2-使用注解提升可读性"><span>1.2 使用注解提升可读性</span></a></h3><ul><li><p>使用 <code>@Configuration</code> 注解来标识配置类。</p></li><li><p>对于每一个 Bean 的定义，都可以通过清晰的命名和适当的注释来提高可读性。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">ComponentScan</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">basePackages</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;com.example.service&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ServiceConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 业务相关的配置</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_1-3-避免过度依赖-xml-配置" tabindex="-1"><a class="header-anchor" href="#_1-3-避免过度依赖-xml-配置"><span>1.3 避免过度依赖 XML 配置</span></a></h3><p>虽然 Spring 传统上支持通过 XML 配置文件来定义 Bean，但 Java 配置（基于 <code>@Configuration</code>）通常更加清晰、易于维护，且支持类型安全。尽量避免过度依赖 XML 配置，而是推荐使用 Java 配置类。</p><h3 id="_1-4-使用工厂方法简化复杂的-bean-创建" tabindex="-1"><a class="header-anchor" href="#_1-4-使用工厂方法简化复杂的-bean-创建"><span>1.4 使用工厂方法简化复杂的 Bean 创建</span></a></h3><p>对于复杂的 Bean 创建，可以使用工厂方法或者静态工厂方法来简化 Bean 的配置。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DataSource</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> DataSourceBuilder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">url</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;jdbc:mysql://localhost:3306/db&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">build</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-配置类的可扩展性" tabindex="-1"><a class="header-anchor" href="#_1-5-配置类的可扩展性"><span>1.5 配置类的可扩展性</span></a></h3><ul><li><p><strong>接口与继承</strong>：当需要扩展配置类时，尽量采用接口与继承的方式，确保配置的可扩展性。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Import</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MyServiceConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MainConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 引入其他配置类</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>组件扫描与自动配置</strong>：利用 <code>@ComponentScan</code> 和自动配置机制来确保新的 Bean 或配置能够被自动识别和注册。</p></li></ul><hr><h2 id="_2-项目中如何合理分层管理-bean-定义" tabindex="-1"><a class="header-anchor" href="#_2-项目中如何合理分层管理-bean-定义"><span>2. 项目中如何合理分层管理 Bean 定义</span></a></h2><p>在实际开发中，为了提高项目的可维护性与可扩展性，Spring Bean 的定义应该遵循一定的分层原则。通常，我们会按照功能和职责将 Bean 分为多个层次，并将每一层的 Bean 配置在不同的配置类中。</p><h3 id="_2-1-分层管理原则" tabindex="-1"><a class="header-anchor" href="#_2-1-分层管理原则"><span>2.1 分层管理原则</span></a></h3><ul><li><strong>表示层（Controller）</strong>：负责接收前端请求并返回视图或数据，通常使用 <code>@Controller</code> 或 <code>@RestController</code> 注解来定义 Bean。可以放在专门的 <code>WebConfig</code> 配置类中。</li><li><strong>业务层（Service）</strong>：负责处理核心业务逻辑，通常使用 <code>@Service</code> 注解来定义 Bean。将业务逻辑配置类与其他服务类分开，避免混乱。</li><li><strong>数据访问层（Repository/DAO）</strong>：负责与数据库进行交互，通常使用 <code>@Repository</code> 注解来定义 Bean。可以将数据访问层的 Bean 配置在单独的 <code>DataSourceConfig</code> 或 <code>RepositoryConfig</code> 类中。</li><li><strong>共享工具类（Utility）</strong>：一些共享的工具类（如日志、消息发送等）可以统一放在 <code>UtilityConfig</code> 中进行配置和管理。</li></ul><h3 id="_2-2-使用模块化配置" tabindex="-1"><a class="header-anchor" href="#_2-2-使用模块化配置"><span>2.2 使用模块化配置</span></a></h3><p>每个模块的配置都可以有一个独立的配置类，避免所有 Bean 定义都堆积在一个配置类中。这样可以提升代码的可读性、可维护性，并且减少不必要的耦合。</p><p>例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Import</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">({</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ServiceConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> RepositoryConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AppConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 核心应用配置</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 <code>@Import</code> 注解，模块之间的配置可以更加清晰和独立。</p><h3 id="_2-3-使用-primary-与-qualifier-注解避免冲突" tabindex="-1"><a class="header-anchor" href="#_2-3-使用-primary-与-qualifier-注解避免冲突"><span>2.3 使用 <code>@Primary</code> 与 <code>@Qualifier</code> 注解避免冲突</span></a></h3><p>当多个 Bean 的类型相同，但功能不同，需要明确指定注入哪个 Bean 时，可以使用 <code>@Primary</code> 注解来标记默认的 Bean，或者使用 <code>@Qualifier</code> 来精确指定注入的 Bean。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Primary</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> defaultMyService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyServiceImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Qualifier</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;specialService&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyService</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> specialService</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SpecialServiceImpl</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-测试环境与生产环境下的配置切换策略-结合-profile" tabindex="-1"><a class="header-anchor" href="#_3-测试环境与生产环境下的配置切换策略-结合-profile"><span>3. 测试环境与生产环境下的配置切换策略（结合 <code>@Profile</code>）</span></a></h2><p>在开发过程中，通常需要在不同环境（如开发、测试、生产等）之间切换配置。Spring 提供了 <code>@Profile</code> 注解来实现基于环境的配置切换。</p><h3 id="_3-1-使用-profile-切换配置" tabindex="-1"><a class="header-anchor" href="#_3-1-使用-profile-切换配置"><span>3.1 使用 <code>@Profile</code> 切换配置</span></a></h3><p>通过 <code>@Profile</code> 注解，我们可以为不同的环境提供不同的 Bean 配置。例如，可以为开发环境配置一个数据源，而为生产环境配置一个不同的数据源。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Profile</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;dev&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DevConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DataSource</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> devDataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;dev-db-url&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Profile</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;prod&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ProdConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Bean</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DataSource</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> prodDataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DataSource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;prod-db-url&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-激活配置文件" tabindex="-1"><a class="header-anchor" href="#_3-2-激活配置文件"><span>3.2 激活配置文件</span></a></h3><ul><li><p><strong>通过 <code>application.properties</code> 或 <code>application.yml</code> 配置文件激活环境</strong>：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#C678DD;">spring.profiles.active</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#98C379;">dev</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>在命令行中通过 <code>-D</code> 参数设置</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">java</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -jar</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> app.jar</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --spring.profiles.active=prod</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="_3-3-配置切换的最佳实践" tabindex="-1"><a class="header-anchor" href="#_3-3-配置切换的最佳实践"><span>3.3 配置切换的最佳实践</span></a></h3><ul><li><strong>避免硬编码</strong>：不要将硬编码的环境信息直接写在代码中，而是使用配置文件或环境变量来管理。</li><li><strong>分离不同环境的配置</strong>：将开发、测试和生产环境的配置分离，并根据环境激活相应的配置类。</li><li><strong>统一的配置文件管理</strong>：使用 Spring Cloud Config 或类似工具集中管理不同环境的配置，以保证在生产环境中配置的安全性和一致性。</li></ul><hr><h2 id="总结-5" tabindex="-1"><a class="header-anchor" href="#总结-5"><span>总结</span></a></h2><p>Spring 提供了灵活的配置和管理方式，但要在项目中实现高效、可维护的配置管理，必须遵循一定的最佳实践和设计原则。通过合理地组织配置类、分层管理 Bean、结合 <code>@Profile</code> 注解切换环境配置，可以大大提高项目的可扩展性和可维护性。同时，遵循清晰、模块化的配置管理策略，可以使得项目在不同环境中的运行更加顺畅，减少因环境配置问题引发的错误。</p>`,479)]))}const r=s(l,[["render",h]]),k=JSON.parse('{"path":"/1.%E5%AD%A6%E4%B9%A0%E7%AF%87/2.Spring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/1.Spring%20Core.html","title":"1.Spring Core","lang":"en-US","frontmatter":{"title":"1.Spring Core"},"git":{},"readingTime":{"minutes":41.78,"words":12533},"filePathRelative":"1.学习篇/2.Spring生态系统/1.Spring Core.md"}');export{r as comp,k as data};
